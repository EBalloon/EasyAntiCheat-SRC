/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall EAC_HashCR32(_BYTE *buffer, unsigned int bufferSize);
int __fastcall sub_140009D88(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
void __fastcall sub_140009E9C(__int64 a1);
char __fastcall sub_14000A0BC(__int64 a1);
__int64 *__fastcall sub_14000A24C(__int64 **a1);
void __fastcall sub_14000A36C(int *a1);
unsigned int *__fastcall sub_14000A554(__int64 a1, unsigned __int8 (__fastcall *a2)(unsigned int *, __int64, __int64), __int64 a3, __int64 a4);
unsigned __int64 sub_14000AC40();
char __fastcall sub_14000B018(__int64 Process, unsigned __int64 Address, unsigned __int64 RegionSize, int Length);
char __fastcall EAC_Allocate_ProcessVirtualMemory_2(__int64 Process, struct_eData *eData);
char __fastcall sub_14000B1F0(__int64 Process, _QWORD *eData);
char __fastcall sub_14000B330(__int64 Process, _QWORD *aData);
char __fastcall sub_14000B450(__int64 Process, struct_eData_5 *eData);
char __fastcall sub_14000B53C(__int64 Process, struct_eData_8 *eData);
char __fastcall EAC_NtFlushVirtualMemory(__int64 Process, struct_eData_4 *eData);
void __fastcall sub_14000B6D0(void **aData, struct_a2 *gData, _DWORD *OutLenght);
__int64 __fastcall sub_14000C7A4(__int64 a1);
__int64 __fastcall sub_14000CCBC(__int64, __int64, __int64, __int64);
__int64 *__fastcall sub_14000D7E8(__int64 ProcessId);
__int64 *__fastcall sub_14000D890(__int64);
void __fastcall sub_14000D924(__int64);
char __fastcall sub_1400105B8(char *a1, int a2, __int64 a3, _OWORD *a4);
char __fastcall sub_1400106D0(__int64, int, __int64, int, __m128 *);
bool __fastcall sub_1400109F0(char *a1, int a2, __m128 *a3);
__int64 __fastcall sub_140010B2C(__int64, __int64);
__int64 __fastcall sub_140010C68(__int64, __int64, unsigned __int64);
__m128 *__fastcall sub_140010D8C(__m128 *a1);
__int64 __fastcall sub_140010DD8(_DWORD *, _DWORD *);
__int64 __fastcall MmVirtualMemory(__int64 SourceAddress, __int64 NumberOfBytes, __int64 TargetAddress);
__int64 __fastcall sub_140015FB0(__int64 a1, __int64 a2);
char __fastcall sub_140016288(__int64 a1);
int __fastcall sub_140016330(__int64 a1);
char __fastcall sub_1400179F8(unsigned __int64 BaseAddress, unsigned int Size, unsigned __int64 *a3);
char sub_140019DA8();
void sub_14001A460();
__int64 __fastcall EAC_Allocate_Memory(unsigned __int64 Size);
__int64 __fastcall Get_ExFreePool(__int64 Buffer);
ULONG64 __fastcall EAC_IsUsermodeValidAddress(ULONG64 Address, __int64 Size, int Flag);
char __fastcall sub_14001D338(char *Address, __int64 Size);
_IMAGE_NT_HEADERS *__fastcall Get_Nt_Headers(__int64 BaseAddress, unsigned __int64 Size);
char __fastcall GetModuleInfo(__int64 BaseAddress, unsigned __int64 Size, _QWORD *AddressOut, __int64 *NtHeadersOut);
_DWORD *__fastcall sub_14001D56C(unsigned __int64 Address, _IMAGE_NT_HEADERS *NtHeaders, __int64 BaseAddress);
__int64 __fastcall sub_14001D5A0(unsigned __int64 a1, __int64 a2, __int64 a3);
unsigned int *__fastcall sub_14001D80C(__int64 a1);
__int64 __fastcall sub_14001D99C(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_14001DBF4(unsigned __int64 a1, unsigned __int64 a2, _BYTE *a3);
unsigned __int64 __fastcall sub_14001E220(__int64, unsigned __int16 *, unsigned int, unsigned int, _BYTE *);
char *__fastcall sub_14001E410(unsigned __int64 a1, unsigned __int64 a2, _BYTE *a3);
bool __fastcall sub_14001EF84(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
void sub_1400208F8();
__int64 __fastcall sub_1400210C8(unsigned __int8 *, __int64);
__int64 __fastcall sub_140022858(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_140022FFC(PFAST_MUTEX FastMutex, __int64 a2);
void __fastcall sub_1400230F8(PFAST_MUTEX FastMutex, __int64 a2);
void __fastcall sub_140023184(struct _FAST_MUTEX *P);
__int64 __fastcall sub_1400269F0(__int64 a1, unsigned int a2);
char __fastcall sub_1400289D4(unsigned int a1, __int64 a2, __m128 *a3);
__int64 sub_14002C528(_BYTE *a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_14002C590(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 Get_PsGetCurrentProcess();
__int64 __fastcall sub_14002D260(__int64 a1);
__int64 __fastcall Get_PsGetProcessId(__int64 Process);
bool __fastcall sub_14002D628(unsigned __int64);
bool sub_14002D798();
_DWORD *__fastcall sub_14002F508(unsigned __int64 a1, _DWORD *a2);
void __fastcall sub_14002F64C(__int64 a1, __int64 a2);
char __fastcall sub_1400301F8(_BYTE *a1, unsigned int a2, int a3, __int64 a4, __int64 a5);
char __fastcall sub_14003023C(const char *a1, unsigned int a2, __int64 a3);
char __fastcall sub_1400303DC(__int64 a1, _DWORD *a2, __int128 **a3);
bool __fastcall sub_140031AEC(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_140031C84(__int64 a1, char a2);
__m128 *__fastcall sub_140032ADC(__int64, unsigned int *);
void __fastcall sub_140032FB0(ULONG64 *a1);
char __fastcall sub_14003363C(ULONG64 a1);
char __fastcall sub_14003398C(__int64 a1);
char __fastcall sub_140033DF8(__int64 a1);
char __fastcall sub_14003412C(ULONG64 a1);
__int64 sub_140035ED4();
__int64 sub_140035F88();
__int64 sub_140035FF4();
__int64 __fastcall sub_140036940(__int64 a1);
__int64 __fastcall sub_140036968(__int64 a1);
char __fastcall sub_140036990(__int64 CurrentThread, char a2);
__int64 __fastcall sub_140037E00(); // weak
bool __fastcall sub_140037E08(_OWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
unsigned __int8 __fastcall sub_140037EF4(unsigned __int8 *a1, unsigned int a2, __int64 a3);
char __fastcall sub_140038070(unsigned __int8 *a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_140038E64(unsigned __int16 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140039E28(_BYTE *a1, _DWORD *a2);
__m128 *__fastcall sub_14003C190(__int64 a1, __m128 *a2);
__int64 __fastcall sub_14003C208(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003C2A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003C334(__int64 a1, __int64 a2);
__m128 *__fastcall sub_14003C3C8(__int64 a1, __m128 *a2);
__m128 *__fastcall sub_14003C434(__int64 a1, __m128 *a2);
__m128 *__fastcall sub_14003C4AC(__int64 a1, __m128 *a2);
__m128 *__fastcall sub_14003C518(__int64 a1, __m128 *a2);
__m128 *__fastcall sub_14003C5BC(__int64 a1, __m128 *a2);
__int64 __fastcall sub_14003C62C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003C680(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003C718(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003C770(__int64 a1, __int64 a2);
__int64 __fastcall sub_14003D0B8(__int64 a1, __int64 a2, unsigned __int64 a3);
bool __fastcall sub_14003D208(__int64 a1, int a2, int a3, int a4, int a5, int a6, int a7, __int64 a8);
__int64 __fastcall sub_14003D35C(__int64 a1, int a2, int a3, _BYTE *a4, unsigned int a5, int a6);
__int64 __fastcall sub_14003D3BC(__int64 a1, int a2, __int64 a3, unsigned int a4);
char __fastcall sub_14003E60C(__int64 a1, unsigned int a2, unsigned int a3, unsigned __int8 (__fastcall *a4)(char *, char *));
void __fastcall sub_14003EEB0(_BYTE *a1, __int64 a2);
char __fastcall sub_14003F084(WCHAR *, _UNICODE_STRING *);
bool __fastcall sub_14003F204(WCHAR *a1, __int64 a2);
char __fastcall sub_140040684(__int64 a1);
bool __fastcall sub_1400417D4(__int64 a1);
unsigned int *__fastcall sub_140041E1C(unsigned __int64 a1, unsigned int *a2);
char __fastcall sub_14004223C(__int64 a1, unsigned __int64 a2, _QWORD *a3, unsigned __int64 *a4);
char __fastcall sub_1400423E4(__int16, _BYTE *);
char __fastcall sub_140042490(_BYTE *a1);
bool sub_140042614();
__int64 __fastcall sub_140043780(__int64 a1, __int64 a2);
__int64 __fastcall sub_140043DFC(__int64 a1, __int64 a2);
void __fastcall sub_140043E54(__int64 a1);
char __fastcall sub_140044F08(__int64 a1);
__int64 __fastcall sub_140045438(__int64 a1);
char __fastcall sub_14004803C(char, char **, int *, unsigned int *);
char __fastcall sub_1400481AC(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400481E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void sub_140048670();
bool __fastcall sub_140048738(unsigned __int64 a1, __int64 a2, unsigned __int64 *a3);
char __fastcall sub_140048764(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3);
char __fastcall sub_1400487F0(char *a1, unsigned __int64 a2, int a3, __int64 a4);
char __fastcall sub_140048850(__int64 a1, int a2, __int64 a3, __int64 a4);
char __fastcall sub_140048950(unsigned __int16 *a1, int *a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_140048A30(__int64 a1);
char __fastcall sub_140048A80(unsigned __int64 *a1, __int64 a2, int a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140048CFC(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5);
char __fastcall sub_140048FFC(__int64 a1, __int64 a2, unsigned int a3, int a4, unsigned int *a5);
char __fastcall sub_1400490EC(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int *a5);
void sub_14004942C();
char *__fastcall sub_1400496C8(int a1);
__int64 __fastcall sub_14004973C(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall EAC_CRC32(_BYTE *a1, unsigned int Size, unsigned int Value);
char __fastcall sub_14004AC88(unsigned __int64 a1, unsigned __int64 Size, __int64 a3);
unsigned __int8 *__fastcall sub_14004BC54(_DWORD *a1, unsigned __int8 *a2, int a3);
__m128 *__fastcall sub_14004C6D0(unsigned int *a1, unsigned __int8 *a2, unsigned __int64 a3);
__m128 *__fastcall sub_14004C78C(__m128 *a1, __int64 a2);
char __fastcall sub_14004CBBC(__int64);
char sub_14004D514();
bool sub_14004D528();
bool sub_14004D540();
__int64 sub_14004EE50();
__int64 __fastcall sub_14004EE80(__int64 a1);
void __fastcall sub_1400511D0(__int64 a1);
char __fastcall sub_1400515F0(__int64, unsigned __int64);
__int64 __fastcall sub_140051724(__int64 a1, __int64 a2);
char sub_140051B28();
char __fastcall sub_1400520C4(__int64 a1);
bool __fastcall sub_140052A50(__int64 a1, __int64 *a2);
__int64 __fastcall Get_PsGetProcessWow64Process(__int64 Process);
__int64 __fastcall Get_PsGetProcessWow64Process2(__int64 Process);
__int64 __fastcall sub_140052F70(__int64);
char __fastcall sub_1400535D8(__int64 ProcessId, char *Buffer, _OWORD *Address, unsigned __int64 Size);
bool __fastcall Get_ZwProtectVirtualMemory_2(__int64 Address, __int64 Size, unsigned int NewProtect, __int64 OldProtection);
char __fastcall Get_KeStackAttachProcess(__int64 Process, _KAPC_STATE *ApcState);
__int64 Get_BuildNumber();
__int64 __fastcall EAC_NtQuerySystemInformation(unsigned int SystemInformationClass, unsigned int SystemInformation, unsigned int Info, int *Size);
__int64 __fastcall Get_NtClose(unsigned __int64 Handle);
__int64 __fastcall Get_NtFlushVirtualMemory(__int64 ProcessHandle, __int64 BaseAddress, __int64 RegionSize, __int64 IoStatus);
__int64 __fastcall sub_140058F40(__int64, unsigned int, __int64, __int64, __int64, int);
__int64 __fastcall Get_ZwQueryVirtualMemory(__int64 ProcessHandle, __int64 BaseAddress, unsigned int MemoryInformationClass, __int64 Buffer, __int64 Length, __int64 ResultLength);
__int64 __fastcall sub_14005974C(__int64 Handle, __int64 a2, __int64 a3, __int64 a4, __int64 IoStatusBlock, int a6, __int64 a7, int a8, __int64 a9, int a10);
char sub_14005C1D4();
char __fastcall sub_14005D25C(__int64, __int64);
__int64 __fastcall EAC_Free_UnicodeString(_UNICODE_STRING *unicode_string);
char __fastcall sub_14005D784(__int64, _BYTE *, unsigned __int64);
char *__fastcall sub_14005D7E4(char *Buffer, char *a2, unsigned __int64 a3);
char __fastcall sub_14005D918(__int64, char *, unsigned __int64);
char __fastcall sub_14005D9A8(__int64, unsigned __int16 *, unsigned __int16);
bool __fastcall sub_14005F450(_BYTE *a1, int a2, _BYTE *a3, __int64 a4, char a5);
char __fastcall sub_14005FF30(__int64 Address, unsigned __int8 (__fastcall *Routine)(__int64, _QWORD, _QWORD, __int64, __int64), __int64 Buffer);
bool __fastcall sub_14005FFE8(__int64, int, int, __int64, __int64);
char __fastcall sub_140060074(__int64 Address, __int64 a2, unsigned __int8 (__fastcall *a3)(__int64, _QWORD, _QWORD, __int64, __int64), __int64 a4);
char __fastcall sub_140060138(__int64, __int64, __int64);
void sub_140060BB0();
__m128 *__fastcall EAC_memcpy(_OWORD *dst, char *Src, unsigned __int64 Lenght);
__m128 *__fastcall EAC_memset(__m128 *, unsigned __int8, unsigned __int64);
__int64 __fastcall sub_14037006E(); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_140016B54; // weak
_UNKNOWN loc_140019CE0; // weak
_UNKNOWN loc_1400263B0; // weak
_UNKNOWN loc_1400327F4; // weak
_UNKNOWN loc_14003CB4C; // weak
_UNKNOWN loc_140040F28; // weak
_UNKNOWN loc_14004256C; // weak
_UNKNOWN loc_14004503C; // weak
_UNKNOWN loc_140045210; // weak
_UNKNOWN loc_140046234; // weak
_UNKNOWN loc_140051FDC; // weak
_UNKNOWN loc_140054154; // weak
_UNKNOWN loc_14005B768; // weak
// extern void (__stdcall *ExAcquireFastMutex)(PFAST_MUTEX FastMutex);
// extern void (__stdcall *ExReleaseFastMutex)(PFAST_MUTEX FastMutex);
// extern const PVOID MmHighestUserAddress;
// extern ULONG (*KeQueryTimeIncrement)(void);
// extern LONG (__stdcall *KeSetEvent)(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// extern PEPROCESS (*IoGetCurrentProcess)(void);
// extern LONG_PTR (__stdcall *ObfDereferenceObject)(PVOID Object);
// extern void (__stdcall *ExFreePoolWithTag)(PVOID P, ULONG Tag);
// extern NTSTATUS (__stdcall *ObCloseHandle)(HANDLE Handle, KPROCESSOR_MODE PreviousMode);
// extern NTSTATUS (__stdcall *ObReferenceObjectByHandle)(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
_DWORD dword_140073E58[8] = { 1, 8, 2, 4, 16, 128, 32, 64 }; // weak
unsigned __int8 byte_140073E90[256] =
{
  237u,
  48u,
  81u,
  117u,
  89u,
  244u,
  246u,
  6u,
  97u,
  137u,
  36u,
  26u,
  194u,
  184u,
  116u,
  50u,
  118u,
  33u,
  209u,
  186u,
  100u,
  236u,
  149u,
  234u,
  240u,
  198u,
  94u,
  138u,
  129u,
  7u,
  75u,
  29u,
  141u,
  78u,
  105u,
  182u,
  203u,
  41u,
  82u,
  197u,
  156u,
  10u,
  167u,
  172u,
  226u,
  227u,
  210u,
  176u,
  19u,
  204u,
  155u,
  96u,
  83u,
  183u,
  251u,
  52u,
  80u,
  31u,
  8u,
  252u,
  243u,
  185u,
  98u,
  24u,
  40u,
  46u,
  216u,
  199u,
  3u,
  219u,
  23u,
  55u,
  169u,
  206u,
  68u,
  66u,
  166u,
  250u,
  195u,
  202u,
  213u,
  57u,
  62u,
  2u,
  115u,
  14u,
  181u,
  145u,
  112u,
  124u,
  107u,
  205u,
  163u,
  113u,
  224u,
  71u,
  127u,
  162u,
  92u,
  136u,
  241u,
  17u,
  228u,
  53u,
  73u,
  177u,
  133u,
  58u,
  114u,
  231u,
  249u,
  67u,
  122u,
  106u,
  143u,
  174u,
  158u,
  86u,
  101u,
  119u,
  168u,
  44u,
  134u,
  200u,
  22u,
  111u,
  157u,
  171u,
  238u,
  39u,
  142u,
  201u,
  179u,
  187u,
  34u,
  72u,
  13u,
  193u,
  207u,
  91u,
  25u,
  245u,
  56u,
  208u,
  255u,
  229u,
  135u,
  65u,
  99u,
  150u,
  225u,
  223u,
  190u,
  160u,
  104u,
  140u,
  38u,
  120u,
  144u,
  173u,
  70u,
  16u,
  88u,
  63u,
  154u,
  12u,
  152u,
  18u,
  49u,
  51u,
  103u,
  45u,
  254u,
  192u,
  247u,
  76u,
  128u,
  217u,
  87u,
  189u,
  85u,
  132u,
  191u,
  165u,
  90u,
  125u,
  211u,
  214u,
  188u,
  64u,
  0u,
  61u,
  15u,
  212u,
  43u,
  27u,
  30u,
  110u,
  84u,
  221u,
  215u,
  77u,
  233u,
  32u,
  220u,
  74u,
  178u,
  35u,
  161u,
  148u,
  59u,
  60u,
  9u,
  126u,
  232u,
  1u,
  130u,
  121u,
  4u,
  109u,
  235u,
  69u,
  230u,
  5u,
  153u,
  28u,
  239u,
  54u,
  196u,
  146u,
  108u,
  102u,
  248u,
  20u,
  175u,
  37u,
  79u,
  147u,
  151u,
  95u,
  253u,
  131u,
  170u,
  93u,
  139u,
  159u,
  218u,
  222u,
  47u,
  11u,
  123u,
  242u,
  42u,
  164u,
  21u,
  180u
}; // weak
_DWORD dword_140073F90[31] =
{
  1,
  2,
  3,
  5,
  7,
  11,
  17,
  25,
  38,
  57,
  86,
  129,
  194,
  291,
  437,
  656,
  854,
  1110,
  1443,
  1876,
  2439,
  3171,
  3475,
  3823,
  4205,
  4626,
  5088,
  5597,
  6157,
  6772,
  7450
}; // weak
_UNKNOWN unk_140076450; // weak
_UNKNOWN unk_14007649A; // weak
_UNKNOWN unk_1400765F1; // weak
_UNKNOWN unk_140076609; // weak
_UNKNOWN unk_14007661B; // weak
_UNKNOWN unk_14007662A; // weak
_UNKNOWN unk_140076654; // weak
_BYTE byte_14007D560[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_BYTE byte_14007D660[280] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  35,
  -79,
  29,
  -16,
  76,
  -127,
  -72,
  101,
  -123,
  -126,
  26,
  103,
  -37,
  78,
  -82,
  76,
  -103,
  -2,
  105,
  -95,
  92,
  72,
  -64,
  -68
}; // weak
__int128 xmmword_14007E640 = 0x8971D3D857CB11C40412DA3CCA3B2D84i64; // weak
__int128 xmmword_14007E700 = 0xF973EBA0254DBACE962F25429F5998E2i64; // weak
_UNKNOWN unk_140083278; // weak
__int16 word_14008327C; // weak
__int64 qword_140083280; // weak
__int64 qword_1400832A0; // weak
__int64 qword_1400832C8; // weak
struct _FAST_MUTEX stru_140083348; // idb
__int64 qword_140083530; // weak
struct _FAST_MUTEX stru_140083540; // idb
int dword_140083578; // weak
char byte_140083597; // weak
__int64 qword_1400835E0; // weak
char byte_140085688; // weak
PVOID qword_140085690; // idb
PVOID qword_140085698; // idb
__int64 qword_1400856C8; // weak
__int64 qword_140085950; // weak
__int64 qword_140085A40; // weak
__int64 qword_140085A58; // weak
int dword_140085CBC; // weak
__int64 (__fastcall *qword_140085D88)(_QWORD, _QWORD); // weak
__int64 qword_140085DA8; // weak
struct _FAST_MUTEX stru_140085DB8; // idb
_UNKNOWN unk_140085DF0; // weak
_UNKNOWN unk_140085DF8; // weak
__int64 qword_140085EF0; // weak
struct _FAST_MUTEX stru_140085EF8; // idb
__int64 qword_140085F80; // weak
__int64 qword_140085F88; // weak
char byte_140085FE8; // weak
__int64 qword_140085FF8; // weak
__int64 qword_140086060; // weak
struct _FAST_MUTEX stru_140086070; // idb
__int64 qword_1400860A8; // weak
__int64 qword_1400860B0; // weak
__int64 qword_140086138; // weak
__int64 qword_1400861B8; // weak
__int64 qword_1400861C0; // weak
char byte_1400861D6; // weak
__int64 EAC_ProcessId_0; // weak
__int64 qword_140086540; // weak
__int128 xmmword_140086960; // weak
int dword_140086970; // weak
_KUSER_SHARED_DATA KUSER_SHARED_DATA; // weak


//----- (0000000140001000) ----------------------------------------------------
__m128 *__fastcall sub_140001000(
        _IMAGE_NT_HEADERS *NtHeaders,
        char *Base_Address,
        unsigned __int64 NumberOfBytes,
        _OWORD *Memory,
        unsigned __int64 Size)
{
  unsigned __int64 SizeOfHeaders; // r8
  __int64 SizeOfOptionalHeader; // rbx
  __m128 *result; // rax
  WORD Idx; // di
  unsigned int *v13; // rbx
  unsigned int v14; // edx
  __int64 v15; // r9
  __int64 v16; // r10

  SizeOfHeaders = NtHeaders->OptionalHeader.SizeOfHeaders;
  SizeOfOptionalHeader = NtHeaders->FileHeader.SizeOfOptionalHeader + 0x24i64;

  if ( SizeOfHeaders > 0x1000 )
    SizeOfHeaders = 0x1000i64;

  result = EAC_memcpy(Memory, Base_Address, SizeOfHeaders);

  Idx = 0;
  if ( NtHeaders->FileHeader.NumberOfSections )
  {
    v13 = (&NtHeaders->Signature + SizeOfOptionalHeader);
    do
    {
      v14 = v13[1];
      if ( v14 )
      {
        v15 = *v13;
        if ( v14 + v15 <= Size )
        {
          v16 = v13[2];
          if ( v16 + v14 <= NumberOfBytes )
            result = EAC_memcpy((Memory + v15), &Base_Address[v16], v14);
        }
      }
      ++Idx;
      v13 += 10;
    }
    while ( Idx < NtHeaders->FileHeader.NumberOfSections );
  }

  return result;
}

//----- (00000001400010B8) ----------------------------------------------------
void __fastcall sub_1400010B8(_IMAGE_NT_HEADERS *NtHeaders, __int64 Address, __int64 BaseAddress)
{
  __int64 v4; // rbp
  DWORD VirtualAddress; // eax
  _IMAGE_NT_HEADERS *v6; // rdx
  _DWORD *v7; // rbx
  DWORD v8; // esi
  unsigned int *v9; // r15
  __int64 v10; // rdi
  _DWORD *v11; // r8
  unsigned int v12; // r9d

  if ( NtHeaders )
  {
    if ( BaseAddress )
    {
      v4 = Address - *&NtHeaders->OptionalHeader.BaseOfData;
      if ( v4 )
      {
        if ( NtHeaders->OptionalHeader.DataDirectory[7].Size )
        {
          VirtualAddress = NtHeaders->OptionalHeader.DataDirectory[7].VirtualAddress;
          if ( VirtualAddress )
          {
            v7 = sub_14001D56C(VirtualAddress, NtHeaders, BaseAddress);
            if ( v7 )
            {
              v8 = 0;
              do
              {
                v9 = v7 + 1;
                v10 = v7[1];
                if ( !v10 )
                  break;
                v11 = sub_14001D56C(*v7, v6, BaseAddress);
                if ( !v11 )
                  break;
                v7 += 2;
                v12 = 0;
                if ( ((v10 - 8) & 0xFFFFFFFFFFFFFFFEui64) != 0 )
                {
                  do
                  {
                    if ( (*v7 & 0xF000) == 0xA000 )
                      *(v11 + (*v7 & 0xFFF)) += v4;
                    v10 = *v9;
                    ++v12;
                    v7 = (v7 + 2);
                  }
                  while ( v12 < (v10 - 8) >> 1 );
                }
                v8 += v10;
              }
              while ( v8 < v6->OptionalHeader.DataDirectory[7].Size );
            }
          }
        }
      }
    }
  }
}
// 140001128: conditional instruction was optimized away because edi.4!=0
// 14000113A: variable 'v6' is possibly undefined

//----- (00000001400011C0) ----------------------------------------------------
char *__fastcall sub_1400011C0(_IMAGE_NT_HEADERS *NtHeaders, unsigned __int64 BaseAddress, __int64 NumberOfBytes)
{
  unsigned __int64 FinalAddress; // rdi
  _DWORD *v6; // rax MAPDST
  _IMAGE_NT_HEADERS *Nt_Headers; // rdx
  _DWORD *v9; // rax
  __int64 v10; // rax
  char *v11; // r9
  char *result; // rax
  char *v13; // rdx

  FinalAddress = BaseAddress + NumberOfBytes;
  if ( !NtHeaders )
    return 0i64;

  if ( !BaseAddress )
    return 0i64;

  if ( !NumberOfBytes )
    return 0i64;

  v6 = sub_14001D56C(NtHeaders->OptionalHeader.DataDirectory[12].VirtualAddress, NtHeaders, BaseAddress);
  if ( !v6 )
    return 0i64;

  if ( v6 < BaseAddress )
    return 0i64;

  v9 = v6 + 0x40;
  if ( v9 <= v6 )
    return 0i64;

  if ( v9 > FinalAddress )
    return 0i64;

  v10 = *(v6 + 0x72);
  if ( !v10 )
    return 0i64;

  v11 = NtHeaders + 32 * v10 + 8 * v10 + NtHeaders->FileHeader.SizeOfOptionalHeader - 16;
  if ( !v11 )
    return 0i64;

  if ( v11 < BaseAddress )
    return 0i64;

  if ( v11 + 40 <= v11 )
    return 0i64;

  if ( (v11 + 40) > FinalAddress )
    return 0i64;

  result = sub_14001D56C((*(v11 + 3) + v6[56]), Nt_Headers, BaseAddress);
  if ( !result )
    return 0i64;

  if ( result < BaseAddress )
    return 0i64;

  if ( result + 8 <= result )
    return 0i64;

  if ( (result + 8) > FinalAddress )
    return 0i64;

  v13 = &result[*(result + 1)];
  if ( v13 <= result || v13 > FinalAddress )
    return 0i64;

  return result;
}
// 14000127A: variable 'Nt_Headers' is possibly undefined

//----- (00000001400012C0) ----------------------------------------------------
char __fastcall sub_1400012C0(
        _DWORD *a1,
        int a2,
        _IMAGE_NT_HEADERS *NtHeaders,
        __int64 Address,
        unsigned __int64 BaseAddress,
        __int64 NumberOfBytes,
        unsigned __int64 Buf,
        unsigned int Length)
{
  unsigned __int64 v8; // rbp
  unsigned __int64 Address_1; // r14
  _DWORD *v10; // rax
  _DWORD *v11; // rdx
  _DWORD *v12; // rax
  unsigned __int64 v13; // rcx

  v8 = BaseAddress + NumberOfBytes;
  if ( !NtHeaders )
    return 0;

  if ( !BaseAddress )
    return 0;

  if ( !a1 )
    return 0;

  if ( !Address )
    return 0;

  if ( !NumberOfBytes )
    return 0;

  if ( !Buf )
    return 0;

  if ( !Length )
    return 0;

  if ( a1 < BaseAddress )
    return 0;

  if ( a1 + 1 <= a1 )
    return 0;

  if ( (a1 + 1) > v8 )
    return 0;

  Address_1 = a2 + (*a1 & 0xFFFu);
  v10 = sub_14001D56C(Address_1, NtHeaders, BaseAddress);
  v11 = v10;
  if ( !v10 )
    return 0;

  if ( v10 < BaseAddress )
    return 0;

  v12 = v10 + 3;
  if ( v12 <= v11 )
    return 0;

  if ( v12 > v8 )
    return 0;

  v13 = Address_1 + Buf;
  if ( Address_1 + Buf < Buf || v13 + 12 <= v13 || v13 + 12 > Buf + Length )
    return 0;

  *v11 = *v13;
  v11[2] = *(v13 + 8);

  return 1;
}

//----- (00000001400013B4) ----------------------------------------------------
void __fastcall sub_1400013B4(
        unsigned __int64 a1,
        _IMAGE_NT_HEADERS *NtHeaders,
        __int64 Address,
        unsigned __int64 BaseAddress,
        __int64 NumberOfBytes,
        unsigned __int64 Buf,
        unsigned int Length)
{
  unsigned __int64 v8; // r13
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rbx
  __int64 v11; // rax
  _DWORD *v12; // rdi
  unsigned __int64 i; // rsi
  char v14; // al
  _IMAGE_NT_HEADERS *v15; // [rsp+88h] [rbp+10h]

  if ( NtHeaders )
  {
    v15 = NtHeaders;
    v8 = BaseAddress + NumberOfBytes;
    if ( BaseAddress )
    {
      if ( Address )
      {
        if ( a1 )
        {
          if ( NumberOfBytes )
          {
            if ( Buf )
            {
              if ( Length )
              {
                if ( a1 >= BaseAddress )
                {
                  v9 = a1 + *(a1 + 8) + 12i64;
                  if ( v9 > a1 && v9 <= v8 )
                  {
                    v10 = a1 + 12;
                    if ( a1 != -12i64 )
                    {
                      do
                      {
                        v11 = *(v10 + 4);
                        if ( !v11 || v10 < BaseAddress || v10 + v11 <= v10 || v10 + v11 > v8 )
                          break;
                        v12 = (v10 + 8);
                        for ( i = v10 + 12; v12 >= v10; i += 4i64 )
                        {
                          if ( i <= v12 )
                            break;
                          if ( i > v10 + *(v10 + 4) )
                            break;
                          v14 = sub_1400012C0(v12, *v10, NtHeaders, Address, BaseAddress, NumberOfBytes, Buf, Length);
                          NtHeaders = v15;
                          if ( !v14 )
                            break;
                          ++v12;
                        }
                        v8 = BaseAddress + NumberOfBytes;
                        v10 += *(v10 + 4);
                      }
                      while ( v10 );
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (0000000140001508) ----------------------------------------------------
void __fastcall sub_140001508(
        unsigned __int64 a1,
        _IMAGE_NT_HEADERS *NtHeaders,
        unsigned __int64 BaseAddress,
        __int64 NumberOfBytes,
        unsigned __int64 Buf,
        unsigned int Length)
{
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rax
  char *v10; // rbx
  __int64 v11; // rax
  char *v12; // rdi
  int v13; // ebp
  char *i; // rsi
  unsigned __int16 v15; // ax
  unsigned __int64 Address; // r15
  _DWORD *v17; // rax
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // [rsp+60h] [rbp+18h]

  if ( BaseAddress )
  {
    v8 = BaseAddress + NumberOfBytes;
    v19 = BaseAddress + NumberOfBytes;
    if ( NtHeaders )
    {
      if ( a1 )
      {
        if ( NumberOfBytes )
        {
          if ( Buf )
          {
            if ( Length )
            {
              if ( a1 >= BaseAddress )
              {
                v9 = a1 + *(a1 + 8) + 12i64;
                if ( v9 > a1 && v9 <= v8 )
                {
                  v10 = (a1 + 12);
                  if ( a1 != -12i64 )
                  {
                    do
                    {
                      v11 = *(v10 + 1);
                      if ( !v11 || v10 < BaseAddress || &v10[v11] <= v10 || &v10[v11] > v8 )
                        break;
                      v12 = v10 + 8;
                      v13 = 0;
                      for ( i = v10 + 10; v12 >= v10; i += 2 )
                      {
                        if ( i <= v12 )
                          break;
                        if ( i > &v10[*(v10 + 1)] )
                          break;
                        v15 = *v12 & 0xFFF;
                        if ( !v15 )
                        {
                          if ( v13 )
                            break;
                        }
                        Address = *v10 + v15;
                        if ( Address > NtHeaders->OptionalHeader.SizeOfImage - 6 )
                          break;
                        v17 = sub_14001D56C(Address, NtHeaders, BaseAddress);
                        if ( !v17 )
                          break;
                        v18 = Address + Buf;
                        if ( Address + Buf >= Buf && v18 + 6 > v18 && v18 + 6 <= Buf + Length )
                        {
                          *v17 = *v18;
                          *(v17 + 2) = *(v18 + 4);
                        }
                        ++v13;
                        v12 += 2;
                      }
                      v8 = v19;
                      v10 += *(v10 + 1);
                    }
                    while ( v10 );
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (0000000140001698) ----------------------------------------------------
void __fastcall sub_140001698(
        unsigned __int64 a1,
        _IMAGE_NT_HEADERS *NtHeaders,
        unsigned __int64 BaseAddress,
        __int64 NumberOfBytes,
        unsigned __int64 Buf,
        unsigned int Length)
{
  unsigned __int64 Final_Address; // rdx
  unsigned __int64 v9; // rax
  char *v10; // rbx
  __int64 v11; // rax
  char *ofs; // rdi
  int idx; // ebp
  char *i; // rsi
  unsigned __int64 Address; // r15
  _DWORD *result; // r8
  _QWORD *v17; // rax
  unsigned __int64 Final_Address_2; // [rsp+60h] [rbp+18h]

  Final_Address = BaseAddress + NumberOfBytes;
  Final_Address_2 = BaseAddress + NumberOfBytes;
  if ( BaseAddress )
  {
    if ( NtHeaders )
    {
      if ( a1 )
      {
        if ( NumberOfBytes )
        {
          if ( Buf )
          {
            if ( Length )
            {
              if ( a1 >= BaseAddress )
              {
                v9 = a1 + *(a1 + 8) + 12i64;
                if ( v9 > a1 && v9 <= Final_Address )
                {
                  v10 = (a1 + 0xC);
                  if ( a1 != 0xFFFFFFFFFFFFFFF4ui64 )
                  {
                    do
                    {
                      v11 = *(v10 + 1);
                      if ( !v11 || v10 < BaseAddress || &v10[v11] <= v10 || &v10[v11] > Final_Address )
                        break;

                      ofs = v10 + 8;
                      idx = 0;
                      for ( i = v10 + 10; ofs >= v10 && i > ofs && i <= &v10[*(v10 + 1)] && (!idx || *ofs); i += 2 )
                      {
                        Address = *v10 + *ofs;
                        if ( Address > NtHeaders->OptionalHeader.SizeOfImage - 8 )
                          break;

                        result = sub_14001D56C(Address, NtHeaders, BaseAddress);
                        if ( !result )
                          break;

                        v17 = (Address + Buf);
                        if ( Address + Buf >= Buf && v17 + 1 > v17 && (v17 + 1) <= Buf + Length )
                          *result = *v17;
                        ++idx;
                        ofs += 2;
                      }
                      Final_Address = Final_Address_2;
                      v10 += *(v10 + 1);
                    }
                    while ( v10 );
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (0000000140001818) ----------------------------------------------------
void __fastcall sub_140001818(
        _IMAGE_NT_HEADERS *NtHeaders,
        unsigned __int64 Address,
        unsigned __int64 BaseAddress,
        __int64 NumberOfBytes)
{
  char *v8; // rax MAPDST
  __int64 v10; // rax
  unsigned __int64 v11; // rbx
  __int64 Buf; // r15
  unsigned __int64 v14; // rcx
  bool v15; // [rsp+40h] [rbp-48h]
  DWORD Length; // [rsp+90h] [rbp+8h] MAPDST BYREF
  __int64 Buffer; // [rsp+A0h] [rbp+18h] BYREF
  __int64 v18; // [rsp+A8h] [rbp+20h]

  if ( NtHeaders )
  {
    if ( BaseAddress )
    {
      if ( Address )
      {
        if ( NumberOfBytes )
        {
          v8 = sub_1400011C0(NtHeaders, BaseAddress, NumberOfBytes);
          if ( v8 )
          {
            if ( *v8 == 1 )
            {
              v10 = (loc_1400551B0)() >> 14;
              LOBYTE(v10) = v10 & 1;
              v18 = v10;
              v15 = ((loc_1400551B0)() & 0x8000) != 0;
              if ( sub_1400131AC(Address, &Buffer, &Length) )
              {
                v11 = (v8 + 8);
                Buf = Buffer;
                if ( v8 + 8 < &v8[*(v8 + 1)] )
                {
                  while ( 1 )
                  {
                    if ( v11 < BaseAddress )
                      goto LABEL_21;

                    v14 = v11 + *(v11 + 8);
                    if ( v14 <= v11 || v14 > BaseAddress + NumberOfBytes )
                      goto LABEL_21;

                    if ( v18 )
                      break;

                    if ( v15 )
                      goto LABEL_16;
LABEL_18:
                    if ( *v11 > 0xFFFFui64 )
                      sub_140001698(v11, NtHeaders, BaseAddress, NumberOfBytes, Buf, Length);
                    v11 += *(v11 + 8) + 0xCi64;

                    if ( v11 >= &v8[*(v8 + 1)] )
                      goto LABEL_21;
                  }
                  if ( (*v11 - 4i64) <= 1 )
                    sub_140001508(v11, NtHeaders, BaseAddress, NumberOfBytes, Buf, Length);
LABEL_16:
                  if ( *v11 == 3i64 )
                    sub_1400013B4(v11, NtHeaders, Address, BaseAddress, NumberOfBytes, Buf, Length);
                  goto LABEL_18;
                }
LABEL_21:
                Get_ExFreePool(Buf);
              }
            }
          }
        }
      }
    }
  }
}

//----- (00000001400019C4) ----------------------------------------------------
_OWORD *__fastcall EAC_CopyFile(
        char *BaseAddress,
        unsigned int Size,
        unsigned __int64 Address,
        DWORD *SizeOut,
        char Flag)
{
  unsigned __int64 NumberOfBytes; // r15
  DWORD SizeOfImage; // eax
  _OWORD *Allocate; // rax MAPDST
  __int64 AddressOut; // [rsp+30h] [rbp-38h] BYREF
  _IMAGE_NT_HEADERS *NtHeaders; // [rsp+70h] [rbp+8h] MAPDST BYREF

  if ( !BaseAddress )
    return 0i64;

  if ( !Size )
    return 0i64;

  NumberOfBytes = Size;

  if ( !GetModuleInfo(BaseAddress, Size, &AddressOut, &NtHeaders) )
    return 0i64;

  SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
  if ( !SizeOfImage )
    return 0i64;

  Allocate = EAC_Allocate_Memory(SizeOfImage);
  if ( !Allocate )
    return 0i64;

  memset(Allocate, 0, NtHeaders->OptionalHeader.SizeOfImage);

  if ( SizeOut )
    *SizeOut = NtHeaders->OptionalHeader.SizeOfImage;

  sub_1400010B8(NtHeaders, Address, BaseAddress);

  if ( Flag )
    sub_140001818(NtHeaders, Address, BaseAddress, NumberOfBytes);

  sub_140001000(NtHeaders, BaseAddress, NumberOfBytes, Allocate, NtHeaders->OptionalHeader.SizeOfImage);

  return Allocate;
}
/* Orphan comments:




*/

//----- (0000000140001AA0) ----------------------------------------------------
_OWORD *__fastcall sub_140001AA0(
        struct _UNICODE_STRING *unicode_string,
        unsigned __int64 Length,
        DWORD *SizeOfImage,
        char Flag)
{
  _OWORD *ret; // rdi
  __int64 Buf; // rbx
  __int64 Buffer[5]; // [rsp+30h] [rbp-28h] BYREF
  ULONG Size; // [rsp+60h] [rbp+8h] BYREF

  ret = 0i64;
  if ( !unicode_string || !unicode_string->Buffer || !unicode_string->Length || !unicode_string->MaximumLength )
    return 0i64;

  if ( EAC_ReadFile(unicode_string, Buffer, &Size) )
  {
    Buf = Buffer[0];
    ret = EAC_CopyFile(Buffer[0], Size, Length, SizeOfImage, Flag);

    if ( Buf )
      Get_ExFreePool(Buf);
  }
  return ret;
}
// 140001AA0: using guessed type __int64 Buffer[5];

//----- (0000000140001B30) ----------------------------------------------------
__int64 __fastcall EAC_ExFreePool(__int64 Buffer)
{
  __int64 result; // rax

  if ( Buffer )
    return Get_ExFreePool(Buffer);

  return result;
}

//----- (00000001400030C0) ----------------------------------------------------
char __fastcall sub_1400030C0(unsigned int a1, __int64 a2)
{
  char ret; // bl
  unsigned __int64 idx; // rdi
  unsigned int v6; // edx
  unsigned __int64 i; // r8
  int v8; // ecx
  char v9; // cl
  __int64 v10; // rax
  __int64 v11; // r8
  void *Object; // rdi
  _UNICODE_STRING unicode_string; // [rsp+20h] [rbp-50h] BYREF
  int v15[6]; // [rsp+30h] [rbp-40h]
  __int16 v16; // [rsp+48h] [rbp-28h]
  __int128 string[2]; // [rsp+50h] [rbp-20h] BYREF

  ret = 0;
  v15[0] = -342188366;
  v15[1] = -1681895443;
  v16 = 6970;
  v15[2] = 1730416328;
  idx = 24i64;
  v15[3] = -1783165222;
  v15[4] = -1303908024;
  v15[5] = -209246272;
  v6 = -337731858;
  memset(string, 0, 26);
  for ( i = 0i64; i < 6; ++i )
  {
    v8 = v15[i] ^ v6;
    v6 = __ROR4__(1140671485 * v6 + 0xC39EC3, 4);
    *(string + i * 4) = v8;
  }
  do
  {
    v9 = v6;
    v6 >>= 8;
    *(string + idx) = *(v15 + idx) ^ v9;
    ++idx;
  }
  while ( idx < 0x1A );

  if ( a2 )
  {
    if ( a1 - 2 <= 1 && !KeGetCurrentIrql() && !Get_KeAreAllApcsDisabled() )
    {
      Get_Unicode_string_Inline(&unicode_string, string);
      v10 = sub_14003E0C8(&unicode_string);
      Object = v10;
      if ( v10 )
      {
        LOBYTE(v11) = 1;
        ret = (loc_1400027D4)(v10, a1, v11, a2);
        ObfDereferenceObject(Object);
      }
    }
  }
  memset(string, 0, 0x1Aui64);
  return ret;
}
// 1400031DB: variable 'v11' is possibly undefined

//----- (000000014000337C) ----------------------------------------------------
char __fastcall sub_14000337C(int a1)
{
  unsigned int v1; // r9d
  int v2; // r11d
  unsigned int v3; // ebp
  int v4; // r15d
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r10
  _WORD *v7; // rsi
  int v8; // edi
  unsigned __int64 v9; // rcx

  v1 = 0;
  v2 = a1 - 0x40000000;
  v3 = *(MEMORY[0x14000003C] + 0x1400000B4i64);
  if ( v3 )
  {
    v4 = *(MEMORY[0x14000003C] + 0x1400000B0i64);
    v5 = v2 & 0xFFFFF000;
    do
    {
      v6 = *(0x140000000i64 + v4 + v1);
      if ( v6 > v5 )
        break;
      if ( v6 + 4096 == v5 || v6 == v5 )
      {
        v7 = (0x140000008i64 + v4 + v1);
        v8 = 0;
        v9 = (*(0x140000004i64 + v4 + v1) - 8) >> 1;
        if ( v9 )
        {
          while ( (*v7 & 0xF000) != 0xA000
               || v6 + (*v7 & 0xFF8) != v2 && v6 + (((*v7 & 0xFFF) + 8i64) & 0xFFFFFFFFFFFFFFF8ui64) != v2 )
          {
            ++v8;
            ++v7;
            if ( v8 >= v9 )
              goto LABEL_11;
          }
          return 1;
        }
      }
LABEL_11:
      v1 += *(0x140000004i64 + v4 + v1);
    }
    while ( v1 < v3 );
  }
  return 0;
}

//----- (0000000140003488) ----------------------------------------------------
bool __fastcall sub_140003488(unsigned __int8 *a1, __int64 a2, _QWORD *a3)
{
  char v5; // r9
  unsigned __int8 *v6; // r8
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  bool v9; // zf
  unsigned int v10; // ecx
  int *v11; // r8
  __int64 v12; // rdx
  __int64 v13; // rcx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // ecx
  bool v17; // zf
  unsigned int v18; // ecx
  unsigned int v19; // ecx
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  unsigned int v22; // ecx
  char *v23; // r8
  __int64 v24; // rcx
  unsigned int v26; // ecx
  unsigned int v27; // ecx
  unsigned int v28; // ecx
  unsigned int v29; // ecx
  unsigned int v30; // ecx
  unsigned __int8 v31; // cl
  __int64 v32; // [rsp+30h] [rbp+8h] BYREF

  v5 = a1;
  if ( a1 && a2 && a3 )
  {
    *a3 = 0i64;
    v6 = a1;
    if ( (*a1 - 64) <= 0xFu )
      v6 = a1 + 1;
    v7 = *v6;
    if ( v7 <= 0x7C )
    {
      if ( v7 == 124 )
        goto LABEL_30;
      if ( v7 > 0x75 )
      {
        v14 = v7 - 118;
        if ( !v14 )
          goto LABEL_30;
        v10 = v14 - 1;
        v9 = v10 == 0;
        goto LABEL_17;
      }
      if ( v7 == 117 )
        goto LABEL_30;
      v8 = v7 - 15;
      if ( v8 )
      {
        v10 = v8 - 97;
        v9 = v10 == 0;
LABEL_17:
        if ( !v9 )
        {
          v15 = v10 - 1;
          if ( v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              v18 = v16 - 1;
              v17 = v18 == 0;
LABEL_28:
              if ( !v17 && v18 != 1 )
                return *a3 != 0i64;
            }
          }
        }
LABEL_30:
        v23 = (v6 + 1);
        v12 = *v23;
        v13 = (v23 - v5) + 1i64;
        goto LABEL_31;
      }
      if ( (v6[1] + 0x80) > 0xFu )
        return *a3 != 0i64;
      goto LABEL_13;
    }
    if ( v7 > 0xE2 )
    {
      v26 = v7 - 227;
      if ( !v26 )
        goto LABEL_30;

      v27 = v26 - 5;
      if ( !v27 || (v28 = v27 - 1) == 0 )
      {
        v11 = (v6 + 1);
        goto LABEL_14;
      }
      v29 = v28 - 1;
      if ( v29 )
      {
        v30 = v29 - 1;
        if ( !v30 )
          goto LABEL_30;
        if ( v30 != 20 )
          return *a3 != 0i64;
        v31 = v6[1];
        if ( ((v31 - 0x15) & 0xE7) != 0 )
        {
          if ( ((v31 - 20) & 0xE7) == 0 && ((v6[2] + 0x1B) & 0x3F) == 0 && MmVirtualMemory_Win7(*(v6 + 3), 8i64, &v32) )
            *a3 = v32;

          return *a3 != 0i64;
        }
LABEL_13:
        v11 = (v6 + 2);
LABEL_14:
        v12 = *v11;
        v13 = (v11 - v5) + 4i64;
LABEL_31:
        v24 = v12 + a2 + v13;
LABEL_32:
        *a3 = v24;
        return *a3 != 0i64;
      }
    }
    else
    {
      if ( v7 == 226 )
        goto LABEL_30;
      v19 = v7 - 125;
      if ( !v19 )
        goto LABEL_30;
      v20 = v19 - 1;
      if ( !v20 )
        goto LABEL_30;
      v21 = v20 - 1;
      if ( !v21 )
        goto LABEL_30;
      v22 = v21 - 27;
      if ( v22 )
      {
        v18 = v22 - 70;
        v17 = v18 == 0;
        goto LABEL_28;
      }
    }
    v24 = *((v6 - v5) + a2 + 1);
    goto LABEL_32;
  }
  return 0;
}

//----- (0000000140004AAC) ----------------------------------------------------
__int64 __fastcall sub_140004AAC(__int64 a1, __int64 a2, __int64 a3)
{
  return EAC_Allocate_Memory(a3 * a2);
}

//----- (0000000140004AB8) ----------------------------------------------------
__int64 __fastcall sub_140004AB8(__int64 a1, __int64 a2)
{
  return Get_ExFreePool(a2);
}

//----- (0000000140004AC0) ----------------------------------------------------
__int64 __fastcall sub_140004AC0(__int64 a1)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64); // rax
  __int64 v4; // rcx
  _DWORD *Memory; // rax

  if ( !a1 )
    return 0xFFFFFFFEi64;

  *(a1 + 72) = 0;
  *(a1 + 76) = 0;
  *(a1 + 32) = 0i64;
  *(a1 + 12) = 0;
  *(a1 + 28) = 0;
  *(a1 + 80) = 0;
  v3 = *(a1 + 0x30);
  if ( !v3 )
  {
    *(a1 + 0x30) = sub_140004AAC;
    v3 = sub_140004AAC;
  }
  if ( !*(a1 + 0x38) )
    *(a1 + 0x38) = sub_140004AB8;

  v4 = *(a1 + 0x40);

  if ( v3 == sub_140004AAC )
    Memory = EAC_Allocate_Memory(0xAB10ui64);
  else
    Memory = v3(v4, 1i64, 0xAB10i64);

  if ( !Memory )
    return 0xFFFFFFFCi64;

  *(a1 + 0x28) = Memory;

  *Memory = 0;
  Memory[2750] = 0;
  Memory[2751] = 0;
  Memory[2753] = 0;
  Memory[10947] = 1;
  Memory[2752] = 1;
  Memory[2754] = 0xFFFFFFF1;

  return 0i64;
}

//----- (0000000140004B88) ----------------------------------------------------
__int64 __fastcall sub_140004B88(__int64 *a1)
{
  char *v2; // rsi
  int v3; // r13d
  int v4; // eax
  int v5; // r15d
  unsigned int v6; // r14d
  __int64 v7; // r9
  __int64 v8; // rdx
  int v9; // eax
  unsigned int v10; // edx
  int v11; // ecx
  unsigned int v12; // edx
  unsigned int v14; // ecx
  char *v15; // rdx
  __int64 v16; // rbx
  int v17; // ecx
  int v18; // edx
  int v19; // r9d
  __int64 v20; // rdx
  int v21; // eax
  int v22; // r12d
  unsigned int v23; // edx
  __int64 v24; // rax
  unsigned int v25; // ecx
  __int64 v26; // rbx
  int v27; // ecx
  int v28; // edx
  __int64 v29; // [rsp+80h] [rbp+40h] BYREF
  __int64 v30; // [rsp+90h] [rbp+50h] BYREF

  if ( !a1 )
    return 4294967294i64;
  v2 = a1[5];
  if ( !v2 )
    return 4294967294i64;
  v3 = *(a1 + 2);
  v4 = *(v2 + 2752);
  v5 = (*(a1[5] + 11016) > 0) + 8;
  *(v2 + 2752) = 0;
  if ( *(v2 + 10947) < 0 )
    return 4294967293i64;
  v6 = 1;
  *(v2 + 2753) |= 1u;
  if ( !v4 )
  {
    v14 = *(v2 + 2751);
    v15 = v2 + 11020;
    if ( v14 )
    {
      if ( v14 >= *(a1 + 6) )
        v14 = *(a1 + 6);
      v16 = v14;
      EAC_memcpy(a1[2], &v15[*(v2 + 0xABE)], v14);
      a1[2] += v16;
      *(a1 + 6) -= v16;
      *(a1 + 7) += v16;
      v17 = (v16 + *(v2 + 2750)) & 0x7FFF;
      v18 = *(v2 + 2751) - v16;
      *(v2 + 2751) = v18;
      *(v2 + 2750) = v17;
      if ( *(v2 + 10947) || v18 )
        return 0;
      return v6;
    }
    while ( 1 )
    {
      v30 = *(a1 + 2);
      v19 = v15;
      v20 = *a1;
      v29 = (0x8000 - *(v2 + 2750));
      v21 = sub_140004E14(v2, v20, &v30, v19, &v2[*(v2 + 2750) + 11020], &v29, v5);
      *(v2 + 10947) = v21;
      v22 = v21;
      v23 = v30;
      *(a1 + 2) -= v30;
      *(a1 + 3) += v23;
      *a1 += v23;
      *(a1 + 19) = *(v2 + 7);
      v24 = *(v2 + 2750);
      *(v2 + 2751) = v29;
      v25 = v29;
      if ( v29 >= *(a1 + 6) )
        v25 = *(a1 + 6);
      v26 = v25;
      EAC_memcpy(a1[2], &v2[v24 + 11020], v25);
      a1[2] += v26;
      *(a1 + 6) -= v26;
      *(a1 + 7) += v26;
      v27 = (v26 + *(v2 + 2750)) & 0x7FFF;
      v28 = *(v2 + 2751) - v26;
      *(v2 + 2751) = v28;
      *(v2 + 2750) = v27;
      if ( v22 < 0 )
        break;
      if ( v22 == 1 && !v3 )
        return 4294967291i64;
      if ( !v22 )
        return v28 != 0 ? -5 : 1;
      LODWORD(v15) = v2 + 11020;
      if ( !*(a1 + 6) )
        return 4294967291i64;
    }
    return 4294967293i64;
  }
  v7 = a1[2];
  v8 = *a1;
  v30 = *(a1 + 2);
  v29 = *(a1 + 6);
  v9 = sub_140004E14(v2, v8, &v30, v7, v7, &v29, v5 | 4u);
  *(v2 + 10947) = v9;
  v10 = v30;
  *(a1 + 2) -= v30;
  *(a1 + 3) += v10;
  *a1 += v10;
  v11 = *(v2 + 7);
  v12 = v29;
  *(a1 + 6) -= v29;
  *(a1 + 7) += v12;
  *(a1 + 19) = v11;
  a1[2] += v12;
  if ( v9 < 0 )
    return 4294967293i64;
  if ( !v9 )
    return v6;
  *(v2 + 10947) = -1;
  return 4294967291i64;
}
// 140004E14: using guessed type __int64 __fastcall sub_140004E14(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, _DWORD);

//----- (0000000140004E14) ----------------------------------------------------
__int64 __fastcall sub_140004E14(
        __int64 a1,
        char *a2,
        _QWORD *a3,
        unsigned __int64 a4,
        unsigned __int64 a5,
        __int64 *a6,
        char a7)
{
  char *v8; // r14
  int v9; // ebp
  unsigned __int8 *v10; // rbx
  __int64 v11; // rax
  _BYTE *v13; // r10
  char v14; // cl
  unsigned __int64 v15; // r9
  int v16; // r11d
  unsigned int v17; // edx
  unsigned int v18; // edi
  unsigned __int64 v19; // r12
  unsigned int i; // r15d
  unsigned __int64 v21; // r8
  unsigned int v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  _BYTE *v29; // r9
  unsigned __int8 *v30; // r11
  unsigned __int64 v31; // r10
  unsigned int v32; // ecx
  unsigned int v33; // r8d
  unsigned int v34; // ecx
  unsigned __int64 j; // r9
  unsigned int v36; // edx
  unsigned int v37; // r10d
  int v38; // r8d
  int v39; // ecx
  int v40; // r8d
  int v41; // ecx
  int v42; // r8d
  int v43; // ecx
  int v44; // r8d
  int v45; // ecx
  int v46; // r8d
  int v47; // ecx
  int v48; // r8d
  int v49; // ecx
  int v50; // r8d
  int v51; // ecx
  char v52; // al
  int v53; // r10d
  unsigned int v54; // r8d
  unsigned __int64 v55; // rax
  BOOL v56; // eax
  unsigned int v57; // eax
  unsigned int v58; // eax
  unsigned int v59; // eax
  unsigned int v60; // eax
  unsigned int v61; // eax
  unsigned int v62; // eax
  __int64 v63; // r9
  unsigned __int64 v64; // rax
  unsigned int v65; // eax
  unsigned int v66; // eax
  unsigned int v67; // eax
  unsigned int v68; // eax
  unsigned int v69; // eax
  unsigned int v70; // eax
  unsigned int v71; // eax
  unsigned int v72; // eax
  unsigned int v73; // eax
  unsigned int v74; // eax
  unsigned int v75; // eax
  unsigned int v76; // eax
  unsigned __int64 v77; // rbx
  unsigned __int64 v78; // rcx
  unsigned __int64 v79; // rax
  unsigned __int64 v80; // rax
  unsigned __int64 v81; // rcx
  unsigned __int64 v82; // rbx
  unsigned __int64 v83; // rax
  unsigned int v84; // ecx
  unsigned int v85; // ecx
  __m128i si128; // xmm0
  __m128i v87; // xmm0
  int v88; // edx
  int v89; // ecx
  unsigned __int64 v90; // rax
  unsigned __int64 v91; // rax
  __int64 v92; // rax
  char v93; // cl
  __int64 v94; // rax
  __int64 v95; // rbx
  __int64 v96; // r13
  __int64 v97; // r10
  unsigned int v98; // r11d
  unsigned __int8 *v99; // rcx
  __int64 v100; // rdx
  __int64 v101; // rax
  unsigned int v102; // r8d
  int v103; // ecx
  __int64 v104; // rdx
  __int64 v105; // r9
  __int32 v106; // eax
  int v107; // r13d
  unsigned int v108; // ecx
  __int64 v109; // r9
  unsigned int v110; // r10d
  __int64 v111; // r8
  unsigned int v112; // r9d
  int v113; // r11d
  int v114; // ecx
  unsigned int v115; // edx
  __int16 v116; // r9
  int v117; // r8d
  __int64 v118; // rax
  unsigned int v119; // ecx
  int v120; // r8d
  unsigned int v121; // r8d
  __int64 v122; // rax
  int v123; // ecx
  unsigned int v124; // edx
  __int64 v125; // r8
  __int64 v126; // rax
  unsigned int v127; // edx
  int v128; // ecx
  unsigned __int64 v129; // rdx
  unsigned __int64 v130; // rax
  __int64 v131; // rdx
  __int64 v132; // rax
  int v133; // ecx
  unsigned __int64 v134; // rdx
  __int64 v135; // rax
  unsigned __int64 v136; // rax
  int v137; // ebx
  unsigned int v138; // ebx
  unsigned __int8 v139; // dl
  unsigned __int64 v140; // rax
  unsigned __int64 v141; // rax
  int v142; // ecx
  unsigned __int64 v143; // rdx
  int v144; // r8d
  int v145; // ecx
  unsigned __int64 v146; // rdx
  _BYTE *v147; // rax
  int v148; // r8d
  unsigned int v149; // r8d
  int v150; // ecx
  unsigned __int64 v151; // rdx
  __int64 v152; // rdx
  __int64 v153; // rax
  int v154; // ecx
  unsigned __int64 v155; // rdx
  __int64 v156; // rcx
  unsigned __int64 v157; // rax
  int v158; // eax
  int v159; // r8d
  unsigned int v160; // r8d
  int v161; // ecx
  unsigned __int64 v162; // rdx
  unsigned __int64 v163; // rax
  __int64 v164; // rdx
  __int64 v165; // rax
  __int64 v166; // r8
  int v167; // ecx
  unsigned __int64 v168; // rdx
  unsigned __int64 v169; // rax
  int v170; // eax
  _BYTE *v171; // r8
  _BYTE *v172; // rax
  _BYTE *v174; // rcx
  __int64 v175; // rax
  __int64 v176; // rcx
  char v177; // al
  unsigned __int64 v178; // rax
  char v179; // cl
  unsigned __int64 v180; // rax
  char v181; // cl
  unsigned __int64 v182; // rax
  unsigned __int64 v183; // rax
  unsigned __int64 v184; // r12
  unsigned __int64 v185; // rax
  int v186; // ecx
  int v187; // ecx
  int v188; // eax
  int v189; // ecx
  __int64 result; // rax
  int v191; // [rsp+20h] [rbp-118h]
  unsigned int v192; // [rsp+24h] [rbp-114h]
  unsigned __int64 v193; // [rsp+28h] [rbp-110h]
  _BYTE *v194; // [rsp+28h] [rbp-110h]
  _BYTE *v195; // [rsp+30h] [rbp-108h]
  __int64 v196; // [rsp+38h] [rbp-100h]
  int v197; // [rsp+40h] [rbp-F8h]
  unsigned __int64 v198; // [rsp+48h] [rbp-F0h]
  unsigned __int8 *v199; // [rsp+50h] [rbp-E8h]
  __int64 v200; // [rsp+60h] [rbp-D8h]
  __int64 v201[10]; // [rsp+70h] [rbp-C8h]
  __m128 v202[7]; // [rsp+C0h] [rbp-78h] BYREF

  v8 = a2;
  v9 = -1;
  v10 = &a2[*a3];
  v193 = a5;
  v199 = v10;
  v11 = *a6;
  v13 = a5;
  v198 = *a6 + a5;
  v14 = a7;
  if ( (a7 & 4) != 0 )
  {
    v196 = -1i64;
    v15 = 0i64;
  }
  else
  {
    v196 = a5 + v11 - a4 - 1;
    v15 = a5 + v11 - a4;
    if ( (v196 & (v196 + 1)) != 0 )
    {
LABEL_364:
      *a6 = 0i64;
      result = 4294967293i64;
      *a3 = 0i64;
      return result;
    }
  }
  if ( a5 < a4 )
    goto LABEL_364;
  v16 = *(a1 + 32);
  v17 = *(a1 + 40);
  v18 = *(a1 + 4);
  v19 = *(a1 + 56);
  i = *(a1 + 36);
  v21 = a2;
  v195 = *(a1 + 64);
  v22 = *a1;
  v191 = v16;
  v192 = v17;
  if ( *a1 > 0x18u )
  {
    if ( v22 > 0x25 )
    {
      v71 = v22 - 38;
      if ( !v71 )
      {
        v79 = *a6 + a5;
        goto LABEL_78;
      }
      v72 = v71 - 1;
      if ( !v72 )
        goto LABEL_322;
      v73 = v72 - 2;
      if ( !v73 )
        goto LABEL_336;
      v74 = v73 - 1;
      if ( !v74 )
        goto LABEL_340;
      v75 = v74 - 9;
      if ( !v75 )
        goto LABEL_285;
      v76 = v75 - 1;
      if ( !v76 )
        goto LABEL_289;
      if ( v76 == 1 )
      {
        v63 = v196;
        v77 = a4;
        goto LABEL_75;
      }
      goto LABEL_17;
    }
    if ( v22 != 37 )
    {
      v65 = v22 - 25;
      if ( !v65 )
      {
        v63 = v196;
        do
        {
LABEL_218:
          if ( v8 >= v10 )
          {
            *a1 = 25;
            goto LABEL_348;
          }
          v157 = *v8++ << v18;
          v19 |= v157;
          v18 += 8;
        }
        while ( v18 < v17 );
LABEL_220:
        v18 -= v17;
        v158 = v19 & ((1 << v17) - 1);
        v19 >>= v17;
        i += v158;
LABEL_221:
        if ( v18 >= 0xF )
          goto LABEL_237;
        if ( v10 - v8 >= 2 )
        {
          v164 = v8[1];
          v165 = *v8;
          v8 += 2;
          v19 |= (v165 << v18) | (v164 << (v18 + 8));
          v18 += 16;
          goto LABEL_237;
        }
        while ( 1 )
        {
          v159 = *(a1 + 2 * (v19 & 0x3FF) + 3848);
          if ( v159 < 0 )
          {
            if ( v18 > 0xA )
            {
              v161 = 10;
              while ( 1 )
              {
                v162 = v19 >> v161++;
                v159 = *(a1 + 2 * (~v159 + (v162 & 1)) + 5896);
                if ( v159 >= 0 )
                  break;
                if ( v18 < v161 + 1 )
                  goto LABEL_233;
              }
LABEL_237:
              LODWORD(v166) = *(a1 + 2 * (v19 & 0x3FF) + 3848);
              if ( v166 < 0 )
              {
                v167 = 10;
                do
                {
                  v168 = v19 >> v167++;
                  v166 = *(a1 + 2 * (~v166 + (v168 & 1)) + 5896);
                }
                while ( v166 < 0 );
              }
              else
              {
                v167 = v166 >> 9;
                v166 &= 0x1FFu;
              }
              v19 >>= v167;
              v18 -= v167;
              v17 = dword_140062450[v166];
              v16 = dword_1400623D0[v166];
              v192 = v17;
              v191 = v16;
              if ( v17 )
              {
                if ( v18 < v17 )
                  goto LABEL_245;
                goto LABEL_247;
              }
              goto LABEL_248;
            }
          }
          else
          {
            v160 = v159 >> 9;
            if ( v160 && v18 >= v160 )
              goto LABEL_237;
          }
LABEL_233:
          if ( v8 >= v10 )
          {
            *a1 = 26;
            goto LABEL_348;
          }
          v163 = *v8++ << v18;
          v19 |= v163;
          v18 += 8;
          if ( v18 >= 0xF )
            goto LABEL_237;
        }
      }
      v66 = v65 - 1;
      if ( !v66 )
      {
        v63 = v196;
        goto LABEL_233;
      }
      v67 = v66 - 1;
      if ( v67 )
      {
        v68 = v67 - 5;
        if ( !v68 )
          goto LABEL_324;
        v69 = v68 - 2;
        if ( !v69 )
          goto LABEL_346;
        v70 = v69 - 1;
        if ( !v70 )
        {
LABEL_299:
          *a1 = 35;
          goto LABEL_45;
        }
        if ( v70 == 1 )
          goto LABEL_44;
LABEL_17:
        v29 = *(a1 + 64);
        goto LABEL_18;
      }
      v63 = v196;
      do
      {
LABEL_245:
        if ( v8 >= v10 )
        {
          *a1 = 27;
          goto LABEL_348;
        }
        v169 = *v8++ << v18;
        v19 |= v169;
        v18 += 8;
      }
      while ( v18 < v17 );
LABEL_247:
      v18 -= v17;
      v170 = v19 & ((1 << v17) - 1);
      v19 >>= v17;
      v16 += v170;
      v191 = v16;
LABEL_248:
      v77 = a4;
      v195 = &v13[-a4];
      if ( v16 <= &v13[-a4] || (a7 & 4) == 0 )
      {
        v171 = (a4 + (v63 & &v13[-a4 - v16]));
        v172 = v171;
        if ( v13 > v171 )
          v172 = v13;
        if ( &v172[i] > v198 )
        {
          while ( 1 )
          {
            if ( !i-- )
              goto LABEL_174;
LABEL_75:
            if ( v13 >= v198 )
              break;
            v78 = v63 & &v195[-v16];
            ++v195;
            *v13++ = *(v78 + v77);
            v193 = v13;
          }
          *a1 = 53;
          goto LABEL_294;
        }
        if ( i >= 9 )
        {
          if ( i > v16 )
          {
LABEL_265:
            v176 = (i - 3) / 3 + 1;
            do
            {
              i -= 3;
              *v13 = *v171;
              v13[1] = v171[1];
              v177 = v171[2];
              v171 += 3;
              v13[2] = v177;
              v13 += 3;
              --v176;
            }
            while ( v176 );
            v193 = v13;
            goto LABEL_260;
          }
          v174 = &v171[i & 0xFFFFFFF8];
          do
          {
            v175 = *v171;
            v171 += 8;
            *v13 = v175;
            v13 += 8;
          }
          while ( v171 < v174 );
          i &= 7u;
          v193 = v13;
          if ( i < 3 )
          {
LABEL_260:
            if ( i )
            {
              *v13 = *v171;
              if ( i > 1 )
                v13[1] = v171[1];
              v193 = &v13[i];
            }
LABEL_174:
            v13 = v193;
            v10 = v199;
            while ( 1 )
            {
              v140 = v198;
LABEL_176:
              if ( v10 - v8 < 4 || (v140 - v13) < 2 )
                break;
              if ( v18 < 0x1E )
              {
                v141 = *v8 << v18;
                v8 += 4;
                v19 |= v141;
                v18 += 32;
              }
              i = *(a1 + 2 * (v19 & 0x3FF) + 360);
              if ( (i & 0x80000000) != 0 )
              {
                v142 = 10;
                do
                {
                  v143 = v19 >> v142++;
                  i = *(a1 + 2 * (~i + (v143 & 1)) + 2408);
                }
                while ( (i & 0x80000000) != 0 );
              }
              else
              {
                v142 = i >> 9;
              }
              v19 >>= v142;
              v18 -= v142;
              if ( (i & 0x100) != 0 )
                goto LABEL_213;
              v144 = *(a1 + 2 * (v19 & 0x3FF) + 360);
              if ( v144 < 0 )
              {
                v145 = 10;
                do
                {
                  v146 = v19 >> v145++;
                  v144 = *(a1 + 2 * (~v144 + (v146 & 1)) + 2408);
                }
                while ( v144 < 0 );
              }
              else
              {
                v145 = v144 >> 9;
              }
              v19 >>= v145;
              v147 = v13 + 1;
              v18 -= v145;
              *v13 = i;
              if ( (v144 & 0x100) != 0 )
              {
                ++v13;
                v193 = v147;
                LOWORD(i) = v144;
                goto LABEL_213;
              }
              v13 += 2;
              *v147 = v144;
              v193 = v13;
            }
            if ( v18 >= 0xF )
              goto LABEL_203;
            if ( v10 - v8 >= 2 )
            {
              v152 = v8[1];
              v153 = *v8;
              v8 += 2;
              v19 |= (v153 << v18) | (v152 << (v18 + 8));
              v18 += 16;
              goto LABEL_203;
            }
            while ( 1 )
            {
              v148 = *(a1 + 2 * (v19 & 0x3FF) + 360);
              if ( v148 < 0 )
              {
                if ( v18 > 0xA )
                {
                  v150 = 10;
                  while ( 1 )
                  {
                    v151 = v19 >> v150++;
                    v148 = *(a1 + 2 * (~v148 + (v151 & 1)) + 2408);
                    if ( v148 >= 0 )
                      break;
                    if ( v18 < v150 + 1 )
                      goto LABEL_54;
                  }
LABEL_203:
                  i = *(a1 + 2 * (v19 & 0x3FF) + 360);
                  if ( (i & 0x80000000) != 0 )
                  {
                    v154 = 10;
                    do
                    {
                      v155 = v19 >> v154++;
                      i = *(a1 + 2 * (~i + (v155 & 1)) + 2408);
                    }
                    while ( (i & 0x80000000) != 0 );
                  }
                  else
                  {
                    v154 = i >> 9;
                    i &= 0x1FFu;
                  }
                  v19 >>= v154;
                  v18 -= v154;
                  if ( i < 0x100 )
                  {
LABEL_210:
                    v140 = v198;
                    if ( v13 < v198 )
                    {
                      *v13++ = i;
                      v193 = v13;
                      goto LABEL_176;
                    }
                    v16 = v191;
                    v17 = v192;
                    *a1 = 24;
LABEL_294:
                    v21 = a2;
                    v9 = 2;
LABEL_45:
                    v29 = v195;
                    goto LABEL_352;
                  }
LABEL_213:
                  i &= 0x1FFu;
                  if ( i != 256 )
                  {
                    v156 = i - 257;
                    v17 = dword_140062550[v156];
                    i = dword_1400624D0[v156];
                    v192 = v17;
                    if ( v17 )
                    {
                      if ( v18 < v17 )
                        goto LABEL_218;
                      goto LABEL_220;
                    }
                    goto LABEL_221;
                  }
LABEL_85:
                  v10 = v199;
                  if ( (*(a1 + 20) & 1) == 0 )
                  {
                    v17 = v192;
                    goto LABEL_89;
                  }
                  for ( ; v18 < (v18 & 7); ++v8 )
                  {
LABEL_324:
                    if ( v8 >= v10 )
                    {
                      *a1 = 32;
                      goto LABEL_348;
                    }
                    v183 = *v8 << v18;
                    v18 += 8;
                    v19 |= v183;
                  }
                  v21 = a2;
                  v184 = v19 >> (v18 & 7);
                  for ( v18 &= 0xFFFFFFF8; v8 > a2 && v18 >= 8; v18 -= 8 )
                    --v8;
                  v19 = ((1i64 << v18) - 1) & v184;
                  if ( (a7 & 1) != 0 )
                  {
                    for ( i = 0; i < 4; ++i )
                    {
                      if ( v18 )
                      {
                        for ( ; v18 < 8; v18 += 8 )
                        {
LABEL_336:
                          if ( v8 >= v10 )
                          {
                            *a1 = 41;
                            goto LABEL_349;
                          }
                          v185 = *v8++ << v18;
                          v19 |= v185;
                        }
                        v186 = v19;
                        v19 >>= 8;
                        v18 -= 8;
                      }
                      else
                      {
                        v14 = a7;
LABEL_340:
                        if ( v8 >= v10 )
                        {
                          v52 = v14;
                          *a1 = 42;
                          goto LABEL_350;
                        }
                        v186 = *v8++;
                      }
                      *(a1 + 16) = v186 | (*(a1 + 16) << 8);
                    }
                  }
                  v16 = v191;
                  v17 = v192;
LABEL_346:
                  *a1 = 34;
                  v9 = 0;
                  goto LABEL_45;
                }
              }
              else
              {
                v149 = v148 >> 9;
                if ( v149 && v18 >= v149 )
                  goto LABEL_203;
              }
LABEL_54:
              if ( v8 >= v10 )
              {
                *a1 = 23;
                goto LABEL_348;
              }
              v64 = *v8++ << v18;
              v19 |= v64;
              v18 += 8;
              if ( v18 >= 0xF )
                goto LABEL_203;
            }
          }
        }
        if ( i <= 2 )
          goto LABEL_260;
        goto LABEL_265;
      }
      v21 = a2;
    }
    *a1 = 37;
    goto LABEL_45;
  }
  if ( v22 == 24 )
  {
    v63 = v196;
    goto LABEL_210;
  }
  if ( v22 > 0xA )
  {
    v57 = v22 - 11;
    if ( !v57 )
      goto LABEL_98;
    v58 = v57 - 3;
    if ( !v58 )
      goto LABEL_103;
    v59 = v58 - 2;
    if ( !v59 )
      goto LABEL_150;
    v60 = v59 - 1;
    if ( !v60 )
    {
LABEL_302:
      *a1 = 17;
      goto LABEL_45;
    }
    v61 = v60 - 1;
    if ( !v61 )
      goto LABEL_164;
    v62 = v61 - 3;
    if ( v62 )
    {
      if ( v62 == 2 )
      {
        v63 = v196;
        goto LABEL_54;
      }
      goto LABEL_17;
    }
LABEL_305:
    *a1 = 21;
    goto LABEL_45;
  }
  if ( v22 == 10 )
  {
LABEL_315:
    *a1 = 10;
    goto LABEL_45;
  }
  if ( !v22 )
  {
    *(a1 + 28) = 1;
    *(a1 + 8) = 0i64;
    v17 = 0;
    v192 = 0;
    i = 0;
    v191 = 0;
    v16 = 0;
    *(a1 + 16) = 1;
    v18 = 0;
    v19 = 0i64;
    if ( (a7 & 1) == 0 )
      goto LABEL_89;
    goto LABEL_26;
  }
  v23 = v22 - 1;
  if ( !v23 )
  {
LABEL_26:
    if ( a2 >= v10 )
    {
      v52 = a7;
      *a1 = 1;
      goto LABEL_350;
    }
    v8 = a2 + 1;
    *(a1 + 8) = *a2;
    goto LABEL_29;
  }
  v24 = v23 - 1;
  if ( !v24 )
  {
LABEL_29:
    if ( v8 >= v10 )
    {
      v52 = a7;
      *a1 = 2;
      goto LABEL_350;
    }
    v53 = *v8;
    v54 = *(a1 + 8);
    ++v8;
    *(a1 + 12) = v53;
    i = v53 + (v54 << 8) != 31 * ((v53 + (v54 << 8)) / 0x1F) || (v53 & 0x20) != 0 || (v54 & 0xF) != 8;
    if ( (a7 & 4) == 0 )
    {
      v55 = (1 << ((v54 >> 4) + 8));
      v56 = v55 > 0x8000 || v15 < v55;
      i |= v56;
    }
    v13 = a5;
    v17 = v192;
    if ( !i )
      goto LABEL_89;
    v21 = a2;
LABEL_44:
    *a1 = 36;
    goto LABEL_45;
  }
  v25 = v24 - 1;
  if ( v25 )
  {
    v26 = v25 - 2;
    if ( !v26 )
    {
      while ( 1 )
      {
        if ( v8 >= v10 )
        {
          *a1 = 5;
          goto LABEL_348;
        }
        v178 = *v8++ << v18;
        v19 |= v178;
        v18 += 8;
LABEL_270:
        if ( v18 >= (v18 & 7) )
        {
          v179 = v18 & 7;
          v18 &= 0xFFFFFFF8;
          v19 >>= v179;
          i = 0;
          goto LABEL_272;
        }
      }
    }
    v27 = v26 - 1;
    if ( !v27 )
      goto LABEL_275;
    v28 = v27 - 1;
    if ( v28 )
    {
      if ( v28 == 2 )
      {
        while ( 1 )
        {
          v79 = v198;
          if ( v13 >= v198 )
          {
            *a1 = 9;
            goto LABEL_294;
          }
LABEL_78:
          if ( v8 >= v10 )
          {
            *a1 = 38;
            goto LABEL_348;
          }
          v80 = v79 - v13;
          v81 = v10 - v8;
          v82 = i;
          if ( v80 < v81 )
            v81 = v80;
          if ( v81 < i )
            v82 = v81;
          EAC_memcpy(v13, v8, v82);
          v8 += v82;
          v13 = (v82 + v193);
          i -= v82;
          v193 += v82;
LABEL_84:
          if ( !i )
            goto LABEL_85;
          v10 = v199;
          v16 = v191;
          v17 = v192;
        }
      }
      goto LABEL_17;
    }
LABEL_278:
    if ( v8 >= v10 )
    {
      *a1 = 7;
      goto LABEL_348;
    }
    v181 = *v8++;
    *(i + a1 + 10536) = v181;
    while ( 1 )
    {
      ++i;
LABEL_272:
      if ( i >= 4 )
        break;
      if ( !v18 )
        goto LABEL_278;
      for ( ; v18 < 8; v18 += 8 )
      {
LABEL_275:
        if ( v8 >= v10 )
        {
          *a1 = 6;
          goto LABEL_348;
        }
        v180 = *v8++ << v18;
        v19 |= v180;
      }
      *(i + a1 + 10536) = v19;
      v19 >>= 8;
      v18 -= 8;
    }
    i = *(a1 + 10536);
    if ( i == (*(a1 + 10538) ^ 0xFFFF) )
    {
      while ( 1 )
      {
        if ( !i )
          goto LABEL_85;
        if ( !v18 )
          goto LABEL_84;
        while ( v18 < 8 )
        {
LABEL_285:
          if ( v8 >= v10 )
          {
            *a1 = 51;
            goto LABEL_348;
          }
          v182 = *v8++ << v18;
          v19 |= v182;
          v18 += 8;
        }
        v16 = v19;
        v19 >>= 8;
        v18 -= 8;
        v191 = v16;
LABEL_289:
        if ( v13 >= v198 )
        {
          *a1 = 52;
          goto LABEL_294;
        }
        *v13 = v16;
        --i;
        v193 = ++v13;
      }
    }
    v16 = v191;
    v21 = a2;
LABEL_322:
    *a1 = 39;
    goto LABEL_45;
  }
  do
  {
    if ( v8 >= v10 )
    {
      *a1 = 3;
      goto LABEL_348;
    }
    v83 = *v8++ << v18;
    v19 |= v83;
    v18 += 8;
LABEL_89:
    ;
  }
  while ( v18 < 3 );
  v18 -= 3;
  v84 = v19 & 7;
  v19 >>= 3;
  *(a1 + 20) = v84;
  v85 = v84 >> 1;
  *(a1 + 24) = v85;
  switch ( v85 )
  {
    case 0u:
      goto LABEL_270;
    case 3u:
      v16 = v191;
      v21 = a2;
      goto LABEL_315;
    case 1u:
      si128 = _mm_load_si128(&xmmword_14007E4D0);
      *(a1 + 44) = 288;
      *(a1 + 48) = 32;
      *(a1 + 3560) = si128;
      *(a1 + 3576) = si128;
      EAC_memset((a1 + 0x48), 8u, 0x90ui64);
      EAC_memset((a1 + 0xD8), 9u, 0x70ui64);
      v87 = _mm_load_si128(xmmword_14007E4E0);
      *(a1 + 328) = v87;
      *(a1 + 344) = v87.m128i_i64[0];
      *(a1 + 352) = 0x808080808080808i64;
      goto LABEL_107;
  }
  for ( i = 0; i < 3; ++i )
  {
    while ( v18 < *(&qword_1400612B0[2] + i) )
    {
LABEL_98:
      if ( v8 >= v10 )
      {
        *a1 = 11;
        goto LABEL_348;
      }
      v90 = *v8++ << v18;
      v19 |= v90;
      v18 += 8;
    }
    v88 = v19 & ((1 << *(&qword_1400612B0[2] + i)) - 1);
    *(a1 + 4i64 * i + 44) = v88;
    v89 = *(&qword_1400612B0[2] + i);
    v19 >>= v89;
    v18 -= v89;
    *(a1 + 4i64 * i + 44) = v88 + dword_1400625E8[i];
  }
  EAC_memset((a1 + 7048), 0, 0x120ui64);
  for ( i = 0; i < *(a1 + 52); ++i )
  {
    for ( ; v18 < 3; v18 += 8 )
    {
LABEL_103:
      if ( v8 >= v10 )
      {
        *a1 = 14;
        goto LABEL_348;
      }
      v91 = *v8++ << v18;
      v19 |= v91;
    }
    v92 = i;
    v93 = v19 & 7;
    v19 >>= 3;
    v18 -= 3;
    *(byte_1400625D0[v92] + a1 + 7048) = v93;
  }
  *(a1 + 52) = 19;
  while ( 1 )
  {
LABEL_107:
    v94 = *(a1 + 24);
    if ( v94 < 0 )
    {
      v63 = v196;
      goto LABEL_174;
    }
    v95 = 3488 * v94;
    v96 = 3488 * v94 + a1 + 72;
    v200 = v96;
    EAC_memset(v202, 0, 0x40ui64);
    EAC_memset((v95 + a1 + 360), 0, 0x800ui64);
    EAC_memset((v95 + a1 + 2408), 0, 0x480ui64);
    v97 = *(a1 + 24);
    v98 = *(a1 + 4 * v97 + 44);
    if ( v98 )
    {
      v99 = v96;
      v100 = v98;
      do
      {
        v101 = *v99++;
        ++v202[0].m128_i32[v101];
        --v100;
      }
      while ( v100 );
    }
    v102 = 0;
    v201[0] = 0i64;
    v103 = 0;
    v104 = 0i64;
    v105 = 15i64;
    do
    {
      v106 = v202[0].m128_i32[++v104];
      v102 += v106;
      v103 = 2 * (v106 + v103);
      *(v201 + v104 * 4 + 4) = v103;
      --v105;
    }
    while ( v105 );
    if ( v103 != 0x10000 && v102 > 1 )
    {
      v13 = v193;
      v16 = v191;
      v17 = v192;
      v21 = a2;
      goto LABEL_299;
    }
    v107 = -1;
    v108 = 0;
    v197 = 0;
    if ( v98 )
    {
      v109 = v200;
      do
      {
        v110 = 0;
        v111 = *(v108 + v109);
        if ( *(v108 + v109) )
        {
          v112 = *(v201 + v111);
          v113 = v111;
          *(v201 + v111) = v112 + 1;
          do
          {
            v114 = v112 & 1;
            v112 >>= 1;
            v110 = (2 * v110) | v114;
            v115 = v110;
            --v113;
          }
          while ( v113 );
          if ( v111 > 0xA )
          {
            v109 = v200;
            v122 = v110 & 0x3FF;
            v123 = *(v200 + 2 * v122 + 288);
            if ( !*(v200 + 2 * v122 + 288) )
            {
              *(v200 + 2 * v122 + 288) = v107;
              v123 = v107;
              v107 -= 2;
            }
            v124 = v110 >> 9;
            if ( v111 > 0xB )
            {
              v125 = (v111 - 11);
              do
              {
                v124 >>= 1;
                v126 = ~(v123 - (v124 & 1));
                v123 = *(v200 + 2 * v126 + 2336);
                if ( !*(v200 + 2 * v126 + 2336) )
                {
                  *(v200 + 2 * v126 + 2336) = v107;
                  v123 = v107;
                  v107 -= 2;
                }
                --v125;
              }
              while ( v125 );
            }
            v127 = ((v124 >> 1) & 1) - v123;
            v108 = v197;
            *(v200 + 2i64 * (v127 - 1) + 2336) = v197;
          }
          else
          {
            v108 = v197;
            v116 = v197 | (v111 << 9);
            if ( v110 < 0x400 )
            {
              v117 = 1 << v111;
              do
              {
                v118 = v115;
                v115 += v117;
                *(v200 + 2 * v118 + 288) = v116;
              }
              while ( v115 < 0x400 );
              v108 = v197;
            }
            v109 = v200;
          }
        }
        v197 = ++v108;
      }
      while ( v108 < *(a1 + 4i64 * *(a1 + 24) + 44) );
      LODWORD(v97) = *(a1 + 24);
      v9 = -1;
    }
    if ( v97 == 2 )
      break;
LABEL_172:
    *(a1 + 24) = v97 - 1;
  }
  i = 0;
  while ( 2 )
  {
    v16 = v191;
    while ( 2 )
    {
      v119 = *(a1 + 44) + *(a1 + 48);
      if ( i >= v119 )
      {
        if ( i == v119 )
        {
          EAC_memcpy((a1 + 72), (a1 + 0x292C), *(a1 + 44));
          EAC_memcpy((a1 + 0xDE8), (*(a1 + 44) + a1 + 0x292C), *(a1 + 48));
          LODWORD(v97) = *(a1 + 24);
          goto LABEL_172;
        }
        v13 = v193;
        v17 = v192;
        v21 = a2;
        goto LABEL_305;
      }
      if ( v18 >= 0xF )
        goto LABEL_154;
      v10 = v199;
      if ( v199 - v8 >= 2 )
      {
        v131 = v8[1];
        v132 = *v8;
        v8 += 2;
        v19 |= (v132 << v18) | (v131 << (v18 + 8));
        v18 += 16;
        goto LABEL_154;
      }
      while ( 2 )
      {
        v120 = *(a1 + 2 * (v19 & 0x3FF) + 7336);
        if ( v120 >= 0 )
        {
          v121 = v120 >> 9;
          if ( v121 && v18 >= v121 )
            goto LABEL_154;
          goto LABEL_150;
        }
        if ( v18 <= 0xA )
        {
LABEL_150:
          if ( v8 >= v10 )
          {
            *a1 = 16;
            goto LABEL_348;
          }
          v130 = *v8++ << v18;
          v19 |= v130;
          v18 += 8;
          if ( v18 >= 0xF )
            goto LABEL_154;
          continue;
        }
        break;
      }
      v128 = 10;
      while ( 1 )
      {
        v129 = v19 >> v128++;
        v120 = *(a1 + 2 * (~v120 + (v129 & 1)) + 9384);
        if ( v120 >= 0 )
          break;
        if ( v18 < v128 + 1 )
          goto LABEL_150;
      }
LABEL_154:
      v16 = *(a1 + 2 * (v19 & 0x3FF) + 7336);
      if ( v16 < 0 )
      {
        v133 = 10;
        do
        {
          v134 = v19 >> v133++;
          v16 = *(a1 + 2 * (~v16 + (v134 & 1)) + 9384);
        }
        while ( v16 < 0 );
      }
      else
      {
        v133 = v16 >> 9;
        v16 &= 0x1FFu;
      }
      v19 >>= v133;
      v18 -= v133;
      v191 = v16;
      if ( v16 < 0x10 )
      {
        v135 = i++;
        *(v135 + a1 + 10540) = v16;
        continue;
      }
      break;
    }
    if ( v16 == 16 && !i )
    {
      v13 = v193;
      v17 = v192;
      v21 = a2;
      goto LABEL_302;
    }
    v17 = *(qword_1400612B0 + (v16 - 16));
    v192 = v17;
    if ( v18 >= v17 )
    {
LABEL_166:
      v18 -= v17;
      v137 = v19 & ((1 << v17) - 1);
      v19 >>= v17;
      v138 = *(&qword_1400612B0[4] + (v16 - 16)) + v137;
      if ( v16 == 16 )
        v139 = *(i - 1 + a1 + 10540);
      else
        v139 = 0;
      EAC_memset((i + a1 + 0x292C), v139, v138);
      i += v138;
      continue;
    }
    break;
  }
  v10 = v199;
LABEL_164:
  while ( v8 < v10 )
  {
    v136 = *v8++ << v18;
    v19 |= v136;
    v18 += 8;
    if ( v18 >= v17 )
      goto LABEL_166;
  }
  *a1 = 18;
LABEL_348:
  v21 = a2;
LABEL_349:
  v52 = a7;
LABEL_350:
  v187 = (v52 & 2) != 0 ? 5 : 0;
  v9 = v187 - 4;
  v13 = v193;
  v16 = v191;
  v17 = v192;
  v29 = v195;
  if ( v187 != 5 && v187 )
  {
LABEL_352:
    while ( v8 > v21 )
    {
      if ( v18 < 8 )
        break;
      --v8;
      v18 -= 8;
    }
  }
LABEL_18:
  *(a1 + 32) = v16;
  v30 = a5;
  v31 = &v13[-a5];
  *(a1 + 4) = v18;
  *(a1 + 36) = i;
  *(a1 + 40) = v17;
  *(a1 + 64) = v29;
  v194 = v31;
  *(a1 + 56) = v19 & ((1i64 << v18) - 1);
  *a3 = &v8[-v21];
  *a6 = v31;
  if ( (a7 & 9) != 0 && v9 >= 0 )
  {
    v32 = *(a1 + 28);
    v33 = v32;
    v34 = HIWORD(v32);
    for ( j = v31 % 0x15B0; v31; v194 = v31 )
    {
      v36 = 0;
      if ( j > 7 )
      {
        v37 = 7;
        do
        {
          v37 += 8;
          v38 = *v30 + v33;
          v36 += 8;
          v39 = v38 + v34;
          v40 = v30[1] + v38;
          v41 = v40 + v39;
          v42 = v30[2] + v40;
          v43 = v42 + v41;
          v44 = v30[3] + v42;
          v45 = v44 + v43;
          v46 = v30[4] + v44;
          v47 = v46 + v45;
          v48 = v30[5] + v46;
          v49 = v48 + v47;
          v50 = v30[6] + v48;
          v51 = v50 + v49;
          v33 = v30[7] + v50;
          v30 += 8;
          v34 = v33 + v51;
        }
        while ( v37 < j );
        v31 = v194;
      }
      while ( v36 < j )
      {
        v188 = *v30++;
        v33 += v188;
        v34 += v33;
        ++v36;
      }
      v33 %= 0xFFF1u;
      v34 %= 0xFFF1u;
      v31 -= j;
      j = 5552i64;
    }
    v189 = v33 + (v34 << 16);
    *(a1 + 28) = v189;
    if ( !v9 && (a7 & 1) != 0 && v189 != *(a1 + 16) )
      return -2;
  }
  return v9;
}
// 1400612B0: using guessed type __int64 qword_1400612B0[60];
// 1400623D0: using guessed type int dword_1400623D0[32];
// 140062450: using guessed type int dword_140062450[];
// 1400624D0: using guessed type int dword_1400624D0[32];
// 140062550: using guessed type int dword_140062550[38];
// 1400625D0: using guessed type unsigned __int8[24];
// 1400625E8: using guessed type int dword_1400625E8[542];
// 14007E4D0: using guessed type __int128 xmmword_14007E4D0;
// 14007E4E0: using guessed type __m128i xmmword_14007E4E0[3];

//----- (0000000140006394) ----------------------------------------------------
__int64 __fastcall sub_140006394(__int64 a1, __int64 a2)
{
  __int64 Process; // rax MAPDST
  int v6; // ebx
  int v7; // esi
  int v8; // r14d
  __int64 BaseAddress; // rax MAPDST
  int v11; // eax
  char ProcessImageFileName; // al
  int v13; // ecx
  unsigned __int64 v14; // rdx
  unsigned __int64 i; // rcx
  __m128 *v16; // rax
  int v17[17]; // [rsp+4Ch] [rbp-FCh] BYREF
  __int16 v18; // [rsp+90h] [rbp-B8h]
  int v19[4]; // [rsp+98h] [rbp-B0h] BYREF
  __int16 v20[16]; // [rsp+A8h] [rbp-A0h] BYREF
  __m128 v21[8]; // [rsp+C8h] [rbp-80h] BYREF
  _DWORD *NtHeaders; // [rsp+160h] [rbp+18h] BYREF

  Process = Get_PsGetCurrentProcess();
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      Process = *(a1 + 0x210);
      if ( !Process || !*(Process + 0x20) )
      {
        BaseAddress = Get_PsGetProcessSectionBaseAddress(Process);
        if ( BaseAddress )
        {
          EAC_IsUsermodeValidAddress(BaseAddress, 0x1000i64, 8);
          if ( GetModuleInfo(BaseAddress, 0x1000ui64, 0i64, &NtHeaders) )
          {
            v11 = Check_Process_Architecture();
            if ( v11 == 32 || v11 == 64 )
            {
              v6 = NtHeaders[0x16];
              v7 = NtHeaders[0xA];
              v8 = NtHeaders[2];
            }
          }
        }
        ProcessImageFileName = EAC_GetProcessImageFileName(Process, v19);
        v13 = v19[0];

        if ( !ProcessImageFileName )
          v13 = 0x412F4E;

        v19[0] = v13;
        v14 = -1i64;
        do
          ++v14;
        while ( *(v19 + v14) );
        for ( i = 0i64; i < 0xF; ++i )
        {
          if ( i >= v14 )
            break;
          v20[i] = *(v19 + i);
        }
        v20[i] = 0;
        v17[0] = 0x2C38256A;
        v17[1] = 0xFEC66717;
        v17[2] = 0xE45D2DDE;
        v17[3] = 0xA1E8417F;
        v17[4] = 0xAFC31889;
        v17[5] = 0xC0B489D1;
        v17[6] = 0x501716CD;
        v17[7] = 0x7ED2FF3A;
        v17[8] = 0x95FE3C0;
        v17[9] = 0xD31E8E02;
        v17[10] = 0x8D10954B;
        v17[11] = 0x623D6BD6;
        v17[12] = 0x8AF2869;
        v17[13] = 0x92D05A5A;
        v17[14] = 0x14F6A382;
        v17[15] = 0xA4FDF763;
        v17[16] = 0xF44B869A;
        v18 = 0xE708;
        v16 = sub_1400065F8(v17, v21);
        EAC_sprintf_Allocate_Memory(*(a1 + 0x210), v16, a2, v20, v8, v6, v7);
        Process = 0i64;
        memset(v21, 0, 0x46ui64);
      }
    }
  }
  return Process;
}
// 140006394: using guessed type __int16 var_A0[16];
// 140006394: using guessed type __m128 var_80[8];

//----- (00000001400065F8) ----------------------------------------------------
__m128 *__fastcall sub_1400065F8(__int64 a1, __m128 *a2)
{
  unsigned __int64 v4; // rdx
  unsigned int v5; // r8d
  unsigned __int64 v6; // r9
  char v7; // cl
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x46ui64);
  v4 = 0i64;
  v5 = 740107569;
  v6 = 68i64;
  do
  {
    a2->m128_i32[v4] = *(a1 + v4 * 4) ^ v5;
    ++v4;
    v5 = __ROL4__(((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13) ^ (32 * (((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13))), 3);
  }
  while ( v4 < 17 );
  do
  {
    v7 = v5;
    v5 >>= 8;
    result = a2;
    a2->m128_i8[v6] = *(a1 + v6) ^ v7;
    ++v6;
  }
  while ( v6 < 0x46 );
  return result;
}

//----- (00000001400066A0) ----------------------------------------------------
void __fastcall sub_1400066A0(__int64 a1, __int64 a2, ULONG64 a3, __int64 a4)
{
  unsigned __int64 v4; // rdi
  __int64 v9; // rax
  char v10; // al
  int v11; // ecx
  unsigned __int64 v12; // rdx
  unsigned __int64 i; // rcx
  unsigned int v14; // edx
  unsigned __int64 v15; // r8
  char v16; // cl
  __int64 v17; // [rsp+30h] [rbp-D0h]
  __int64 v18; // [rsp+38h] [rbp-C8h]
  unsigned __int64 v19; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v20; // [rsp+48h] [rbp-B8h]
  __int64 v21; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v22; // [rsp+58h] [rbp-A8h]
  unsigned __int64 v23; // [rsp+60h] [rbp-A0h]
  __int64 v24; // [rsp+68h] [rbp-98h]
  __int128 *v25; // [rsp+70h] [rbp-90h]
  __int128 v26[4]; // [rsp+78h] [rbp-88h] BYREF
  int v27[32]; // [rsp+C0h] [rbp-40h] BYREF
  __int16 v28[128]; // [rsp+140h] [rbp+40h] BYREF

  if ( a1 )
  {
    v4 = 0i64;
    if ( a2 )
    {
      if ( *(a2 + 8) )
      {
        if ( *a2 )
        {
          if ( *(a2 + 2) )
          {
            if ( a3 )
            {
              if ( a4 )
              {
                v9 = *(a1 + 528);
                if ( !v9 || !*(v9 + 32) )
                {
                  v10 = sub_14001E77C(a3, v27, 128);
                  v11 = v27[0];
                  if ( !v10 )
                    v11 = 4271950;
                  v12 = -1i64;
                  v27[0] = v11;
                  do
                    ++v12;
                  while ( *(v27 + v12) );
                  for ( i = 0i64; i < 0x7F; ++i )
                  {
                    if ( i >= v12 )
                      break;
                    v28[i] = *(v27 + i);
                  }
                  v28[i] = 0;
                  v17 = 0x6719BF4D9EF34F73i64;
                  WORD2(v24) = -7212;
                  v14 = -1631629528;
                  v15 = 60i64;
                  v18 = 0x3F23893ADEE780C5i64;
                  v19 = 0x81873233487141A8ui64;
                  v20 = 0x95A70DAEA08B2DD8ui64;
                  v21 = 0x159E0F44E867C1CDi64;
                  v22 = 0x9487CB91A6565962ui64;
                  v23 = 0xA0F776BE705F3068ui64;
                  LODWORD(v24) = 1335965;
                  memset(v26, 0, 62);
                  v25 = v26;
                  do
                  {
                    *(v25 + v4) = *(&v17 + v4) ^ v14;
                    v4 += 4i64;
                    v14 = -6037332 - 7261 * v14;
                  }
                  while ( v4 < 0x3C );
                  v25 = v26;
                  do
                  {
                    v16 = v14;
                    v14 >>= 8;
                    *(v25 + v15) = *(&v17 + v15) ^ v16;
                    ++v15;
                  }
                  while ( v15 < 0x3E );
                  EAC_sprintf_Allocate_Memory(
                    *(a1 + 0x210),
                    v26,
                    a2,
                    a3,
                    a4,
                    v28,
                    v17,
                    v18,
                    v19,
                    v20,
                    v21,
                    v22,
                    v23,
                    v24);
                  memset(v26, 0, 0x3Eui64);
                }
              }
            }
          }
        }
      }
    }
  }
}
// 1400066A0: using guessed type __int16 var_110[128];

//----- (00000001400068EC) ----------------------------------------------------
void **__fastcall sub_1400068EC(__int64 a1, __int64 a2, unsigned __int64 BaseAddress, unsigned __int64 Size)
{
  void **result; // rax
  unsigned __int64 v5; // rdi
  DWORD CheckSum; // r15d
  DWORD AddressOfEntryPoint; // r12d
  DWORD TimeDateStamp; // r13d
  unsigned int v12; // edx
  unsigned __int64 v13; // r8
  int v14; // ecx
  char v15; // cl
  DWORD v16; // [rsp+28h] [rbp-A9h]
  DWORD v17; // [rsp+30h] [rbp-A1h]
  DWORD v18; // [rsp+38h] [rbp-99h]
  int v19[21]; // [rsp+48h] [rbp-89h] BYREF
  __int16 v20; // [rsp+9Ch] [rbp-35h]
  char *v21; // [rsp+A0h] [rbp-31h]
  int *v22; // [rsp+A8h] [rbp-29h]
  char v23[86]; // [rsp+B0h] [rbp-21h] BYREF
  void *retaddr; // [rsp+130h] [rbp+5Fh] BYREF
  IMAGE_NT_HEADERS *NtHeaders; // [rsp+138h] [rbp+67h] BYREF

  result = &retaddr;
  v5 = 0i64;
  CheckSum = 0;
  AddressOfEntryPoint = 0;
  TimeDateStamp = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( BaseAddress )
      {
        if ( Size )
        {
          result = *(a1 + 0x210);
          if ( !result || !*(result + 0x20) )
          {
            if ( BaseAddress > MmSystemRangeStart && GetModuleInfo(BaseAddress, Size, 0i64, &NtHeaders) )
            {
              CheckSum = NtHeaders->OptionalHeader.CheckSum;
              AddressOfEntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
              TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
            }
            v19[0] = 0x5EC64153;
            v19[1] = 0xD3423E93;
            v19[2] = 0x5621C2DC;
            v19[3] = 0x2F69A69E;
            v19[4] = 0xE79FBAB4;
            v19[5] = 0xC4CA6FB6;
            v19[6] = 0x178AE4C0;
            v19[7] = 0xD2211C32;
            v19[8] = 0xCA335A8F;
            v19[9] = 0x4D69ED91;
            v19[10] = 0x1508B656;
            v19[11] = 035512245372;
            v19[12] = 0xB40EBEB1;
            v19[13] = 0xA1571EA;
            v19[14] = 0x4B0EBC63;
            v19[15] = 0x2F5B434B;
            v19[16] = 0x6EDE0326;
            v19[17] = 0x55F5A37A;
            v19[18] = 0x7501A717;
            v19[19] = 0x219C276A;
            v19[20] = 0xB2B8090D;
            v20 = 0xE5C9;
            EAC_memset(v23, 0, 0x56ui64);
            v12 = 1586839816;
            v22 = v19;
            v13 = 84i64;
            v21 = v23;
            do
            {
              v14 = v22[v5] ^ v12;
              v12 = __ROR4__(214013 * v12 + 0x269EC3, 2);
              *&v21[v5 * 4] = v14;
              ++v5;
            }
            while ( v5 < 21 );
            NtHeaders = v19;
            v21 = v23;
            do
            {
              v15 = v12;
              v12 >>= 8;
              v21[v13] = *(&NtHeaders->Signature + v13) ^ v15;
              ++v13;
            }
            while ( v13 < 0x56 );
            v18 = AddressOfEntryPoint;
            v17 = CheckSum;
            v16 = TimeDateStamp;
            EAC_sprintf_Allocate_Memory(*(a1 + 0x210), v23, a2, Size, v16, v17, v18);
            result = 0i64;
            memset(v23, 0, sizeof(v23));
          }
        }
      }
    }
  }
  return result;
}

//----- (0000000140006E48) ----------------------------------------------------
char __fastcall Read_PhysicalMemory(unsigned __int64 BaseAddress, __int64 *VirtualAddress, __int64 *Length)
{
  char ret; // si MAPDST
  unsigned __int64 cr3; // rax
  __int64 Address; // rbx
  unsigned __int64 Value; // rdi
  __int64 v10; // rax
  __int64 v14; // r10
  __int64 Final_TargetAddress_2; // r10
  PVOID Virtua_lAddress; // rax
  __int64 Final_TargetAddress; // r9
  __int64 TargetAddress; // [rsp+20h] [rbp-10h] BYREF
  __int64 TargetAddress_4; // [rsp+28h] [rbp-8h] MAPDST BYREF
  __int64 TargetAddress_3; // [rsp+60h] [rbp+30h] MAPDST BYREF
  __int64 TargetAddress_2; // [rsp+78h] [rbp+48h] MAPDST BYREF

  ret = 0;
  cr3 = __readcr3();
  if ( MmPhysicalMemory((cr3 & 0xFFFFFFFFF000i64) + ((BaseAddress >> 36) & 0xFF8), 8i64, &TargetAddress) == 8
    && (TargetAddress & 1) != 0
    && MmPhysicalMemory((TargetAddress & 0xFFFFFFFFF000i64) + ((BaseAddress >> 27) & 0xFF8), 8i64, &TargetAddress_2) == 8
    && (TargetAddress_2 & 1) != 0
    && (TargetAddress_2 & 0x80u) == 0i64 )
  {
    Address = (TargetAddress_2 & 0xFFFFFFFFF000i64) + ((BaseAddress >> 18) & 0xFF8);
    if ( MmPhysicalMemory(Address, 8i64, &TargetAddress_3) == 8 && (TargetAddress_3 & 1) != 0 )
    {
      if ( (TargetAddress_3 & 0x80u) != 0i64 )
      {
        Virtua_lAddress = Get_MmGetVirtualForPhysical(Address);
        *VirtualAddress = Virtua_lAddress;
        Final_TargetAddress = (TargetAddress | TargetAddress_2 | TargetAddress_3) ^ (TargetAddress_3 ^ (TargetAddress | TargetAddress_2 | TargetAddress_3)) & 0x7FFFFFFFFFFFFFFFi64;
        *Length = Final_TargetAddress ^ (Final_TargetAddress ^ (TargetAddress & TargetAddress_2 & TargetAddress_3)) & 2;
        return 1;
      }
      Value = BaseAddress >> 9;
      if ( MmPhysicalMemory((Value & 0xFF8) + (TargetAddress_3 & 0xFFFFFFFFF000i64), 8i64, &TargetAddress_4) == 8 )
      {
        v10 = (loc_14001A5B8)();
        ret = TargetAddress_3;
        ret = TargetAddress_2;
        v14 = TargetAddress_2 | TargetAddress_3 | TargetAddress_4;
        *VirtualAddress = (Value & 0x7FFFFFFFF8i64) + v10;
        Final_TargetAddress_2 = (TargetAddress | v14) ^ (TargetAddress_4 ^ (TargetAddress | v14)) & 0x7FFFFFFFFFFFFFFFi64;
        *Length = Final_TargetAddress_2 ^ (Final_TargetAddress_2 ^ (TargetAddress & ret & ret & TargetAddress_4)) & 2;
        return 1;
      }
    }
  }
  return ret;
}

//----- (0000000140007048) ----------------------------------------------------
char __fastcall sub_140007048(unsigned __int64 a1, __int64 *a2, __int64 *a3)
{
  char v3; // r14
  _QWORD *v7; // rdi
  _QWORD *v8; // rsi
  __int64 v9; // rbx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rdx

  v3 = 0;
  if ( KUSER_SHARED_DATA.NtMajorVersion >= 10 )
    return 0;

  v7 = (((a1 >> 36) & 0xFF8) - 0x90482413000i64);
  if ( (*v7 & 1) != 0 )
  {
    v8 = (((a1 >> 27) & 0x1FFFF8) - 0x90482600000i64);
    if ( (*v8 & 1) != 0 && (*v8 & 0x80u) == 0i64 )
    {
      v9 = ((a1 >> 18) & 0x3FFFFFF8) - 0x904C0000000i64;
      if ( (*v9 & 1) != 0 )
      {
        if ( (*v9 & 0x80u) != 0i64 )
        {
          *a2 = v9;
          *a3 = v9;
          v13 = (*v7 | *v8 | *v9) ^ (v9 ^ (*v7 | *v8 | *v9)) & 0x7FFFFFFFFFFFFFFFi64;
          *a3 = v13;
          *a3 = v13 | *v7 & *v8 & *v9 & 2;
          return 1;
        }
        v10 = (((a1 >> 9) & 0x7FFFFFFFF8i64) + (loc_14001A5B8)());
        if ( (v10 + 0x13000000000i64) <= 0x7FFFFFFFFFi64 )
        {
          *a2 = v10;
          v11 = *v10;
          *a3 = *v10;
          v12 = (*v10 | *v7 | *v8 | *v9) ^ (v11 ^ (*v10 | *v7 | *v8 | *v9)) & 0x7FFFFFFFFFFFFFFFi64;
          *a3 = v12;
          *a3 = v12 ^ (v12 ^ (*v10 & *v7 & *v8 & *v9)) & 2;
          return 1;
        }
      }
    }
  }
  return v3;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (00000001400071F4) ----------------------------------------------------
char __fastcall EAC_Read_PhysicalMemory(signed __int64 BaseAddress, __int64 *PhysicalAddress, void *Length)
{
  char v3; // r9

  v3 = 0;
  if ( BaseAddress )
  {
    if ( Length )
    {
      if ( PhysicalAddress )
      {
        *PhysicalAddress = 0i64;
        memset(Length, 0, 8ui64);
        if ( (BaseAddress >> 0x30 == -1 || BaseAddress >> 0x30 == 0) && BaseAddress >= MmSystemRangeStart )
        {
          if ( KUSER_SHARED_DATA.NtMajorVersion < 10 )
            return Read_PhysicalMemory_Win7(BaseAddress, PhysicalAddress, Length);// Less than Win 10
          else
            return Read_PhysicalMemory(BaseAddress, PhysicalAddress, Length);// Win 10 or higher
        }
      }
    }
  }
  return v3;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014000731C) ----------------------------------------------------
void __fastcall sub_14000731C(__int64 a1)
{
  unsigned int idx; // ebx
  __int64 ProcessId; // r14
  int Size; // r15d
  int v5; // r15d
  unsigned int *Buffer; // rax MAPDST
  __int64 v8; // rax

  if ( a1 )
  {
    idx = 0;
    if ( *(a1 + 8) )
    {
      ProcessId = g_EAC_ProcessIg;
      if ( g_EAC_ProcessIg )
      {
        Size = 0x1000;
        if ( KUSER_SHARED_DATA.NtMajorVersion == 5 )
          Size = 0x400;

        v5 = Size | 0x100001;
        Buffer = EAC_NtQuerySystemInformation(0x10u, 0x80000u, 0x1000000u, 0i64);
        if ( Buffer )
        {
          if ( *Buffer )
          {
            do
            {
              v8 = Buffer[6 * idx + 2];
              if ( v8 == ProcessId
                && v8 > 4
                && sub_140050898(*&Buffer[6 * idx + 4]) == PsProcessType
                && *(a1 + 8) == *&Buffer[6 * idx + 4]
                && (~v5 & Buffer[6 * idx + 6]) != 0 )
              {
                sub_140052970(ProcessId, HIWORD(Buffer[6 * idx + 3]));
              }
              ++idx;
            }
            while ( idx < *Buffer );
          }
          Get_ExFreePool(Buffer);
        }
      }
    }
  }
}
// 140083238: using guessed type __int64 EAC_ProcessId;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140007418) ----------------------------------------------------
char __fastcall sub_140007418(volatile void *a1, _OWORD *a2)
{
  ProbeForRead(a1, 0x1000ui64, 1u);
  EAC_memcpy(a2, a1, 0x1000ui64);
  return 1;
}

//----- (0000000140007B48) ----------------------------------------------------
void sub_140007B48()
{
  if ( _InterlockedCompareExchange(&dword_140083330, 0, 0) )
  {
    ExAcquireFastMutex(&FastMutex);
    sub_140023184(P);
    ExReleaseFastMutex(&FastMutex);
  }
}
// 140083330: using guessed type int dword_140083330;

//----- (0000000140007B88) ----------------------------------------------------
unsigned __int64 __fastcall sub_140007B88(unsigned __int64 a1, __int64 a2, _QWORD *a3)
{
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rdi
  __int64 Memory; // rax
  char *v9; // rsi
  unsigned __int64 v10; // rbx
  _OWORD *v11; // rax
  __m128 v13; // [rsp+20h] [rbp-60h] BYREF
  __int64 v14; // [rsp+30h] [rbp-50h]
  unsigned int v15; // [rsp+38h] [rbp-48h]
  __int64 v16; // [rsp+48h] [rbp-38h]
  void (__fastcall *v17)(__int64); // [rsp+58h] [rbp-28h]
  __int64 v18; // [rsp+60h] [rbp-20h]

  v6 = 0i64;
  EAC_memset(&v13, 0, 0x58ui64);
  if ( !a1 || (a2 - 1) > 0x63FFF || !a3 )
    return 0i64;
  *a3 = 0i64;
  v7 = 20 * a2;
  Memory = EAC_Allocate_Memory(20 * a2);
  v9 = Memory;
  if ( Memory )
  {
    v13.m128_u64[0] = a1;
    v13.m128_i32[2] = a2;
    v14 = Memory;
    v15 = 20 * a2;
    if ( !sub_140004AC0(&v13) )
    {
      if ( sub_140004B88(&v13) == 1 && !v13.m128_i32[2] )
      {
        if ( v15 )
        {
          v10 = v7 - v15;
          if ( v10 < v7 )
          {
            v11 = EAC_Allocate_Memory(v7 - v15);
            *a3 = v11;
            if ( v11 )
            {
              EAC_memcpy(v11, v9, v10);
              v6 = v10;
            }
          }
        }
      }
      if ( v16 )
        v17(v18);
    }
    Get_ExFreePool(v9);
  }
  return v6;
}

//----- (0000000140007CA4) ----------------------------------------------------
// from @Swiftik
__int64 __fastcall EAC_HashCR32(_BYTE *buffer, unsigned int bufferSize)
{
  unsigned int ret; // r8d
  __int64 Size; // r10
  __int64 dec; // rcx

  ret = -1;
  if ( bufferSize )
  {
    Size = bufferSize;
    do
    {
      dec = (ret ^ *buffer++);
      ret = dword_140062E60[dec] ^ (ret >> 8);
      --Size;
    }
    while ( Size );
  }
  return ~ret;
}
// 140062E60: using guessed type _DWORD dword_140062E60[262];

//----- (0000000140007CE0) ----------------------------------------------------
char __fastcall EAC_Copy_User_Page(char *Address, __int64 Unknown, _OWORD *Buffer)
{
  char ret; // dl

  ret = 0;
  if ( Address && Address < MmHighestUserAddress && Address + 0x1000 < MmHighestUserAddress && Buffer )
  {
    EAC_IsUsermodeValidAddress(Address, 0x1000i64, 1);
    EAC_memcpy(Buffer, Address, 0x1000ui64);
    return 1;
  }
  return ret;
}

//----- (0000000140008308) ----------------------------------------------------
char __fastcall sub_140008308(_DWORD *a1)
{
  __int64 Process; // rsi
  __int64 IsProcessId; // rax
  __int64 ProcessId; // rax
  unsigned __int64 v5; // rdi
  int v6; // edx
  char v7; // r9
  char v8; // dl
  int v9; // edx
  unsigned __int64 v10; // rdi
  int v11; // edx
  unsigned __int64 v12; // rdi
  unsigned int v13; // edx
  unsigned __int64 v14; // rdi
  int v15; // ecx
  unsigned __int64 v16; // rdi
  char v17; // cl
  unsigned int v18; // edi
  unsigned __int64 v19; // r8
  unsigned __int64 v20; // r8
  char v21; // cl
  int v23[3]; // [rsp+20h] [rbp-59h] BYREF
  char v24; // [rsp+2Ch] [rbp-4Dh]
  int v25[3]; // [rsp+2Dh] [rbp-4Ch] BYREF
  __int16 v26; // [rsp+39h] [rbp-40h]
  int v27[3]; // [rsp+3Bh] [rbp-3Eh] BYREF
  __int16 v28; // [rsp+47h] [rbp-32h]
  char v29; // [rsp+49h] [rbp-30h]
  int v30[3]; // [rsp+4Ah] [rbp-2Fh] BYREF
  int v31[4]; // [rsp+56h] [rbp-23h] BYREF
  __int64 v32; // [rsp+68h] [rbp-11h] BYREF
  int v33; // [rsp+70h] [rbp-9h]
  __int16 v34; // [rsp+74h] [rbp-5h]
  _BYTE v35[15]; // [rsp+78h] [rbp-1h] BYREF
  _BYTE v36[14]; // [rsp+87h] [rbp+Eh] BYREF
  _BYTE v37[13]; // [rsp+95h] [rbp+1Ch] BYREF
  _BYTE v38[12]; // [rsp+A2h] [rbp+29h] BYREF
  __int64 v39[4]; // [rsp+AEh] [rbp+35h] BYREF
  PVOID Object; // [rsp+E8h] [rbp+6Fh] BYREF
  int *v41; // [rsp+F0h] [rbp+77h]
  __int64 *v42; // [rsp+F8h] [rbp+7Fh]

  LODWORD(Object) = 0;
  Process = Get_PsGetCurrentProcess();
  IsProcessId = Get_PsGetProcessId(Process);
  LOBYTE(ProcessId) = EAC_Is_Equal_ProcessId(IsProcessId);

  if ( ProcessId )
    return ProcessId;

  LOBYTE(ProcessId) = EAC_GetProcessImageFileName(Process, &v32);

  if ( !ProcessId )
    return ProcessId;

  v30[0] = 849134504;
  v39[0] = 0i64;
  v5 = 0i64;
  LODWORD(v39[1]) = 0;
  v6 = -1450790646;
  v30[1] = 1597274410;
  v30[2] = -2001491090;
  v41 = v30;
  v42 = v39;
  do
  {
    v6 = __ROL4__(((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13) ^ (32 * (((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13))), 3);
    *(v42 + v5 * 4) = v41[v5] ^ v6;
    ++v5;
  }
  while ( v5 < 3 );
  v7 = 1;
  v8 = 1;
  if ( v32 != v39[0] || v33 != LOWORD(v39[1]) || BYTE2(v33) != BYTE2(v39[1]) )
  {
    v31[0] = -506173472;
    memset(v38, 0, sizeof(v38));
    v9 = -1863234418;
    v10 = 0i64;
    v31[1] = -1754065982;
    v31[2] = -719162452;
    v41 = v31;
    v42 = v38;
    do
    {
      v9 = __ROL4__(1140671485 * v9 + 12820163, 4);
      *(v42 + v10 * 4) = v41[v10] ^ v9;
      ++v10;
    }
    while ( v10 < 3 );
    v8 = 3;
    if ( v32 != *v38 || v33 != *&v38[8] || BYTE2(v33) != v38[10] )
    {
      v23[0] = 0xA09900B5;
      memset(v37, 0, sizeof(v37));
      v11 = -873831999;
      v12 = 0i64;
      v23[1] = -1386799633;
      v23[2] = -79590155;
      v24 = -84;
      v41 = v23;
      v42 = v37;
      do
      {
        *(v42 + v12 * 4) = v41[v12] ^ v11;
        ++v12;
        v11 = __ROL4__(
                ((v11 ^ (v11 << 13)) >> 17) ^ v11 ^ (v11 << 13) ^ (32 * (((v11 ^ (v11 << 13)) >> 17) ^ v11 ^ (v11 << 13))),
                4);
      }
      while ( v12 < 3 );
      v41 = v23;
      v42 = v37;
      v37[12] = v24 ^ v11;
      v8 = 7;
      if ( v32 != *v37 || v33 != *&v37[8] )
      {
        v27[0] = 0xAD8F8DEC;
        memset(v35, 0, sizeof(v35));
        v13 = 0xC6FCEC98;
        v14 = 0i64;
        v27[1] = 0xCE1DF315;
        v27[2] = 0x2DE686C3;
        v28 = 14352;
        v29 = 13;
        v41 = v27;
        v42 = v35;
        do
        {
          v15 = v41[v14] ^ v13;
          v13 = __ROR4__(1140671485 * v13 + 12820163, 1);
          *(v42 + v14 * 4) = v15;
          ++v14;
        }
        while ( v14 < 3 );
        v16 = 12i64;
        v41 = v27;
        v42 = v35;
        do
        {
          v17 = v13;
          v13 >>= 8;
          *(v42 + v16) = *(v41 + v16) ^ v17;
          ++v16;
        }
        while ( v16 < 0xF );
        v8 = 15;
        if ( v32 != *v35 || v33 != *&v35[8] || v34 != *&v35[12] )
        {
          v25[0] = 779616169;
          memset(v36, 0, sizeof(v36));
          v8 = 31;
          v18 = 1157930717;
          v19 = 0i64;
          v25[1] = -2034666650;
          v25[2] = 530694210;
          v26 = -21975;
          v41 = v25;
          v42 = v36;
          do
          {
            *(v42 + v19 * 4) = v41[v19] ^ v18;
            ++v19;
            v18 = -(((v18 ^ (v18 << 13)) >> 17) ^ v18 ^ (v18 << 13) ^ (32
                                                                     * (((v18 ^ (v18 << 13)) >> 17) ^ v18 ^ (v18 << 13))));
          }
          while ( v19 < 3 );
          v20 = 12i64;
          v41 = v25;
          v42 = v36;
          do
          {
            v21 = v18;
            v18 >>= 8;
            *(v42 + v20) = *(v41 + v20) ^ v21;
            ++v20;
          }
          while ( v20 < 0xE );
          if ( v32 != *v36 || v33 != *&v36[8] || v34 != v36[12] )
          {
            v7 = 0;
LABEL_34:
            v8 &= ~0x10u;
            memset(v36, 0, sizeof(v36));
            goto LABEL_35;
          }
        }
      }
    }
  }
  if ( (v8 & 0x10) != 0 )
    goto LABEL_34;
LABEL_35:
  if ( (v8 & 8) != 0 )
  {
    v8 &= ~8u;
    memset(v35, 0, sizeof(v35));
  }
  if ( (v8 & 4) != 0 )
    memset(v37, 0, sizeof(v37));

  if ( (v8 & 2) != 0 )
    memset(v38, 0, sizeof(v38));

  LOBYTE(ProcessId) = 0;
  memset(v39, 0, 0xCui64);

  if ( v7 )
  {
    *a1 |= 0x2000u;
    ProcessId = sub_140053088(Process);
    if ( ProcessId && (LODWORD(ProcessId) = Get_PsLookupProcessByProcessId(ProcessId, &Object), ProcessId >= 0) )
    {
      if ( KUSER_SHARED_DATA.NtMajorVersion != 5 && !sub_1400408B0(Object) )
        *a1 |= 0x4000u;

      LOBYTE(ProcessId) = ObfDereferenceObject(Object);
    }
    else
    {
      *a1 |= 0x4000u;
    }
  }
  return ProcessId;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140008BF4) ----------------------------------------------------
__int64 __fastcall sub_140008BF4(__int64 Buffer)
{
  __int64 Buffer_2; // rcx
  __int64 i; // rdi
  __int64 Buffer_3; // rcx
  __int64 result; // rax

  if ( Buffer )
  {
    Buffer_2 = *Buffer;
    if ( Buffer_2 )
      Get_ExFreePool(Buffer_2);

    if ( *(Buffer + 0x10) )
      EAC_Free_UnicodeString((Buffer + 0x18));

    for ( i = 0i64; i < *(Buffer + 0x28); i = (i + 1) )
    {
      Buffer_3 = *(Buffer + 24 * i + 0x38);
      if ( Buffer_3 )
        Get_ExFreePool(Buffer_3);
    }
    return Get_ExFreePool(Buffer);
  }
  return result;
}

//----- (0000000140009178) ----------------------------------------------------
bool __fastcall Process_is_x86(__int64 ProcessId, __int64 a2)
{
  bool ret; // bl
  PVOID Object; // [rsp+30h] [rbp+8h] BYREF

  if ( !ProcessId || !a2 || Get_PsLookupProcessByProcessId(ProcessId, &Object) < 0 )
    return 1;

  ret = Get_PsGetProcessWow64Process(Object) != 64
     || KUSER_SHARED_DATA.NtMajorVersion < 0xA
     || (loc_1400327F4)(Object, 0x340i64, &a2, 8i64) != 0;

  ObfDereferenceObject(Object);

  return ret;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140009294) ----------------------------------------------------
char __fastcall sub_140009294(unsigned __int16 *a1, _UNICODE_STRING *unicode_string)
{
  char result; // al
  unsigned __int16 *v4; // r8
  __int64 Size; // rcx
  unsigned __int16 *v6; // r11
  unsigned __int64 i; // rdx
  unsigned __int64 v8; // r10
  unsigned __int16 Length[4]; // [rsp+20h] [rbp-18h] BYREF
  unsigned __int16 *v10; // [rsp+28h] [rbp-10h]

  result = 0;
  if ( a1 && unicode_string )
  {
    v4 = a1 + 1;
    Size = *a1;
    if ( v4 )
    {
      v6 = v4;
      for ( i = Size >> 1; i; --i )
      {
        if ( !*v6 )
          break;
        ++v6;
      }
      if ( i )
        v8 = (Size >> 1) - i;
      else
        v8 = 0i64;
      if ( i )
        Size = 2 * v8;
    }
    if ( Size )
    {
      v10 = v4;
      Length[0] = Size;
      Length[1] = Size;
      if ( v4 )
      {
        if ( Size )
          return EAC_Allocate_Unicode_string(unicode_string, Length, Size);
      }
    }
    else
    {
      *&unicode_string->Length = 0;
      unicode_string->Buffer = 0i64;
      return 1;
    }
  }
  return result;
}

//----- (0000000140009564) ----------------------------------------------------
__int64 __fastcall sub_140009564(__int64 a1)
{
  __int64 result; // rax
  _WORD *v3; // rcx
  _WORD *v4; // rcx
  _WORD *v5; // rcx

  if ( a1 )
  {
    if ( *(a1 + 8) && *a1 && *(a1 + 2) )
      result = EAC_Free_UnicodeString(a1);
    v3 = (a1 + 16);
    if ( a1 != -16 && *(a1 + 24) && *v3 && *(a1 + 18) )
      result = EAC_Free_UnicodeString(v3);
    v4 = (a1 + 32);
    if ( a1 != -32 && *(a1 + 40) && *v4 && *(a1 + 34) )
      result = EAC_Free_UnicodeString(v4);
    v5 = (a1 + 48);
    if ( a1 != -48 && *(a1 + 56) && *v5 )
    {
      if ( *(a1 + 50) )
        return EAC_Free_UnicodeString(v5);
    }
  }
  return result;
}

//----- (0000000140009828) ----------------------------------------------------
__int64 __fastcall sub_140009828(_UNICODE_STRING *ObjectName)
{
  __int64 result; // rax
  _UNICODE_STRING *unicode_string_1; // rcx
  _UNICODE_STRING *unicode_string_2; // rcx
  _UNICODE_STRING *unicode_string_3; // rcx
  _UNICODE_STRING *unicode_string_4; // rcx

  if ( ObjectName )
  {
    if ( ObjectName->Buffer && ObjectName->Length && ObjectName->MaximumLength )
      result = EAC_Free_UnicodeString(ObjectName);

    unicode_string_1 = ObjectName + 1;
    if ( ObjectName != 0xFFFFFFFFFFFFFFF0i64
      && ObjectName[1].Buffer
      && unicode_string_1->Length
      && ObjectName[1].MaximumLength )
    {
      result = EAC_Free_UnicodeString(unicode_string_1);
    }

    unicode_string_2 = ObjectName + 2;
    if ( ObjectName != 0xFFFFFFFFFFFFFFE0i64
      && ObjectName[2].Buffer
      && unicode_string_2->Length
      && ObjectName[2].MaximumLength )
    {
      result = EAC_Free_UnicodeString(unicode_string_2);
    }

    unicode_string_3 = ObjectName + 3;
    if ( ObjectName != 0xFFFFFFFFFFFFFFD0i64
      && ObjectName[3].Buffer
      && unicode_string_3->Length
      && ObjectName[3].MaximumLength )
    {
      result = EAC_Free_UnicodeString(unicode_string_3);
    }

    unicode_string_4 = ObjectName + 4;
    if ( ObjectName != 0xFFFFFFFFFFFFFFC0i64 && ObjectName[4].Buffer && unicode_string_4->Length )
    {
      if ( ObjectName[4].MaximumLength )
        return EAC_Free_UnicodeString(unicode_string_4);
    }
  }
  return result;
}

//----- (0000000140009B10) ----------------------------------------------------
char __fastcall sub_140009B10(__int64 a1, __int64 a2)
{
  char result; // al
  struct _FAST_MUTEX *v4; // rsi
  struct _KEVENT *Event; // rbp
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // rdi
  char v9; // di
  __int64 v10; // rcx
  __int128 v11; // xmm0
  __int128 v12; // [rsp+30h] [rbp-38h]

  result = *(a2 + 24);
  if ( !result )
  {
    v4 = (a2 + 48);
    Event = (a2 + 104);
    do
    {
      v6 = -1i64;
      ExAcquireFastMutex(v4);
      if ( *(a2 + 24) )
        goto LABEL_7;
      v7 = *(a2 + 32);
      if ( !v7 )
        goto LABEL_8;
      v8 = *(v7 + 16);
      if ( KUSER_SHARED_DATA.TickCountQuad >= v8 )
LABEL_7:
        v6 = 0i64;
      else
        v6 = v8 - KUSER_SHARED_DATA.TickCountQuad;
LABEL_8:
      ExReleaseFastMutex(v4);
      if ( v6 != -1 )
      {
        if ( !v6 )
          goto LABEL_12;
        KeQueryTimeIncrement();
      }
      Get_KeWaitForSingleObject(Event);
LABEL_12:
      KeClearEvent(Event);
      while ( 1 )
      {
        v9 = 0;
        ExAcquireFastMutex(v4);
        if ( !*(a2 + 24) )
        {
          v10 = *(a2 + 32);
          if ( v10 )
          {
            if ( KUSER_SHARED_DATA.TickCountQuad >= *(v10 + 16) )
            {
              v11 = *v10;
              v9 = 1;
              *(a2 + 32) = *(v10 + 24);
              v12 = v11;
              Get_ExFreePool(v10);
            }
          }
        }
        ExReleaseFastMutex(v4);
        if ( !v9 || *(a2 + 24) )
          break;
        *(a2 + 40) = KUSER_SHARED_DATA.TickCountQuad;
        (v12)(a2, *(&v12 + 1));
        *(a2 + 40) = 0i64;
      }
      result = *(a2 + 24);
    }
    while ( !result );
  }
  return result;
}
// 140009C2E: variable 'v12' is possibly undefined
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140009C5C) ----------------------------------------------------
struct_EAC_Event *sub_140009C5C()
{
  struct_EAC_Event *Allocate; // rax
  struct_EAC_Event *ret; // rbx
  __int64 v2; // r8
  __int64 v3; // rax
  __int64 v4; // rax

  if ( !_InterlockedCompareExchange(&dword_140083334, 1, 0) )
  {
    stru_140083348.Owner = 0i64;
    stru_140083348.Contention = 0;
    qword_140083340 = &qword_140083338;
    qword_140083338 = &qword_140083338;
    stru_140083348.Count = 1;
    KeInitializeEvent(&stru_140083348.Event, SynchronizationEvent, 0);
  }
  Allocate = EAC_Allocate_Memory(0x80ui64);
  ret = Allocate;
  if ( Allocate )
  {
    Allocate->qword38 = 0i64;
    Allocate->dword40 = 0;
    Allocate->byte18 = 0;
    Allocate->qword20 = 0i64;
    Allocate->qword28 = 0i64;
    Allocate->dword30 = 1;
    KeInitializeEvent(&Allocate->event, SynchronizationEvent, 0);
    KeInitializeEvent(&ret[1].gap0[8], NotificationEvent, 0);
    LOBYTE(v2) = 1;
    v3 = (loc_140051D08)(sub_140009B10, ret, v2);
    *&ret->gap0[16] = v3;
    if ( v3 )
    {
      ExAcquireFastMutex(&stru_140083348);
      v4 = qword_140083338;
      if ( *(qword_140083338 + 8) != &qword_140083338 )
        __fastfail(3u);
      *ret->gap0 = qword_140083338;
      *&ret->gap0[8] = &qword_140083338;
      *(v4 + 8) = ret;
      qword_140083338 = ret;
      ExReleaseFastMutex(&stru_140083348);
    }
    else
    {
      Get_ExFreePool(ret);
      return 0i64;
    }
  }
  return ret;
}
// 140009D19: variable 'v2' is possibly undefined
// 140083334: using guessed type int dword_140083334;
// 140083338: using guessed type __int64 qword_140083338;
// 140083340: using guessed type __int64 qword_140083340;

//----- (0000000140009D88) ----------------------------------------------------
int __fastcall sub_140009D88(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  char v7; // si
  unsigned __int64 Memory; // rax
  unsigned __int64 v9; // r15
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rcx

  v7 = 0;
  Memory = 10000 * a4 / KeQueryTimeIncrement();
  v9 = Memory;
  if ( a1 )
  {
    if ( a2 )
    {
      Memory = EAC_Allocate_Memory(0x20ui64);
      v10 = Memory;
      if ( Memory )
      {
        *(Memory + 24) = 0i64;
        *Memory = a2;
        *(Memory + 8) = a3;
        *(Memory + 16) = v9 + KUSER_SHARED_DATA.TickCountQuad;
        ExAcquireFastMutex((a1 + 48));
        if ( *(a1 + 24) )
          goto LABEL_14;
        v11 = *(a1 + 32);
        v12 = 0i64;
        if ( !v11 )
          goto LABEL_11;
        do
        {
          if ( *(v11 + 16) >= *(v10 + 16) )
            break;
          v12 = v11;
          v11 = *(v11 + 24);
        }
        while ( v11 );
        if ( v12 )
        {
          *(v12 + 24) = v10;
          if ( !v11 )
          {
LABEL_13:
            v7 = 1;
LABEL_14:
            ExReleaseFastMutex((a1 + 48));
            if ( v7 )
              LODWORD(Memory) = KeSetEvent((a1 + 104), 0, 0);
            else
              LODWORD(Memory) = Get_ExFreePool(v10);
            return Memory;
          }
        }
        else
        {
LABEL_11:
          *(a1 + 32) = v10;
        }
        *(v10 + 24) = v11;
        goto LABEL_13;
      }
    }
  }
  return Memory;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140009E9C) ----------------------------------------------------
void __fastcall sub_140009E9C(__int64 a1)
{
  __int64 v2; // rdx
  _QWORD *v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rcx

  if ( a1 )
  {
    ExAcquireFastMutex(&stru_140083348);
    v2 = *a1;
    v3 = *(a1 + 8);
    if ( *(*a1 + 8i64) != a1 || *v3 != a1 )
      __fastfail(3u);
    *v3 = v2;
    *(v2 + 8) = v3;
    ExReleaseFastMutex(&stru_140083348);
    *(a1 + 24) = 1;
    KeSetEvent((a1 + 104), 0, 0);
    (loc_140051FDC)(*(a1 + 16));
    ExAcquireFastMutex((a1 + 48));
    v4 = *(a1 + 32);
    while ( v4 )
    {
      v5 = v4;
      v4 = *(v4 + 24);
      Get_ExFreePool(v5);
    }
    ExReleaseFastMutex((a1 + 48));
    Get_ExFreePool(a1);
  }
}

//----- (000000014000A0BC) ----------------------------------------------------
char __fastcall sub_14000A0BC(__int64 a1)
{
  char v1; // dl

  v1 = 0;
  if ( a1 && *(a1 + 24) )
    return 1;
  return v1;
}

//----- (000000014000A24C) ----------------------------------------------------
__int64 *__fastcall sub_14000A24C(__int64 **a1)
{
  __int64 *result; // rax
  __int64 v3; // rdx

  for ( result = *a1; *a1 != a1; result = *a1 )
  {
    v3 = *result;
    if ( result[1] != a1 || *(v3 + 8) != result )
      __fastfail(3u);
    *a1 = v3;
    *(v3 + 8) = a1;
    Get_ExFreePool(result);
  }
  return result;
}

//----- (000000014000A36C) ----------------------------------------------------
void __fastcall sub_14000A36C(int *a1)
{
  int v1; // eax
  _DWORD *v2; // rdi
  unsigned int v3; // r11d
  __int64 v4; // r10
  _DWORD *v5; // rdx
  _DWORD *v6; // r8
  __int64 v7; // rbx
  _OWORD *v8; // rax
  char *v9; // rcx
  __int64 v10; // r9
  __int128 v11; // xmm1
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm0
  __int64 v19; // r9
  __int128 v20; // xmm1
  __int64 v21; // rax
  _OWORD *v22; // rcx
  _OWORD *v23; // rax
  __int128 v24; // xmm1
  __int128 v25; // xmm0
  __int128 v26; // xmm1
  __int128 v27; // xmm0
  __int128 v28; // xmm1
  __int128 v29; // xmm0
  __int128 v30; // xmm1
  __int128 v31; // xmm0
  __int64 v32; // r9
  __int128 v33; // xmm1
  __int64 v34; // rax
  _OWORD *v35; // rcx
  char *v36; // rax
  __int128 v37; // xmm1
  __int128 v38; // xmm0
  __int128 v39; // xmm1
  __int128 v40; // xmm0
  __int128 v41; // xmm1
  __int128 v42; // xmm0
  __int128 v43; // xmm1
  __int128 v44; // xmm0
  __int128 v45; // xmm1
  __int64 v46; // rax
  char v47[304]; // [rsp+0h] [rbp-138h] BYREF

  if ( a1 )
  {
    v1 = *a1;
    v2 = a1 + 2;
    if ( *a1 > 1 )
    {
      v3 = v1 - 1;
      v4 = (v1 - 1);
      do
      {
        if ( v3 )
        {
          v5 = v2;
          v6 = v2 + 74;
          v7 = v3;
          do
          {
            if ( *(v5 + 2) > *(v6 + 2) )
            {
              v8 = v5;
              v9 = v47;
              v10 = 2i64;
              do
              {
                v11 = v8[1];
                *v9 = *v8;
                v12 = v8[2];
                *(v9 + 1) = v11;
                v13 = v8[3];
                *(v9 + 2) = v12;
                v14 = v8[4];
                *(v9 + 3) = v13;
                v15 = v8[5];
                *(v9 + 4) = v14;
                v16 = v8[6];
                *(v9 + 5) = v15;
                v17 = v8[7];
                v8 += 8;
                *(v9 + 6) = v16;
                v9 += 128;
                *(v9 - 1) = v17;
                --v10;
              }
              while ( v10 );
              v18 = *v8;
              v19 = 2i64;
              v20 = v8[1];
              v21 = *(v8 + 4);
              *v9 = v18;
              *(v9 + 1) = v20;
              *(v9 + 4) = v21;
              v22 = v5;
              v23 = v6;
              do
              {
                v24 = v23[1];
                *v22 = *v23;
                v25 = v23[2];
                v22[1] = v24;
                v26 = v23[3];
                v22[2] = v25;
                v27 = v23[4];
                v22[3] = v26;
                v28 = v23[5];
                v22[4] = v27;
                v29 = v23[6];
                v22[5] = v28;
                v30 = v23[7];
                v23 += 8;
                v22[6] = v29;
                v22 += 8;
                *(v22 - 1) = v30;
                --v19;
              }
              while ( v19 );
              v31 = *v23;
              v32 = 2i64;
              v33 = v23[1];
              v34 = *(v23 + 4);
              *v22 = v31;
              v22[1] = v33;
              *(v22 + 4) = v34;
              v35 = v6;
              v36 = v47;
              do
              {
                v37 = *(v36 + 1);
                *v35 = *v36;
                v38 = *(v36 + 2);
                v35[1] = v37;
                v39 = *(v36 + 3);
                v35[2] = v38;
                v40 = *(v36 + 4);
                v35[3] = v39;
                v41 = *(v36 + 5);
                v35[4] = v40;
                v42 = *(v36 + 6);
                v35[5] = v41;
                v43 = *(v36 + 7);
                v36 += 128;
                v35[6] = v42;
                v35 += 8;
                *(v35 - 1) = v43;
                --v32;
              }
              while ( v32 );
              v44 = *v36;
              v45 = *(v36 + 1);
              v46 = *(v36 + 4);
              *v35 = v44;
              v35[1] = v45;
              *(v35 + 4) = v46;
            }
            v6 += 74;
            v5 += 74;
            --v7;
          }
          while ( v7 );
        }
        --v4;
      }
      while ( v4 );
    }
  }
}

//----- (000000014000A554) ----------------------------------------------------
unsigned int *__fastcall sub_14000A554(
        __int64 a1,
        unsigned __int8 (__fastcall *a2)(unsigned int *, __int64, __int64),
        __int64 a3,
        __int64 a4)
{
  unsigned int *v4; // rdi
  unsigned int *v9; // r10
  __int64 SystemInformation; // rax
  unsigned int v11; // edx

  v4 = 0i64;
  if ( a1 )
  {
    v9 = *a1;
    if ( *a1
      || (SystemInformation = EAC_NtQuerySystemInformation(0x10u, 0x80000u, 0x1000000u, 0i64),
          *(a1 + 8) = 0,
          v9 = SystemInformation,
          (*a1 = SystemInformation) != 0i64) )
    {
      v11 = *(a1 + 8);
      if ( v11 >= *v9 )
        goto LABEL_15;
      do
      {
        *(a1 + 8) = v11 + 1;
        v4 = &v9[4 * v11 + 2 + 2 * v11];
        if ( !a2 )
          break;
        if ( a2(v4, a3, a4) )
          break;
        v9 = *a1;
        v4 = 0i64;
        v11 = *(a1 + 8);
      }
      while ( v11 < **a1 );
      if ( !v4 )
      {
LABEL_15:
        if ( *a1 )
          Get_ExFreePool(*a1);
        *a1 = 0i64;
        *(a1 + 8) = 0;
      }
    }
  }
  return v4;
}

//----- (000000014000A628) ----------------------------------------------------
__int64 Get_System_Information()
{
  __int64 Memory; // rax MAPDST
  unsigned int Info; // [rsp+30h] [rbp+8h] BYREF

  Memory = 0i64;
  Info = 0;
  if ( Get_NtQuerySystemInformation(11u, &Info, 0, &Info) == 0xC0000004 )
  {
    if ( Info )
    {
      Memory = EAC_Allocate_Memory(Info);
      if ( Memory )
      {
        if ( Get_NtQuerySystemInformation(11u, Memory, Info, 0i64) < 0 )
        {
          Get_ExFreePool(Memory);
          return 0i64;
        }
      }
    }
  }
  return Memory;
}

//----- (000000014000AC40) ----------------------------------------------------
unsigned __int64 sub_14000AC40()
{
  return __readmsr(0x1Bu);
}

//----- (000000014000AD88) ----------------------------------------------------
char __fastcall sub_14000AD88(struct_eData_7 *eData)
{
  char ret; // bl
  _UNICODE_STRING *unicode_string; // rdi
  __int64 Length; // rax
  __int64 Memory; // rax
  char *Buffer; // rsi
  unsigned __int64 Length_1; // r14
  unsigned __int64 v7; // r9
  unsigned int v8; // edx
  unsigned __int64 v9; // r8
  char v10; // cl
  unsigned __int64 v11; // r8
  char v12; // r14
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rdi
  unsigned int v15; // edx
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // r9
  int v18; // ecx
  char v19; // cl
  int v21[5]; // [rsp+20h] [rbp-60h]
  __int16 v22; // [rsp+34h] [rbp-4Ch]
  _BYTE v23[22]; // [rsp+36h] [rbp-4Ah] BYREF
  int v24[6]; // [rsp+4Ch] [rbp-34h]
  __int16 v25; // [rsp+64h] [rbp-1Ch]
  _BYTE v26[26]; // [rsp+66h] [rbp-1Ah] BYREF

  ret = 0;
  if ( !eData )
    return 0;

  unicode_string = &eData->unicode_string;
  if ( eData == -16i64 )
    return 0;

  if ( !eData->qword18 )
    return 0;

  Length = unicode_string->Length;
  if ( !Length || !eData->word12 || Length > 0x200u )
    return 0;

  Memory = EAC_Allocate_Memory(Length + 2);
  Buffer = Memory;
  if ( Memory )
  {
    Length_1 = unicode_string->Length >> 1;
    if ( EAC_Compare_Unicode_Size_String(Memory, unicode_string->Length + 2i64, &unicode_string->Length) == Length_1 )
    {
      v21[0] = 0xB7F64D00;
      v22 = 0x6C0B;
      v21[1] = 0xA74B04E3;
      v7 = 0x14i64;
      v21[2] = 0x8CFFEDBF;
      v21[3] = 0xE1366817;
      v8 = 0xB7814D5C;
      v21[4] = 0x109D6A70;
      v9 = 0i64;
      memset(v23, 0, sizeof(v23));
      do
      {
        *&v23[v9 * 4] = v21[v9] ^ v8;
        ++v9;
        v8 = __ROL4__(((v8 ^ (v8 >> 7)) << 9) ^ v8 ^ (v8 >> 7) ^ ((((v8 ^ (v8 >> 7)) << 9) ^ v8 ^ (v8 >> 7)) >> 13), 4);
      }
      while ( v9 < 5 );
      do
      {
        v10 = v8;
        v8 >>= 8;
        v23[v7] = *(v21 + v7) ^ v10;
        ++v7;
      }
      while ( v7 < 0x16 );
      v11 = Length_1 + 1;
      v12 = 1;
      if ( !sub_14005D7E4(Buffer, v23, v11) )
      {
        v13 = unicode_string->Length;
        v25 = 190;
        v14 = 24i64;
        v24[0] = 0xA4A12850;
        v24[1] = 0xC0FB69B7;
        v15 = 0xA4F6280C;
        v24[2] = 0xC2338CDB;
        v16 = 0i64;
        v24[3] = 0x7BF8109E;
        v24[4] = 0x42BD8309;
        v24[5] = 0x7E3B1484;
        memset(v26, 0, sizeof(v26));
        v17 = v13 >> 1;
        do
        {
          v18 = v24[v16] ^ v15;
          v15 = __ROL4__(214013 * v15 + 2531011, 4);
          *&v26[v16 * 4] = v18;
          ++v16;
        }
        while ( v16 < 6 );
        do
        {
          v19 = v15;
          v15 >>= 8;
          v26[v14] = *(v24 + v14) ^ v19;
          ++v14;
        }
        while ( v14 < 0x1A );
        v12 = 3;
        if ( !sub_14005D7E4(Buffer, v26, v17 + 1) )
          goto LABEL_18;
      }
      ret = 1;
      if ( (v12 & 2) != 0 )
LABEL_18:
        memset(v26, 0, sizeof(v26));
      memset(v23, 0, sizeof(v23));
    }
    Get_ExFreePool(Buffer);
  }
  return ret;
}

//----- (000000014000B018) ----------------------------------------------------
char __fastcall sub_14000B018(__int64 Process, unsigned __int64 Address, unsigned __int64 RegionSize, int Length)
{
  char v8; // bl
  char ret; // bl
  struct_eData_2 eData; // [rsp+38h] [rbp-39h] BYREF
  __int128 v12; // [rsp+58h] [rbp-19h] BYREF
  __int128 v13; // [rsp+68h] [rbp-9h]
  __int128 v14; // [rsp+78h] [rbp+7h]
  _KAPC_STATE ApcState; // [rsp+88h] [rbp+17h] BYREF

  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  memset(&eData, 0, sizeof(eData));

  if ( Process )
  {
    if ( Address )
    {
      if ( Get_KeStackAttachProcess(Process, &ApcState) )
      {
        v8 = (loc_140053930)(-1i64, Address, 0i64, &v12, 48i64);
        (loc_140054154)(Process, &ApcState);    // KeUnstackDetachProcess

        if ( v8 )
        {
          if ( (Length & DWORD1(v14)) == 0 && RegionSize <= *(&v13 + 1) )
          {
            if ( (DWORD2(v14) & 0x1000000) != 0 )
            {
              if ( sub_140021E5C(Process, Address, &eData) )
              {
                ret = sub_14000AD88(&eData);
                sub_140021EE0(&eData);

                return ret;
              }
            }
            else if ( *(&v13 + 1) < 0x100000ui64 )
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (000000014000B114) ----------------------------------------------------
char __fastcall EAC_Allocate_ProcessVirtualMemory_2(__int64 Process, struct_eData *eData)
{
  char ret; // bl
  int Protect; // eax
  __int64 ZeroBits; // r8
  _KAPC_STATE ApcState; // [rsp+30h] [rbp-38h] BYREF
  __int64 BaseAddress; // [rsp+70h] [rbp+8h] BYREF
  __int64 RegionSize; // [rsp+80h] [rbp+18h] BYREF

  ret = 0;
  if ( !Process )
    return 0;

  if ( !eData )
    return 0;

  if ( !eData->RegionSize )
    return 0;

  if ( !eData->Type )
    return 0;

  Protect = eData->Protect;
  if ( !Protect || (Protect & 0xF0) != 0 || eData->BaseAddress )
    return 0;

  if ( Get_KeStackAttachProcess(Process, &ApcState) )
  {
    ZeroBits = eData->ZeroBits;
    BaseAddress = eData->BaseAddress;
    RegionSize = eData->RegionSize;
    if ( Get_NtAllocateVirtualMemory(-1i64, &BaseAddress, ZeroBits, &RegionSize, eData->Type, eData->Protect) >= 0 )
    {
      ret = 1;
      eData->BaseAddress = BaseAddress;
      eData->RegionSize = RegionSize;
    }
    (loc_140054154)(Process, &ApcState);        // KeUnstackDetachProcess
  }
  return ret;
}

//----- (000000014000B1F0) ----------------------------------------------------
char __fastcall sub_14000B1F0(__int64 Process, _QWORD *eData)
{
  char v4; // r15
  unsigned int BuildNumber; // eax
  int v6; // r9d
  char *Memory; // r14
  unsigned __int64 v8; // rbx
  char *v9; // rdi
  __int64 ProcessId; // rax

  v4 = 0;
  if ( !Process || !eData || !eData[1] || !eData[2] || !eData[3] )
    return 0;

  if ( KUSER_SHARED_DATA.NtMajorVersion != 10 || (BuildNumber = Get_BuildNumber(), v6 = 208, BuildNumber < 0x55F0) )
    v6 = 240;

  if ( !sub_14000B018(Process, eData[1], eData[2], v6) )
    return 0;

  sub_14001D338(eData[3], eData[2]);
  Memory = EAC_Allocate_Memory(eData[2]);
  if ( Memory )
  {
    v8 = eData[2];
    v9 = eData[1];
    ProcessId = Get_PsGetProcessId(Process);
    if ( sub_1400535D8(ProcessId, v9, Memory, v8) )
    {
      EAC_memcpy(eData[3], Memory, eData[2]);
      eData[4] = eData[2];
      v4 = 1;
    }
  }
  if ( Memory )
    Get_ExFreePool(Memory);

  return v4;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014000B330) ----------------------------------------------------
char __fastcall sub_14000B330(__int64 Process, _QWORD *aData)
{
  char ret; // r14
  unsigned __int64 Size; // r8
  unsigned __int64 Address; // rdx
  char *Memory; // rax
  char *Buffer; // r15
  unsigned __int64 Size_2; // rbx
  char *Address_2; // rdi
  __int64 ProcessId; // rax

  ret = 0;
  if ( !Process )
    return 0;

  if ( !aData )
    return 0;

  if ( !aData[1] )
    return 0;

  Size = aData[2];
  if ( !Size )
    return 0;

  Address = aData[3];
  if ( !Address || !sub_14000B018(Process, Address, Size, 240) )
    return 0;

  EAC_IsUsermodeValidAddress(aData[1], aData[2], 1);
  Memory = EAC_Allocate_Memory(aData[2]);
  Buffer = Memory;
  if ( Memory )
  {
    EAC_memcpy(Memory, aData[1], aData[2]);
    Size_2 = aData[2];
    Address_2 = aData[3];
    ProcessId = Get_PsGetProcessId(Process);
    if ( sub_140053690(ProcessId, Address_2, Buffer, Size_2) )
    {
      aData[4] = aData[2];
      ret = 1;
    }
  }
  if ( Buffer )
    Get_ExFreePool(Buffer);

  return ret;
}

//----- (000000014000B450) ----------------------------------------------------
char __fastcall sub_14000B450(__int64 Process, struct_eData_5 *eData)
{
  char ret; // bl
  unsigned __int64 BaseAddress; // rdx
  unsigned __int64 NumberOfBytes; // r8
  int NewProtection; // eax
  unsigned int NewAccessProtection; // r9d
  _KAPC_STATE ApcState; // [rsp+30h] [rbp-38h] BYREF
  __int64 BaseAddress_2; // [rsp+70h] [rbp+8h] BYREF
  __int64 NumberOfBytes_2; // [rsp+80h] [rbp+18h] BYREF

  ret = 0;
  if ( !Process )
    return 0;

  if ( !eData )
    return 0;

  BaseAddress = eData->BaseAddress;
  if ( !BaseAddress )
    return 0;

  NumberOfBytes = eData->NumberOfBytes;
  if ( !NumberOfBytes )
    return 0;

  NewProtection = eData->NewProtection;
  if ( !NewProtection || (NewProtection & 240) != 0 || !sub_14000B018(Process, BaseAddress, NumberOfBytes, 240) )
    return 0;

  if ( Get_KeStackAttachProcess(Process, &ApcState) )
  {
    NewAccessProtection = eData->NewProtection;
    BaseAddress_2 = eData->BaseAddress;
    NumberOfBytes_2 = eData->NumberOfBytes;
    if ( Get_ZwProtectVirtualMemory(-1i64, &BaseAddress_2, &NumberOfBytes_2, NewAccessProtection, &eData[1]) >= 0 )
    {
      ret = 1;
      eData->BaseAddress = BaseAddress_2;
      eData->NumberOfBytes = NumberOfBytes_2;
    }
    (loc_140054154)(Process, &ApcState);        // KeUnstackDetachProcess
  }
  return ret;
}

//----- (000000014000B53C) ----------------------------------------------------
char __fastcall sub_14000B53C(__int64 Process, struct_eData_8 *eData)
{
  char ret; // bl
  unsigned __int64 BaseAddress; // rdx
  unsigned int FreeType; // r9d
  _KAPC_STATE ApcState; // [rsp+20h] [rbp-38h] BYREF
  __int64 BaseAddress_2; // [rsp+60h] [rbp+8h] BYREF
  __int64 RegionSize; // [rsp+70h] [rbp+18h] BYREF

  ret = 0;
  if ( !Process )
    return 0;

  if ( !eData )
    return 0;

  BaseAddress = eData->BaseAddress;
  if ( !BaseAddress
    || ((eData->Type - 0x4000) & 0xFFFFBFFF) != 0
    || !sub_14000B018(Process, BaseAddress, eData->RegionSize, 240) )
  {
    return 0;
  }

  if ( Get_KeStackAttachProcess(Process, &ApcState) )
  {
    FreeType = eData->Type;
    BaseAddress_2 = eData->BaseAddress;
    RegionSize = eData->RegionSize;
    if ( Get_NtFreeVirtualMemory(-1i64, &BaseAddress_2, &RegionSize, FreeType) >= 0 )
    {
      ret = 1;
      eData->BaseAddress = BaseAddress_2;
      eData->RegionSize = RegionSize;
    }
    (loc_140054154)(Process, &ApcState);        // KeUnstackDetachProcess
  }
  return ret;
}
// 14000B53C: using guessed type _KAPC_STATE ApcState;

//----- (000000014000B60C) ----------------------------------------------------
char __fastcall EAC_NtFlushVirtualMemory(__int64 Process, struct_eData_4 *eData)
{
  char ret; // bl
  unsigned __int64 BaseAddress; // rdx
  __int64 Handle; // rcx
  _IO_STATUS_BLOCK IoStatus; // [rsp+20h] [rbp-40h] BYREF
  _KAPC_STATE ApcState; // [rsp+30h] [rbp-30h] BYREF
  __int64 BaseAddress_2; // [rsp+80h] [rbp+20h] BYREF
  __int64 RegionSize; // [rsp+90h] [rbp+30h] BYREF

  ret = 0;
  IoStatus = 0i64;
  if ( !Process )
    return 0;

  if ( !eData )
    return 0;

  BaseAddress = eData->BaseAddress;
  if ( !BaseAddress || !sub_14000B018(Process, BaseAddress, eData->RegionSize, 240) )
    return 0;

  if ( Get_KeStackAttachProcess(Process, &ApcState) )
  {
    BaseAddress_2 = eData->BaseAddress;
    RegionSize = eData->RegionSize;
    if ( Get_NtFlushVirtualMemory(Handle, &BaseAddress_2, &RegionSize, &IoStatus) >= 0 )
    {
      ret = 1;
      eData->BaseAddress = BaseAddress_2;
      eData->RegionSize = RegionSize;
      eData->Status = IoStatus.Status;
      eData->Information = IoStatus.Information;
    }
    (loc_140054154)(Process, &ApcState);        // KeUnstackDetachProcess
  }
  return ret;
}
// 14000B684: variable 'Handle' is possibly undefined

//----- (000000014000B6D0) ----------------------------------------------------
void __fastcall sub_14000B6D0(void **aData, struct_a2 *gData, _DWORD *OutLenght)
{
  __int64 *v3; // rsi
  struct_eData *eData; // rdi
  char *Buffer; // r13
  unsigned __int64 Lenght; // r14
  struct_eData *Memory; // rax
  __int64 CurrentProcess; // rax
  __int64 Process; // r12
  bool v10; // r15
  __int64 v11; // rcx
  bool v12; // zf
  char ProcessVirtualMemory_2; // al
  _KAPC_STATE ApcState[2]; // [rsp+48h] [rbp-60h] BYREF
  __int64 Length; // [rsp+C8h] [rbp+20h] BYREF

  v3 = 0i64;
  eData = 0i64;

  Buffer = gData->Buffer;
  if ( !Buffer )
    goto LABEL_49;

  Lenght = gData->Lenght;
  if ( Lenght <= 8 )
    goto LABEL_49;

  if ( aData[14] != Buffer )
    goto LABEL_49;

  if ( gData->Size != Lenght )
    goto LABEL_49;

  EAC_IsUsermodeValidAddress(Buffer, Lenght, 1);
  Memory = EAC_Allocate_Memory(Lenght);
  eData = Memory;

  if ( !Memory )
    goto LABEL_49;

  EAC_memcpy(Memory, Buffer, Lenght);
  v3 = sub_14000D7E8(*&eData->Array[4]);

  if ( !v3 )
    goto LABEL_49;

  CurrentProcess = Get_PsGetCurrentProcess();
  if ( !(loc_140040F28)(CurrentProcess) )
    goto LABEL_49;

  if ( *eData->Array == 1 )
  {
    if ( Lenght != 40 )
      goto LABEL_49;

    ProcessVirtualMemory_2 = EAC_Allocate_ProcessVirtualMemory_2(v3[1], eData);
  }
  else if ( *eData->Array == 2 )
  {
    if ( Lenght != 40 )
      goto LABEL_49;
    ProcessVirtualMemory_2 = sub_14000B1F0(v3[1], eData);
  }
  else if ( *eData->Array == 3 )
  {
    if ( Lenght != 40 )
      goto LABEL_49;

    ProcessVirtualMemory_2 = sub_14000B330(v3[1], eData);
  }
  else if ( *eData->Array == 4 )
  {
    if ( Lenght != 32 )
      goto LABEL_49;
    ProcessVirtualMemory_2 = sub_14000B450(v3[1], eData);
  }
  else if ( *eData->Array == 5 )
  {
    if ( Lenght != 28 )
      goto LABEL_49;
    ProcessVirtualMemory_2 = sub_14000B53C(v3[1], eData);
  }
  else
  {
    if ( *eData->Array != 6 )
    {
      if ( *eData->Array == 7 )
      {
        if ( Lenght != 36 )
          goto LABEL_49;

        Process = v3[1];
        v10 = 0;
        Length = 0i64;

        if ( !Process )
          goto LABEL_25;

        if ( !eData->BaseAddress || !*(&eData->ZeroBits + 4) || !HIDWORD(eData->RegionSize) )
          goto LABEL_49;

        if ( !Get_KeStackAttachProcess(Process, ApcState) )
          goto LABEL_25;

        if ( Get_ZwQueryVirtualMemory(
               -1i64,
               eData->BaseAddress,
               eData->ZeroBits,
               *(&eData->ZeroBits + 4),
               HIDWORD(eData->RegionSize),
               &Length) >= 0 )
        {
          eData->Type = Length;
          v10 = 1;
        }
      }
      else
      {
        if ( *eData->Array != 8 || Lenght != 36 )
          goto LABEL_49;
        Process = v3[1];
        v10 = 0;
        if ( !Process )
          goto LABEL_25;

        if ( !*(&eData->BaseAddress + 4) || !HIDWORD(eData->ZeroBits) || !eData->RegionSize || eData->Type )
          goto LABEL_49;

        if ( !Get_KeStackAttachProcess(Process, ApcState) )
          goto LABEL_25;

        v10 = sub_140058F40(
                v11,
                eData->BaseAddress,
                HIDWORD(eData->ZeroBits),
                *(&eData->BaseAddress + 4),
                eData->RegionSize,
                eData->Type) >= 0;
      }
      (loc_140054154)(Process, ApcState);       // KeUnstackDetachProcess
LABEL_25:
      v12 = !v10;
      goto LABEL_47;
    }
    if ( Lenght != 0x24 )
      goto LABEL_49;

    ProcessVirtualMemory_2 = EAC_NtFlushVirtualMemory(v3[1], eData);
  }
  v12 = ProcessVirtualMemory_2 == 0;
LABEL_47:
  if ( !v12 )
  {
    EAC_memcpy(Buffer, eData->Array, Lenght);
    *OutLenght = Lenght;
  }
LABEL_49:
  if ( eData )
    Get_ExFreePool(eData);

  if ( v3 )
    sub_14000D924(v3);
}
// 14000B845: variable 'v11' is possibly undefined

//----- (000000014000C7A4) ----------------------------------------------------
__int64 __fastcall sub_14000C7A4(__int64 a1)
{
  signed __int32 v2; // ecx
  __int64 result; // rax
  unsigned int i; // esi

  v2 = _InterlockedIncrement(a1);
  while ( *a1 < 2 )
    _mm_pause();
  if ( v2 == 1 )
  {
    *(a1 + 16) = -1i64;
    if ( !*(a1 + 40) || (result = (*(a1 + 40))(*(a1 + 32)), result) )
    {
      result = *(a1 + 48);
      for ( i = 0; i < result; result = *(a1 + 48) )
      {
        (*(a1 + 24))(a1 + 8, *(a1 + 32));
        if ( *(a1 + 12) < *(a1 + 16) )
          *(a1 + 16) = *(a1 + 12);
        ++i;
        _InterlockedExchange((a1 + 12), 0);
      }
    }
    _InterlockedExchange((a1 + 4), 1);
  }
  else
  {
    result = *(a1 + 4);
    if ( v2 == 2 )
    {
      while ( !result )
      {
        if ( *(a1 + 8) )
          ++*(a1 + 12);
        result = *(a1 + 4);
      }
    }
    else
    {
      while ( !result )
      {
        _mm_pause();
        result = *(a1 + 4);
      }
    }
  }
  return result;
}

//----- (000000014000C9A8) ----------------------------------------------------
__int64 sub_14000C9A8()
{
  __int64 v0; // rax
  __int64 v1; // r8
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // rax
  __int64 v13; // r8
  __int64 v14; // rax
  __int64 v15; // r8
  unsigned int v16; // eax
  int v17; // r11d
  __int64 result; // rax
  int v19; // [rsp+20h] [rbp-20h] BYREF
  int v20; // [rsp+24h] [rbp-1Ch]
  int v21; // [rsp+28h] [rbp-18h]
  int v22; // [rsp+2Ch] [rbp-14h]
  int v23; // [rsp+30h] [rbp-10h]

  dword_1400834E0 = sub_14003EEF8();
  v19 = 0xD9435C2C;
  v20 = -618317991;
  v21 = -1597871232;
  v22 = -621869918;
  v23 = 1192654555;
  v0 = (loc_14003CB4C)(&v19);
  LOBYTE(v1) = 1;
  qword_1400834E8 = (loc_14005B768)(v0, &qword_1400834E8, v1);
  v19 = -1453917108;
  v20 = 2068318229;
  v21 = -676559934;
  v22 = 1540748658;
  v23 = -1629252619;
  v2 = (loc_14003CB4C)(&v19);
  LOBYTE(v3) = 1;
  qword_1400834F0 = (loc_14005B768)(v2, &qword_1400834F0, v3);
  v19 = -458481415;
  v20 = -879661535;
  v21 = 1121702357;
  v22 = -872839378;
  v23 = 1904292720;
  v4 = (loc_14003CB4C)(&v19);
  LOBYTE(v5) = 1;
  qword_1400834F8 = (loc_14005B768)(v4, &qword_1400834F8, v5);
  v19 = -1536210223;
  v20 = 1348480303;
  v21 = 1749206712;
  v22 = -614105637;
  v23 = -956282197;
  v6 = (loc_14003CB4C)(&v19);
  LOBYTE(v7) = 1;
  qword_140083500 = (loc_14005B768)(v6, &qword_140083500, v7);
  v19 = 1655754949;
  v20 = 1541785875;
  v21 = -1439837914;
  v22 = 1837542667;
  v23 = 1911465711;
  v8 = (loc_14003CB4C)(&v19);
  LOBYTE(v9) = 1;
  qword_140083508 = (loc_14005B768)(v8, &qword_140083508, v9);
  v19 = 0xCDBF934E;
  v20 = 0xF6671E18;
  v21 = 0x5FDC8E7F;
  v22 = 0xDA5B3B3D;
  v23 = 0xB65E39F7;
  v10 = (loc_14003CB4C)(&v19);
  LOBYTE(v11) = 1;
  qword_140083510 = (loc_14005B768)(v10, &qword_140083510, v11);
  v19 = 511620542;
  v20 = 731681335;
  v21 = -2137519323;
  v22 = -846270271;
  v23 = 2006534252;
  v12 = (loc_14003CB4C)(&v19);
  LOBYTE(v13) = 1;
  qword_140083518 = (loc_14005B768)(v12, &qword_140083518, v13);
  v19 = -1099642545;
  v20 = 17807312;
  v21 = 1442918475;
  v22 = -1266308005;
  v23 = -2121540871;
  v14 = (loc_14003CB4C)(&v19);
  LOBYTE(v15) = 1;
  qword_140083520 = (loc_14005B768)(v14, &qword_140083520, v15);
  v16 = EAC_HashCR32(&dword_1400834E0, 0x48u);
  result = -2066984824 * (v17 ^ v16);
  dword_140083528 = result;
  return result;
}
// 14000C9F5: variable 'v1' is possibly undefined
// 14000CA3A: variable 'v3' is possibly undefined
// 14000CA7F: variable 'v5' is possibly undefined
// 14000CAC4: variable 'v7' is possibly undefined
// 14000CB09: variable 'v9' is possibly undefined
// 14000CB4E: variable 'v11' is possibly undefined
// 14000CB93: variable 'v13' is possibly undefined
// 14000CBD8: variable 'v15' is possibly undefined
// 14000CBF8: variable 'v17' is possibly undefined
// 1400834E0: using guessed type int dword_1400834E0;
// 1400834E8: using guessed type __int64 qword_1400834E8;
// 1400834F0: using guessed type __int64 qword_1400834F0;
// 1400834F8: using guessed type __int64 qword_1400834F8;
// 140083500: using guessed type __int64 qword_140083500;
// 140083508: using guessed type __int64 qword_140083508;
// 140083510: using guessed type __int64 qword_140083510;
// 140083518: using guessed type __int64 qword_140083518;
// 140083520: using guessed type __int64 qword_140083520;
// 140083528: using guessed type int dword_140083528;

//----- (000000014000CC54) ----------------------------------------------------
__int64 __fastcall Get_IoEnumerateDeviceObjectList(
        __int64 Object,
        __int64 DeviceObjectList,
        unsigned int DeviceObjectListSize,
        __int64 ActualNumberDeviceObjects)
{
  __int64 (__fastcall *g_IoEnumerateDeviceObjectList)(__int64, __int64, _QWORD, __int64); // rax

  g_IoEnumerateDeviceObjectList = (loc_14005B768)(qword_140083500, &qword_140083500, 0i64);
  if ( g_IoEnumerateDeviceObjectList )
    return g_IoEnumerateDeviceObjectList(Object, DeviceObjectList, DeviceObjectListSize, ActualNumberDeviceObjects);// IoEnumerateDeviceObjectList
  else
    return 0xC0000002i64;
}
// 140083500: using guessed type __int64 qword_140083500;

//----- (000000014000CCBC) ----------------------------------------------------
__int64 __fastcall sub_14000CCBC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall *v7)(__int64, __int64, __int64, __int64); // rax

  v7 = (loc_14005B768)(qword_140083510, &qword_140083510, 0i64);
  if ( v7 )
    return v7(a1, 1i64, a3, a4);
  else
    return 0xC0000002i64;
}
// 140083510: using guessed type __int64 qword_140083510;

//----- (000000014000CE6C) ----------------------------------------------------
void __fastcall sub_14000CE6C(__int64 a1)
{
  EAC_memset(a1, 0, 0x48ui64);
  *(a1 + 0x18) = 0i64;
  *(a1 + 0x20) = 0;
  *(a1 + 0x10) = 1;
  *(a1 + 0xC) = 0x8042DD12;
  KeInitializeEvent((a1 + 0x28), SynchronizationEvent, 0);
}

//----- (000000014000D0AC) ----------------------------------------------------
char __fastcall sub_14000D0AC(__int64 unicode_string, _DWORD *a2)
{
  char ret; // bl
  char v5; // si
  unsigned __int64 v6; // rdi
  unsigned int v7; // edx
  unsigned __int64 v8; // r8
  char v9; // cl
  int v10; // eax
  char v11; // dl
  int v12; // r14d
  char Read_File; // di
  unsigned __int64 v15; // r15
  __int64 v16; // rax
  unsigned __int8 *v17; // rdi
  unsigned int i; // r8d
  int v19; // eax
  UNICODE_STRING *ObjectName; // [rsp+60h] [rbp-A0h] BYREF
  __int64 Memory; // [rsp+68h] [rbp-98h]
  int v23[2]; // [rsp+70h] [rbp-90h] BYREF
  __int16 v24; // [rsp+78h] [rbp-88h]
  _BYTE string[10]; // [rsp+7Ah] [rbp-86h] BYREF
  _BYTE *v26; // [rsp+88h] [rbp-78h]
  __int64 Buffer; // [rsp+90h] [rbp-70h] MAPDST BYREF
  int *v28; // [rsp+98h] [rbp-68h]
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+A0h] [rbp-60h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes_1; // [rsp+D0h] [rbp-30h] BYREF
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+100h] [rbp+0h] BYREF
  struct _FILE_NETWORK_OPEN_INFORMATION FileInformation; // [rsp+110h] [rbp+10h] BYREF
  int *Size; // [rsp+190h] [rbp+90h] BYREF
  _BYTE gameid[7]; // [rsp+1A0h] [rbp+A0h] BYREF
  void *FileHandle; // [rsp+1A8h] [rbp+A8h] BYREF

  ret = 0;
  LODWORD(Size) = 0;
  v5 = 0;
  if ( !unicode_string || !*(unicode_string + 8) || !*unicode_string || !*(unicode_string + 2) || !a2 )
    return 0;
  *a2 = 0;
  Memory = EAC_Allocate_Memory(0x200ui64);
  if ( Memory )
  {
    LODWORD(ObjectName) = 0x2000000;
    if ( sub_14005D620(&ObjectName, unicode_string) < 0 )
      goto LABEL_13;

    v23[0] = 445283981;
    v24 = -17322;
    v6 = 8i64;
    v23[1] = 1342414608;
    memset(string, 0, sizeof(string));
    v7 = 451903139;
    v8 = 0i64;
    v28 = v23;
    v26 = string;
    do
    {
      *&v26[v8 * 4] = v28[v8] ^ v7;
      ++v8;
      v7 = ~(((v7 ^ (v7 >> 7)) << 9) ^ v7 ^ (v7 >> 7) ^ ((((v7 ^ (v7 >> 7)) << 9) ^ v7 ^ (v7 >> 7)) >> 13));
    }
    while ( v8 < 2 );
    Size = v23;
    v26 = string;
    do
    {
      v9 = v7;
      v7 >>= 8;
      v26[v6] = *(Size + v6) ^ v9;
      ++v6;
    }
    while ( v6 < 0xA );
    v5 = 1;
    v10 = sub_14005D584(&ObjectName, string);
    v11 = 1;
    if ( v10 < 0 )
LABEL_13:
      v11 = 0;
    if ( (v5 & 1) != 0 )
      memset(string, 0, sizeof(string));

    if ( v11 )
    {
      if ( Memory )
      {
        if ( ObjectName )
        {
          if ( WORD1(ObjectName) )
          {
            if ( !KeGetCurrentIrql() && !Get_KeAreAllApcsDisabled() )
            {
              ObjectAttributes.RootDirectory = 0i64;
              ObjectAttributes.ObjectName = &ObjectName;
              ObjectAttributes.Length = 48;
              ObjectAttributes.Attributes = 576;
              *&ObjectAttributes.SecurityDescriptor = 0i64;
              if ( ZwQueryFullAttributesFile(&ObjectAttributes, &FileInformation) >= 0 )
              {
                v12 = 0;
                qmemcpy(gameid, "gameid=", sizeof(gameid));
                if ( Memory )
                {
                  if ( ObjectName )
                  {
                    if ( WORD1(ObjectName) )
                    {
                      Buffer = 0i64;
                      LODWORD(Size) = 0;
                      if ( !KeGetCurrentIrql() && !Get_KeAreAllApcsDisabled() )
                      {
                        ObjectAttributes_1.Length = 48;
                        ObjectAttributes_1.RootDirectory = 0i64;
                        ObjectAttributes_1.Attributes = 576;
                        ObjectAttributes_1.ObjectName = &ObjectName;
                        *&ObjectAttributes_1.SecurityDescriptor = 0i64;
                        if ( ZwCreateFile(
                               &FileHandle,
                               0x120089u,
                               &ObjectAttributes_1,
                               &IoStatusBlock,
                               0i64,
                               0x80u,
                               7u,
                               1u,
                               0x20u,
                               0i64,
                               0) >= 0 )
                        {
                          Read_File = ReadFile(FileHandle, &Buffer, &Size);
                          ZwClose(FileHandle);
                          if ( Read_File )
                          {
                            v15 = Buffer + Size;
                            v16 = (loc_1400327F4)(Buffer, Size, gameid, 7i64);
                            if ( v16 )
                            {
                              v17 = (v16 + 7);
                              for ( i = 0; i < 4; ++i )
                              {
                                if ( v17 >= v15 )
                                  break;
                                v19 = *v17;
                                if ( (v19 - 48) > 9u )
                                  break;
                                ++v17;
                                v12 = v19 + 2 * (5 * v12 - 24);
                              }
                            }
                            if ( Buffer )
                              Get_ExFreePool(Buffer);
                          }
                        }
                      }
                    }
                  }
                }
                *a2 = v12;
                ret = 1;
              }
            }
          }
        }
      }
    }
    Get_ExFreePool(Memory);
  }
  return ret;
}

//----- (000000014000D414) ----------------------------------------------------
__int64 __fastcall sub_14000D414(__int64 a1)
{
  __int64 v2; // r8
  _QWORD *v3; // rdx
  void *v4; // rcx
  __int64 v5; // rcx
  struct _FAST_MUTEX *v6; // rcx
  struct _FAST_MUTEX *v7; // rcx
  __int64 *v8; // rbx
  __int64 v9; // rcx

  v2 = *(a1 + 608);
  v3 = *(a1 + 616);
  if ( *(v2 + 8) != a1 + 608 || *v3 != a1 + 608 )
    __fastfail(3u);
  *v3 = v2;
  *(v2 + 8) = v3;
  if ( a1 )
  {
    v4 = *(a1 + 8);
    if ( v4 )
      ObfDereferenceObject(v4);
    if ( *(a1 + 72) )
    {
      EAC_Free_UnicodeString((a1 + 64));
      *(a1 + 80) = 0i64;
    }
    v5 = _InterlockedExchange64((a1 + 232), 0i64);
    if ( v5 )
      Get_ExFreePool(v5);
    v6 = _InterlockedExchange64((a1 + 512), 0i64);
    if ( v6 )
      sub_140023184(v6);
    v7 = _InterlockedExchange64((a1 + 520), 0i64);
    if ( v7 )
      sub_140023184(v7);
    v8 = _InterlockedExchange64((a1 + 528), 0i64);
    if ( v8 )
    {
      if ( *v8 )
        Get_ExFreePool(*v8);
      Get_ExFreePool(v8);
    }
    v9 = _InterlockedExchange64((a1 + 176), 0i64);
    if ( v9 )
      Get_ExFreePool(v9);
    if ( *(a1 + 552) )
    {
      EAC_Free_UnicodeString((a1 + 544));
      *(a1 + 544) = 0i64;
    }
  }
  return Get_ExFreePool(a1);
}

//----- (000000014000D518) ----------------------------------------------------
__int64 *EAC_KeInitializeEvent()
{
  __int64 *result; // rax

  result = _InterlockedCompareExchange(&dword_140083578, 1, 0);
  if ( !result )
  {
    stru_140083540.Owner = 0i64;
    stru_140083540.Contention = 0;
    stru_140083540.Count = 1;
    KeInitializeEvent(&stru_140083540.Event, SynchronizationEvent, 0);
    result = &qword_140083530;
    qword_140083538 = &qword_140083530;
    qword_140083530 = &qword_140083530;
  }
  return result;
}
// 140083530: using guessed type __int64 qword_140083530;
// 140083538: using guessed type __int64 qword_140083538;
// 140083578: using guessed type int dword_140083578;

//----- (000000014000D7E8) ----------------------------------------------------
__int64 *__fastcall sub_14000D7E8(__int64 ProcessId)
{
  __int64 *i; // rax
  __int64 *ret; // rbx

  if ( !dword_140083578 || !ProcessId || KeGetCurrentIrql() > 1u )
    return 0i64;

  ExAcquireFastMutex(&stru_140083540);
  for ( i = qword_140083530; ; i = *i )
  {
    if ( i == &qword_140083530 )
      goto LABEL_8;

    ret = i - 76;
    if ( *(i - 74) == ProcessId )
      break;
  }
  if ( i == 608 || *(ret + 604) )
  {
LABEL_8:
    ret = 0i64;
    goto LABEL_9;
  }
  ++*(ret + 0x96);
LABEL_9:
  ExReleaseFastMutex(&stru_140083540);
  return ret;
}
// 140083530: using guessed type __int64 qword_140083530;
// 140083578: using guessed type int dword_140083578;

//----- (000000014000D878) ----------------------------------------------------
__int64 *__fastcall sub_14000D878(__int64 a1)
{
  __int64 ProcessId; // rax

  ProcessId = Get_PsGetProcessId(a1);
  return sub_14000D7E8(ProcessId);
}

//----- (000000014000D890) ----------------------------------------------------
__int64 *__fastcall sub_14000D890(__int64 a1)
{
  __int64 *v1; // rdi
  __int64 *v3; // rax

  v1 = 0i64;
  if ( !dword_140083578 || KeGetCurrentIrql() > 1u )
    return 0i64;
  ExAcquireFastMutex(&stru_140083540);
  if ( a1 )
    v3 = *(a1 + 608);
  else
    v3 = qword_140083530;
  while ( v3 != &qword_140083530 )
  {
    if ( !*(v3 - 4) )
    {
      ++*(v3 - 2);
      v1 = v3 - 76;
      break;
    }
    v3 = *v3;
  }
  ExReleaseFastMutex(&stru_140083540);
  if ( a1 )
    sub_14000D924(a1);
  return v1;
}
// 140083530: using guessed type __int64 qword_140083530;
// 140083578: using guessed type int dword_140083578;

//----- (000000014000D924) ----------------------------------------------------
void __fastcall sub_14000D924(__int64 a1)
{
  __int64 v2; // rdx
  __int64 *i; // rax
  __int64 v4; // rcx
  int v5; // eax
  bool v6; // zf

  if ( dword_140083578 && a1 && KeGetCurrentIrql() <= 1u )
  {
    ExAcquireFastMutex(&stru_140083540);
    v2 = *(a1 + 0x10);
    if ( v2 )
    {
      for ( i = qword_140083530; i != &qword_140083530; i = *i )
      {
        v4 = (i + 0xFFFFFFB4);
        if ( i[0xFFFFFFB6i64] == v2 )
        {
          if ( i != 0x260 )
          {
            v5 = *(v4 + 0x258) - 1;
            v6 = *(v4 + 0x25C) == 0;
            *(v4 + 0x258) = v5;
            if ( !v6 && !v5 )
              sub_14000D414(v4);
          }
          break;
        }
      }
    }
    ExReleaseFastMutex(&stru_140083540);
  }
}
// 140083530: using guessed type __int64 qword_140083530;
// 140083578: using guessed type int dword_140083578;

//----- (000000014000F8A0) ----------------------------------------------------
char __fastcall sub_14000F8A0(__int64 a1, _UNICODE_STRING *unicode_string, unsigned int *a3)
{
  if ( !unicode_string || !a3 )
    return 0;

  if ( (loc_14000F0A4)(*a3, unicode_string, *(a3 + 1)) == 1 )
  {
    *(a3 + 0x10) = 1;
    return 0;
  }
  return 1;
}

//----- (000000014000F8D4) ----------------------------------------------------
// from @Swiftik
char __fastcall EAC_HWID_GetMacAddress(__int64 a1, void *a2)
{
  char ret; // bl
  unsigned int v4; // [rsp+20h] [rbp-28h] BYREF
  void *v5; // [rsp+28h] [rbp-20h]
  char v6; // [rsp+30h] [rbp-18h]

  ret = 0;
  v4 = a1;
  v5 = a2;
  v6 = 0;
  if ( !a2 || a1 != 6 )
    return 0;
  if ( EAC_GetFirstNetworkDeviceMacAddress(a1, a2, &v4) )
  {
    if ( v6 )
      return 1;
  }
  return ret;
}

//----- (000000014000F914) ----------------------------------------------------
char __fastcall sub_14000F914(_BYTE *a1)
{
  char v1; // bl
  __int64 (__fastcall *v3)(_QWORD); // rax
  int v5; // [rsp+20h] [rbp-20h] BYREF
  int v6; // [rsp+24h] [rbp-1Ch]
  int v7; // [rsp+28h] [rbp-18h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]

  v1 = 0;
  if ( a1 )
  {
    if ( KUSER_SHARED_DATA.NtMajorVersion >= 6
      && (KUSER_SHARED_DATA.NtMajorVersion != 6 || KUSER_SHARED_DATA.NtMinorVersion) )
    {
      return v1;
    }
    v3 = qword_140083580;
    if ( qword_140083580
      || (v5 = -975104906,
          v6 = 1840018214,
          v7 = 1190601861,
          v8 = 421588080,
          v9 = 1801276242,
          v3 = (loc_14003CB4C)(&v5),
          (qword_140083580 = v3) != 0) )
    {
      if ( qword_140083588 )
      {
LABEL_10:
        *a1 = v3(0i64);
        return 1;
      }
      v5 = 185684293;
      v6 = 384506604;
      v7 = -250882617;
      v8 = 540373460;
      v9 = 1333217803;
      qword_140083588 = (loc_14003CB4C)(&v5);
      if ( qword_140083588 )
      {
        v3 = qword_140083580;
        goto LABEL_10;
      }
    }
  }
  return 0;
}
// 140083580: using guessed type __int64 qword_140083580;
// 140083588: using guessed type __int64 qword_140083588;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014000FA04) ----------------------------------------------------
char __fastcall sub_14000FA04(ULONG64 BaseModule, char a2)
{
  __int64 ret; // rax
  int v5; // r14d
  ULONG64 v6; // r12
  char *BaseAddress; // r15
  int *Buffer; // rsi
  __int64 Size; // rbx
  __int64 v10; // rcx
  __int64 v11; // rbx
  __int64 i; // rbx
  __int64 v13; // rdi
  int v15; // [rsp+24h] [rbp-54h] BYREF
  char v16; // [rsp+28h] [rbp-50h]
  int v17; // [rsp+2Ch] [rbp-4Ch] BYREF
  __int16 v18; // [rsp+30h] [rbp-48h]
  int v19; // [rsp+34h] [rbp-44h] BYREF
  __int16 v20; // [rsp+38h] [rbp-40h]
  int v21[14]; // [rsp+40h] [rbp-38h]
  void *retaddr; // [rsp+78h] [rbp+0h] BYREF
  unsigned int OldProtection; // [rsp+90h] [rbp+18h] BYREF
  int v24; // [rsp+98h] [rbp+20h] BYREF

  ret = &retaddr;
  v21[0] = 9;
  v21[1] = 13;
  v15 = 214089779;
  v16 = 0;
  v19 = -1035943885;
  v20 = 12;
  v24 = -1010814136;
  v17 = -4181176;
  v18 = -15424;
  if ( BaseModule )
  {
    LODWORD(ret) = Check_Module_Architecture(BaseModule);
    v5 = ret;
    if ( ret )
    {
      v6 = BaseModule + *(BaseModule + 0x3C);
      BaseAddress = EAC_Get_AddressOfEntryPoint(BaseModule);
      if ( BaseAddress )
      {
        if ( v5 == 64 )
        {
          Buffer = &v17;
          if ( !a2 )
            Buffer = &v24;
          Size = a2 != 0 ? 6i64 : 4i64;
        }
        else
        {
          Buffer = &v19;
          if ( !a2 )
            Buffer = &v15;
          Size = (a2 != 0) + 5i64;
        }
        if ( Get_ZwProtectVirtualMemory_2(BaseAddress, Size, 0x40u, &OldProtection) )
        {
          sub_14001D338(BaseAddress, Size);
          EAC_memcpy(BaseAddress, Buffer, Size);
          Get_ZwProtectVirtualMemory_2(BaseAddress, Size, OldProtection, &OldProtection);
        }
      }

      ret = 0x80i64;
      if ( v5 == 64 )
        ret = 0x90i64;

      if ( *(ret + v6 + 4) )
      {
        v10 = *(ret + v6);
        if ( v10 )
        {
          v11 = BaseModule + v10;
          LOBYTE(ret) = Get_ZwProtectVirtualMemory_2(BaseModule + v10, 20i64, 0x40u, &OldProtection);
          if ( ret )
          {
            sub_14001D338(v11, 20i64);
            *v11 = 0i64;
            *(v11 + 16) = 0;
            LOBYTE(ret) = Get_ZwProtectVirtualMemory_2(v11, 20i64, OldProtection, &OldProtection);
          }
        }
      }
      for ( i = 0i64; i < 2; i = (i + 1) )
      {
        ret = 120i64;
        if ( v5 == 64 )
          ret = 136i64;
        v13 = ret + v6 + 8i64 * v21[i];
        if ( *(v13 + 4) && *v13 )
        {
          LOBYTE(ret) = Get_ZwProtectVirtualMemory_2(ret + v6 + 8i64 * v21[i], 8i64, 0x40u, &OldProtection);
          if ( ret )
          {
            sub_14001D338(v13, 8i64);
            *(v13 + 4) = 0;
            *v13 = 0;
            LOBYTE(ret) = Get_ZwProtectVirtualMemory_2(v13, 8i64, OldProtection, &OldProtection);
          }
        }
      }
    }
  }
  return ret;
}
// 14000FA04: using guessed type int var_38[14];

//----- (000000014000FC28) ----------------------------------------------------
__int64 __fastcall sub_14000FC28(__int64 a1)
{
  return sub_14000FA04(a1, 0i64);
}
// 14000FA04: using guessed type __int64 __fastcall sub_14000FA04(_QWORD, _QWORD);

//----- (000000014000FC30) ----------------------------------------------------
void __fastcall sub_14000FC30(__int64 Argument2)
{
  HANDLE CurrentThreadId; // rax

  if ( Argument2 )
  {
    CurrentThreadId = PsGetCurrentThreadId();
    Detect_QueueApc(CurrentThreadId, sub_14000FC28, Argument2, 0, 0);
  }
}

//----- (000000014000FC64) ----------------------------------------------------
char __fastcall sub_14000FC64(void *ThreadId)
{
  char ret; // bl
  __int64 Argument2; // r13
  char *v4; // rsi
  int v5; // eax
  __int64 Process; // rsi
  int ProcessWow64Process; // eax
  unsigned __int64 Size; // r15
  char v9; // r14
  __int64 ModuleName; // rax
  __int64 ProcessHandle; // rcx
  __int64 User_Module; // rdi
  __int64 unknown; // r8
  _BYTE *string_Size; // rax
  char Flag; // dl
  char *VirtualMemory; // rax
  char *Buffer; // rdi
  int v19[5]; // [rsp+38h] [rbp-C0h] BYREF
  __m128i unicode_string; // [rsp+4Ch] [rbp-ACh] BYREF
  __int16 v21; // [rsp+5Ch] [rbp-9Ch]
  __int64 v22; // [rsp+60h] [rbp-98h]
  char string[18]; // [rsp+68h] [rbp-90h] BYREF
  char v24[22]; // [rsp+7Ah] [rbp-7Eh] BYREF
  _KAPC_STATE ApcState[2]; // [rsp+90h] [rbp-68h] BYREF
  char *Data; // [rsp+100h] [rbp+8h]
  PVOID Object; // [rsp+110h] [rbp+18h] BYREF

  ret = 0;
  Argument2 = 0i64;
  if ( ThreadId && Get_PsLookupThreadByThreadId(ThreadId, &Object) >= 0 )
  {
    v4 = Object;
    v5 = sub_140035F88();
    if ( v4 && v5 )
      Process = *&v4[v5];
    else
      Process = 0i64;
    if ( Process )
    {
      ProcessWow64Process = Get_PsGetProcessWow64Process(Process);
      if ( ProcessWow64Process )
      {
        if ( ProcessWow64Process == 64 )
        {
          Data = &unk_140063288;
          Size = 27i64;
        }
        else
        {
          Data = &unk_140063278;
          Size = 11i64;
        }
        if ( Get_KeStackAttachProcess(Process, ApcState) )
        {
          v19[0] = 0xB442ECA9;
          v19[1] = 0xA447AD7F;
          v19[2] = 0xB494B0B0;
          v19[3] = 0xF5D27F6F;
          v19[4] = 0x8A098304;
          v9 = 1;
          ModuleName = sub_14000FEA8(v19, v24);
          User_Module = EAC_Get_User_Module(ModuleName);
          if ( !User_Module
            || (unicode_string = _mm_load_si128(&xmmword_14007E620),
                v21 = 8917,
                v9 = 3,
                string_Size = sub_14000FEF8(&unicode_string, string),
                Argument2 = sub_14001DA84(User_Module, string_Size),
                v22 = Argument2,
                Flag = 0,
                !Argument2) )
          {
            Flag = 1;
          }
          if ( (v9 & 2) != 0 )
          {
            v9 &= ~2u;
            memset(string, 0, sizeof(string));
            ProcessHandle = 0i64;
          }
          if ( (v9 & 1) != 0 )
          {
            memset(v24, 0, 0x14ui64);
            ProcessHandle = 0i64;
          }
          if ( !Flag )
          {
            VirtualMemory = EAC_Allocate_ProcessVirtualMemory(ProcessHandle, Size, unknown, 64);
            Buffer = VirtualMemory;
            if ( VirtualMemory )
            {
              sub_14001D338(VirtualMemory, Size);
              EAC_memcpy(Buffer, Data, Size);
              if ( Detect_QueueApc(ThreadId, Buffer, Argument2, 1, 1) )
                ret = 1;
              else
                EAC_Free_Memory(Buffer);
            }
          }
          (loc_140054154)(Process, ApcState);   // KeUnstackDetachProcess
        }
      }
    }
    ObfDereferenceObject(Object);
  }
  return ret;
}
// 14000FE0D: variable 'ProcessHandle' is possibly undefined
// 14000FE0D: variable 'unknown' is possibly undefined
// 14007E620: using guessed type __int128 xmmword_14007E620;

//----- (000000014000FEA8) ----------------------------------------------------
__int64 __fastcall sub_14000FEA8(__int64 a1, __int64 a2)
{
  int v2; // r8d
  unsigned __int64 i; // r9
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0;
  v2 = 605498679;
  for ( i = 0i64; i < 0x14; i += 4i64 )
  {
    v2 = __ROR4__(1140671485 * v2 + 12820163, 2);
    result = a2;
    *(a2 + i) = *(a1 + i) ^ v2;
  }
  return result;
}

//----- (000000014000FEF8) ----------------------------------------------------
__int64 __fastcall sub_14000FEF8(UNICODE_STRING *unicode_string, __int64 string)
{
  unsigned int v3; // r8d
  unsigned __int64 ix; // r9
  unsigned __int64 i; // r11
  char v6; // cl
  __int64 result; // rax

  *string = 0i64;
  *(string + 0x10) = 0;
  v3 = 0x42A784A7;
  ix = 0x10i64;
  for ( i = 0i64; i < 0x10; i += 4i64 )
  {
    *(string + i) = *(&unicode_string->Length + i) ^ v3;
    v3 = ~(((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13) ^ (32 * (((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13))));
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = string;
    *(string + ix) = *(&unicode_string->Length + ix) ^ v6;
    ++ix;
  }
  while ( ix < 0x12 );
  return result;
}

//----- (00000001400102E8) ----------------------------------------------------
char __fastcall sub_1400102E8(__int64 a1, _UNICODE_STRING *unicode_string)
{
  char ret; // di
  unsigned __int64 v5; // r15
  char *v6; // rax
  char *v7; // r14
  unsigned __int64 v8; // r12
  char *Memory; // rax
  __int64 v10; // rax
  int v11; // eax
  unsigned __int16 BytesInMultiByteString[2]; // [rsp+30h] [rbp-20h] BYREF
  int v14; // [rsp+34h] [rbp-1Ch]
  char *v15; // [rsp+38h] [rbp-18h]
  int v16; // [rsp+40h] [rbp-10h]
  int v17; // [rsp+80h] [rbp+30h] BYREF

  v17 = 0;
  ret = 0;
  v14 = 0;
  switch ( *a1 )
  {
    case 0xC:
      if ( qword_1400863B0
        || (*BytesInMultiByteString = -1851543678,
            v14 = -2060275715,
            v15 = 0xDEFF5BDC463A38D2i64,
            v16 = 1852169278,
            (qword_1400863B0 = (loc_14003CB4C)(BytesInMultiByteString)) != 0i64) )
      {
        if ( sub_14005D2DC(unicode_string, 2 * (*(a1 + 16) + 1)) )
        {
          v11 = qword_1400863B0(unicode_string->Buffer, unicode_string->MaximumLength, &v17, *(a1 + 8), *(a1 + 16));
          ret = v11 >= 0;
          if ( v11 >= 0 )
            unicode_string->Length = v17;
          else
            EAC_Free_UnicodeString(unicode_string);
        }
      }
      break;
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x1C:
      v8 = (*(a1 + 16) + 1);
      Memory = EAC_Allocate_Memory(v8);
      v7 = Memory;
      if ( !Memory )
        return ret;
      memset(Memory, 0, v8);
      EAC_memcpy(Memory, *(a1 + 8), *(a1 + 0x10));
      v10 = -1i64;
      v15 = v7;
      do
        ++v10;
      while ( v7[v10] );
      BytesInMultiByteString[0] = v10;
      BytesInMultiByteString[1] = v10 + 1;
      ret = Get_RtlMultiByteToUnicodeN(&unicode_string->Length, BytesInMultiByteString) >= 0;
      goto LABEL_9;
    case 0x1E:
      v5 = (*(a1 + 16) + 2);
      v6 = EAC_Allocate_Memory(v5);
      v7 = v6;
      if ( v6 )
      {
        memset(v6, 0, v5);
        EAC_memcpy(v6, *(a1 + 8), *(a1 + 0x10));
        ret = EAC_Read_String_From_Unicode_String(unicode_string, v7);
LABEL_9:
        Get_ExFreePool(v7);
      }
      break;
  }
  return ret;
}
// 1400863B0: using guessed type __int64 (__fastcall *qword_1400863B0)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (00000001400104A8) ----------------------------------------------------
char __fastcall sub_1400104A8(char *a1, int a2, _UNICODE_STRING *unicode_string)
{
  char ret; // bl
  int v5; // ecx
  char *v7; // [rsp+20h] [rbp-40h] BYREF
  char *v8; // [rsp+28h] [rbp-38h] BYREF
  __int128 v9; // [rsp+30h] [rbp-30h] BYREF
  __int128 v10; // [rsp+40h] [rbp-20h]
  __int64 v11; // [rsp+50h] [rbp-10h]
  int v12; // [rsp+80h] [rbp+20h] BYREF
  __int16 v13; // [rsp+88h] [rbp+28h]
  int v14; // [rsp+98h] [rbp+38h] BYREF

  v13 = 1109;
  v14 = a2;
  v9 = 0i64;
  v11 = 0i64;
  ret = 0;
  v10 = 0i64;
  v8 = a1;

  while ( sub_14004803C(0, &v8, &v14, &v9) )
  {
    if ( v9 != 17 )
      break;

    if ( !v10 )
      break;

    v12 = v10;
    v7 = *(&v9 + 1);
    if ( !sub_14004803C(1, &v7, &v12, &v9) || v9 != 16 )
      break;

    if ( sub_14004803C(1, &v7, &v12, &v9) && v9 == 6 && v10 == 3 && **(&v9 + 1) == v13 && *(*(&v9 + 1) + 2i64) == 3 )
    {
      if ( !sub_14004803C(1, &v7, &v12, &v9) )
        return ret;

      if ( !v10 )
        return ret;

      if ( v9 > 0x1E )
        return ret;

      v5 = 0x50581000;
      if ( !_bittest(&v5, v9) )
        return ret;

      ret = sub_1400102E8(&v9, unicode_string);
    }
  }
  return ret;
}

//----- (00000001400105B8) ----------------------------------------------------
char __fastcall sub_1400105B8(char *a1, int a2, __int64 a3, _OWORD *a4)
{
  __int128 v6; // [rsp+20h] [rbp-30h] BYREF
  __int128 v7; // [rsp+30h] [rbp-20h]
  __int64 v8; // [rsp+40h] [rbp-10h]
  char *v9; // [rsp+60h] [rbp+10h] BYREF
  int v10; // [rsp+70h] [rbp+20h] BYREF

  v9 = a1;
  v10 = a2;
  v8 = 0i64;
  memset(a4, 0, 0x14ui64);
  v6 = 0i64;
  v7 = 0i64;
  if ( !sub_14004803C(1, &v9, &v10, &v6)
    || v6 != 16
    || !sub_14004803C(0, &v9, &v10, &v6)
    || v6 != 2
    || v7 != 1
    || **(&v6 + 1) != 1
    || !sub_14004803C(1, &v9, &v10, &v6)
    || v6 != 16
    || !sub_14004803C(0, &v9, &v10, &v6)
    || v6 != 16
    || !sub_14004803C(0, &v9, &v10, &v6)
    || v6 != 2
    || v7 > 0x14 )
  {
    return 0;
  }
  EAC_memcpy(a4, *(&v6 + 1), v7);
  return 1;
}

//----- (00000001400106D0) ----------------------------------------------------
char __fastcall sub_1400106D0(__int64 a1, int a2, __int64 a3, int a4, __m128 *a5)
{
  int v8; // ebx
  unsigned int v9; // edi
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  __m128 v13; // xmm0
  __m128 *v14; // rcx
  char result; // al
  __m128 v16; // xmm1
  __m128 v17; // xmm0
  __m128 v18; // xmm1
  __int128 v19; // [rsp+20h] [rbp-E0h] BYREF
  __int128 v20; // [rsp+30h] [rbp-D0h]
  __int64 v21; // [rsp+40h] [rbp-C0h]
  __int64 v22; // [rsp+48h] [rbp-B8h] BYREF
  __int128 v23; // [rsp+50h] [rbp-B0h] BYREF
  __int128 v24; // [rsp+60h] [rbp-A0h]
  __int64 v25; // [rsp+70h] [rbp-90h]
  __m128 v26[5]; // [rsp+80h] [rbp-80h] BYREF
  int v27[6]; // [rsp+D0h] [rbp-30h] BYREF
  __m128 v28[4]; // [rsp+E8h] [rbp-18h] BYREF
  int v29; // [rsp+130h] [rbp+30h]
  __int64 v30; // [rsp+170h] [rbp+70h] BYREF
  int v31; // [rsp+178h] [rbp+78h] BYREF
  int v32; // [rsp+188h] [rbp+88h] BYREF

  v32 = a4;
  v25 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  EAC_memset(v26, 0, 0x48ui64);
  v22 = a1;
  v31 = a2;
  while ( 1 )
  {
    if ( !sub_14004803C(0i64, &v22, &v31, &v23) )
      return 0;
    if ( v23 != 16 )
      return 0;
    v8 = v24;
    if ( !v24 )
      return 0;
    v32 = v24;
    v21 = 0i64;
    v30 = *(&v23 + 1);
    memset(v26, 0, 0x48ui64);
    v19 = 0i64;
    v20 = 0i64;
    if ( !sub_14004803C(1i64, &v30, &v32, &v19) )
      return 0;
    if ( v19 != 16 )
      return 0;
    if ( !sub_14004803C(0i64, &v30, &v32, &v19) )
      return 0;
    if ( v19 )
      return 0;
    if ( !sub_14004803C(0i64, &v30, &v32, &v19) )
      return 0;
    if ( v19 != 2 )
      return 0;
    if ( v20 > 0x14 )
      return 0;
    EAC_memcpy(v26[2].m128_f32, *(&v19 + 1), v20);
    if ( !sub_14004803C(0i64, &v30, &v32, &v19)
      || v19 != 16
      || !sub_14004803C(0i64, &v30, &v32, &v19)
      || v19 != 16
      || !v20
      || !sub_1400104A8(*(&v19 + 1), v20, v26)
      || !sub_14004803C(0i64, &v30, &v32, &v19)
      || v19 != 16
      || !sub_14004803C(0i64, &v30, &v32, &v19)
      || v19 != 16
      || !v20
      || !sub_1400104A8(*(&v19 + 1), v20, &v26[1]) )
    {
      return 0;
    }
    if ( *a3 == *&v26[2] && *(a3 + 16) == v26[3].m128_i32[0] )
      break;
    EAC_Free_UnicodeString(v26);
    EAC_Free_UnicodeString(&v26[1]);
  }
  v9 = v8 + v25;
  v10 = *(&v24 + 1);
  if ( *(&v24 + 1) )
  {
    if ( v9 )
    {
      v27[0] = 1732584193;
      v27[1] = -271733879;
      v27[2] = -1732584194;
      v27[3] = 271733878;
      v27[4] = -1009589776;
      EAC_memset(v28, 0, 0x48ui64);
      v29 = 0;
      v11 = sub_140010C68(v27, v10, v9);
      v12 = sub_140010B2C(v11, &v19);
      v13 = *v12;
      v26[4].m128_i32[1] = *(v12 + 16);
      *(&v26[3] + 4) = v13;
    }
  }
  v14 = a5;
  result = 1;
  v16 = v26[1];
  *a5 = v26[0];
  v17 = v26[2];
  v14[1] = v16;
  v18 = v26[3];
  v14[2] = v17;
  v17.m128_u64[0] = v26[4].m128_u64[0];
  v14[3] = v18;
  v14[4].m128_u64[0] = v17.m128_u64[0];
  return result;
}
// 1400104A8: using guessed type __int64 __fastcall sub_1400104A8(_QWORD, _QWORD, _QWORD);
// 140010B2C: using guessed type __int64 __fastcall sub_140010B2C(_QWORD, _QWORD);
// 140010C68: using guessed type __int64 __fastcall sub_140010C68(_QWORD, _QWORD, _QWORD);
// 14004803C: using guessed type __int64 __fastcall sub_14004803C(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400106D0: using guessed type __m128 var_78[4];

//----- (00000001400109F0) ----------------------------------------------------
bool __fastcall sub_1400109F0(char *a1, int a2, __m128 *a3)
{
  int v4; // ebx
  __int64 v5; // rdi
  __int64 v6; // r8
  int v7; // r9d
  bool result; // al
  __int128 v9; // [rsp+30h] [rbp-40h] BYREF
  int v10; // [rsp+40h] [rbp-30h]
  __int128 v11; // [rsp+48h] [rbp-28h] BYREF
  __int128 v12; // [rsp+58h] [rbp-18h]
  __int64 v13; // [rsp+68h] [rbp-8h]
  char *v14; // [rsp+90h] [rbp+20h] BYREF
  int v15; // [rsp+98h] [rbp+28h] BYREF

  v14 = a1;
  v15 = a2;
  v13 = 0i64;
  v10 = 0;
  v11 = 0i64;
  v12 = 0i64;
  v9 = 0i64;
  result = 0;
  if ( sub_14004803C(0, &v14, &v15, &v11) )
  {
    if ( v11 == 2 && v12 == 1 && **(&v11 + 1) == 1 )
    {
      if ( sub_14004803C(0, &v14, &v15, &v11) )
      {
        if ( v11 == 17 )
        {
          if ( sub_14004803C(0, &v14, &v15, &v11) )
          {
            if ( v11 == 16 )
            {
              if ( sub_14004803C(0, &v14, &v15, &v11) )
              {
                if ( !v11 )
                {
                  v4 = v12;
                  if ( v12 )
                  {
                    v5 = *(&v11 + 1);
                    if ( sub_14004803C(0, &v14, &v15, &v11) )
                    {
                      if ( v11 == 17
                        && v12
                        && sub_1400105B8(*(&v11 + 1), v12, v6, &v9)
                        && sub_1400106D0(v5, v4, &v9, v7, a3) )
                      {
                        return 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 140010AF3: variable 'v6' is possibly undefined
// 140010B0A: variable 'v7' is possibly undefined

//----- (0000000140010B2C) ----------------------------------------------------
__int64 __fastcall sub_140010B2C(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  unsigned __int64 v5; // r8
  unsigned __int64 i; // r9
  char v7; // cl
  unsigned __int64 j; // r8
  __int128 v9; // xmm1
  __int64 result; // rax
  __int128 v11; // xmm0
  __int128 v12; // xmm1
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  __int128 v15; // [rsp+20h] [rbp-19h] BYREF
  __int128 v16[5]; // [rsp+30h] [rbp-9h] BYREF
  __int64 v17; // [rsp+80h] [rbp+47h]

  LOBYTE(v15) = 0x80;
  EAC_memset((&v15 + 1), 0, 0x47ui64);
  v4 = *(a1 + 24);
  v5 = (-(v4 + 9) & 0x3F) + 1i64;
  for ( i = 0i64; i < 0x40; i += 8i64 )
  {
    v7 = 56 - i;
    *(&v16[-1] + v5++) = (8 * v4) >> v7;
  }
  sub_140010C68(a1, &v15, v5);
  *a2 = 0i64;
  *(a2 + 16) = 0;
  for ( j = 0i64; j < 0x14; ++j )
    *(j + a2) = *(a1 + 4 * (j >> 2)) >> (8 * (3 - (j & 3)));
  *&v15 = 0xEFCDAB8967452301ui64;
  *(&v15 + 1) = 0x1032547698BADCFEi64;
  LODWORD(v16[0]) = -1009589776;
  EAC_memset((v16 + 8), 0, 0x48ui64);
  LODWORD(v17) = 0;
  v9 = v16[0];
  result = a2;
  *a1 = v15;
  v11 = v16[1];
  *(a1 + 16) = v9;
  v12 = v16[2];
  *(a1 + 32) = v11;
  v13 = v16[3];
  *(a1 + 48) = v12;
  v14 = v16[4];
  *(a1 + 64) = v13;
  *&v13 = v17;
  *(a1 + 80) = v14;
  *(a1 + 96) = v13;
  return result;
}

//----- (0000000140010C68) ----------------------------------------------------
__int64 __fastcall sub_140010C68(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rdi
  _BYTE *v8; // rdx
  __int64 v9; // rcx
  char v10; // al
  __int64 v11; // r14
  __int64 v12; // r9
  unsigned __int8 *v13; // rdx
  int v14; // eax
  int v15; // ecx
  _BYTE *v16; // rcx
  char v17; // al
  __m128 v19[4]; // [rsp+20h] [rbp-58h] BYREF

  v3 = 0i64;
  v5 = *(a1 + 24) & 0x3Fi64;
  *(a1 + 24) += a3;
  if ( v5 + a3 >= 0x40 )
  {
    do
    {
      if ( v5 )
      {
        v8 = (v5 + a1 + 32);
        v9 = 64 - v5;
        do
        {
          v10 = *(v3 + a2);
          ++v3;
          *v8++ = v10;
          --v9;
        }
        while ( v9 );
        v11 = a1 + 32;
        v5 = 0i64;
      }
      else
      {
        v11 = v3 + a2;
        v3 += 64i64;
      }
      EAC_memset(v19, 0, 0x40ui64);
      v12 = 16i64;
      v13 = (v11 + 2);
      do
      {
        v14 = *v13;
        v15 = v13[1];
        v13 += 4;
        *&v13[v19 - v11 - 6] = *(v13 - 6) | ((*(v13 - 5) | ((v14 | (v15 << 8)) << 8)) << 8);
        --v12;
      }
      while ( v12 );
      sub_140010DD8(a1, v19);
    }
    while ( a3 >= v3 + 64 );
  }
  if ( v3 < a3 )
  {
    v16 = (v5 + a1 + 32);
    do
    {
      v17 = *(v3 + a2);
      ++v3;
      *v16++ = v17;
    }
    while ( v3 < a3 );
  }
  return a1;
}
// 140010CB3: conditional instruction was optimized away because rdi.8 is in (1..3F)
// 140010C68: using guessed type __m128 var_58[4];

//----- (0000000140010D8C) ----------------------------------------------------
__m128 *__fastcall sub_140010D8C(__m128 *a1)
{
  a1[1].m128_u64[1] = 0i64;
  a1->m128_i32[0] = 1732584193;
  a1->m128_i32[1] = -271733879;
  a1->m128_i32[2] = -1732584194;
  a1->m128_i32[3] = 271733878;
  a1[1].m128_i32[0] = -1009589776;
  EAC_memset(a1 + 2, 0, 0x40ui64);
  a1[6].m128_i32[0] = 0;
  return a1;
}

//----- (0000000140010DD8) ----------------------------------------------------
__int64 __fastcall sub_140010DD8(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // rdi
  int v3; // edx
  int v4; // r9d
  int v5; // r8d
  int v6; // r10d
  int v7; // ecx
  int v8; // r9d
  int v9; // r11d
  int v10; // ecx
  int v11; // r10d
  int v12; // edx
  int v13; // ecx
  int v14; // r11d
  int v15; // r8d
  int v16; // ecx
  int v17; // edx
  int v18; // r9d
  int v19; // ecx
  int v20; // r8d
  int v21; // r10d
  int v22; // ecx
  int v23; // r9d
  int v24; // r11d
  int v25; // ecx
  int v26; // r10d
  int v27; // edx
  int v28; // ecx
  int v29; // r11d
  int v30; // r8d
  int v31; // ecx
  int v32; // edx
  int v33; // ebx
  int v34; // r9d
  int v35; // r8d
  int v36; // r10d
  int v37; // ebx
  int v38; // r10d
  int v39; // r11d
  int v40; // r9d
  int v41; // r11d
  int v42; // edx
  int v43; // r10d
  int v44; // edx
  int v45; // r8d
  int v46; // r11d
  int v47; // r8d
  int v48; // r12d
  int v49; // ecx
  int v50; // edx
  int v51; // r9d
  int v52; // ecx
  int v53; // r8d
  int v54; // r10d
  int v55; // r13d
  int v56; // ecx
  int v57; // r9d
  int v58; // r11d
  int v59; // ecx
  int v60; // r10d
  int v61; // edx
  int v62; // ecx
  int v63; // r11d
  int v64; // r8d
  int v65; // ebp
  int v66; // r15d
  int v67; // r9d
  int v68; // ecx
  int v69; // r8d
  int v70; // edx
  int v71; // r14d
  int v72; // r10d
  int v73; // esi
  int v74; // ecx
  int v75; // r9d
  int v76; // r11d
  int v77; // r12d
  int v78; // ecx
  int v79; // r10d
  int v80; // edx
  int v81; // ebx
  int v82; // r11d
  int v83; // ebx
  int v84; // edx
  int v85; // ecx
  int v86; // ebx
  int v87; // r8d
  unsigned int v88; // ecx
  int v89; // r9d
  unsigned int v90; // ecx
  int v91; // r8d
  int v92; // r10d
  unsigned int v93; // r11d
  int v94; // r9d
  int v95; // r11d
  int v96; // edx
  int v97; // r10d
  int v98; // edx
  int v99; // ecx
  int v100; // r11d
  int v101; // r8d
  int v102; // ecx
  int v103; // edx
  int v104; // r9d
  int v105; // ecx
  int v106; // r8d
  int v107; // r10d
  int v108; // ecx
  int v109; // r9d
  int v110; // r11d
  int v111; // r13d
  int v112; // ebx
  int v113; // r10d
  int v114; // ecx
  int v115; // r11d
  int v116; // ebx
  int v117; // edx
  int v118; // ebp
  int v119; // r8d
  int v120; // ecx
  int v121; // ebx
  int v122; // r9d
  int v123; // ecx
  int v124; // r8d
  int v125; // r10d
  int v126; // ecx
  int v127; // r9d
  int v128; // r11d
  int v129; // r14d
  int v130; // ecx
  int v131; // r10d
  int v132; // ebx
  int v133; // ecx
  int v134; // r11d
  int v135; // r8d
  int v136; // eax
  int v137; // ecx
  int v138; // ebx
  int v139; // r9d
  int v140; // ecx
  int v141; // r8d
  int v142; // r10d
  int v143; // r14d
  int v144; // r13d
  int v145; // ecx
  int v146; // r9d
  int v147; // r11d
  int v148; // ecx
  int v149; // r10d
  int v150; // ebx
  int v151; // eax
  int v152; // ecx
  int v153; // r11d
  int v154; // ecx
  int v155; // eax
  int v156; // r8d
  int v157; // ecx
  int v158; // ebx
  int v159; // r9d
  int v160; // ecx
  int v161; // r8d
  int v162; // r10d
  int v163; // eax
  int v164; // ecx
  int v165; // r9d
  int v166; // r11d
  int v167; // ecx
  int v168; // r10d
  int v169; // eax
  int v170; // ebx
  int v171; // ecx
  int v172; // r11d
  int v173; // r8d
  int v174; // r12d
  int v175; // ebx
  int v176; // ecx
  int v177; // r8d
  int v178; // esi
  unsigned int v179; // ecx
  int v180; // r9d
  int v181; // r15d
  unsigned int v182; // ecx
  int v183; // esi
  int v184; // eax
  int v185; // r10d
  unsigned int v186; // ecx
  int v187; // r9d
  int v188; // r11d
  int v189; // edx
  int v190; // ecx
  int v191; // r10d
  int v192; // eax
  int v193; // ebx
  int v194; // ecx
  int v195; // r11d
  int v196; // r8d
  int v197; // esi
  int v198; // eax
  int v199; // ebx
  int v200; // r9d
  int v201; // eax
  int v202; // r8d
  int v203; // r10d
  int v204; // eax
  int v205; // r9d
  int v206; // r11d
  int v207; // eax
  int v208; // r10d
  int v209; // ebx
  int v210; // eax
  int v211; // r11d
  int v212; // edx
  int v213; // r8d
  int v214; // eax
  int v215; // ebx
  int v216; // r9d
  int v217; // r8d
  int v218; // eax
  int v219; // edx
  int v220; // r9d
  int v221; // r14d
  int v222; // eax
  int v223; // r8d
  int v224; // r15d
  int v225; // r10d
  int v226; // r12d
  int v227; // eax
  int v228; // r9d
  int v229; // r11d
  int v230; // r13d
  int v231; // eax
  int v232; // r10d
  int v233; // ebx
  int v234; // eax
  int v235; // r11d
  int v236; // r8d
  int v237; // eax
  int v238; // ebx
  int v239; // r9d
  int v240; // edx
  int v241; // esi
  int v242; // ebp
  int v243; // eax
  int v244; // r8d
  int v245; // edx
  int v246; // esi
  int v247; // eax
  int v248; // r9d
  int v249; // r11d
  int v250; // ebp
  unsigned int v251; // eax
  int v252; // ebx
  unsigned int v253; // eax
  int v254; // r11d
  int v255; // r10d
  unsigned int v256; // eax
  int v257; // ebx
  int v258; // r9d
  int v259; // edx
  int v260; // eax
  int v261; // r10d
  int v262; // r8d
  int v263; // esi
  int v264; // ebp
  int v265; // eax
  int v266; // r9d
  int v267; // edx
  __int64 result; // rax
  unsigned int v269; // [rsp+0h] [rbp-A8h]
  int v270; // [rsp+0h] [rbp-A8h]
  int v271; // [rsp+0h] [rbp-A8h]
  int v272; // [rsp+0h] [rbp-A8h]
  int v273; // [rsp+0h] [rbp-A8h]
  unsigned int v274; // [rsp+4h] [rbp-A4h]
  int v275; // [rsp+4h] [rbp-A4h]
  int v276; // [rsp+4h] [rbp-A4h]
  unsigned int v277; // [rsp+8h] [rbp-A0h]
  int v278; // [rsp+8h] [rbp-A0h]
  int v279; // [rsp+8h] [rbp-A0h]
  int v280; // [rsp+8h] [rbp-A0h]
  unsigned int v281; // [rsp+Ch] [rbp-9Ch]
  int v282; // [rsp+Ch] [rbp-9Ch]
  int v283; // [rsp+Ch] [rbp-9Ch]
  int v284; // [rsp+Ch] [rbp-9Ch]
  unsigned int v285; // [rsp+10h] [rbp-98h]
  int v286; // [rsp+10h] [rbp-98h]
  int v287; // [rsp+10h] [rbp-98h]
  int v288; // [rsp+10h] [rbp-98h]
  int v289; // [rsp+14h] [rbp-94h]
  int v290; // [rsp+14h] [rbp-94h]
  int v291; // [rsp+14h] [rbp-94h]
  unsigned int v292; // [rsp+18h] [rbp-90h]
  int v293; // [rsp+18h] [rbp-90h]
  int v294; // [rsp+18h] [rbp-90h]
  unsigned int v295; // [rsp+1Ch] [rbp-8Ch]
  int v296; // [rsp+1Ch] [rbp-8Ch]
  int v297; // [rsp+1Ch] [rbp-8Ch]
  unsigned int v298; // [rsp+20h] [rbp-88h]
  int v299; // [rsp+20h] [rbp-88h]
  int v300; // [rsp+20h] [rbp-88h]
  unsigned int v301; // [rsp+24h] [rbp-84h]
  int v302; // [rsp+24h] [rbp-84h]
  int v303; // [rsp+24h] [rbp-84h]
  unsigned int v304; // [rsp+28h] [rbp-80h]
  int v305; // [rsp+28h] [rbp-80h]
  int v306; // [rsp+28h] [rbp-80h]
  unsigned int v307; // [rsp+2Ch] [rbp-7Ch]
  int v308; // [rsp+2Ch] [rbp-7Ch]
  int v309; // [rsp+2Ch] [rbp-7Ch]
  int v310; // [rsp+2Ch] [rbp-7Ch]
  unsigned int v311; // [rsp+30h] [rbp-78h]
  int v312; // [rsp+30h] [rbp-78h]
  unsigned int v313; // [rsp+34h] [rbp-74h]
  int v314; // [rsp+34h] [rbp-74h]
  int v315; // [rsp+34h] [rbp-74h]
  int v316; // [rsp+38h] [rbp-70h]
  int v317; // [rsp+38h] [rbp-70h]
  int v318; // [rsp+38h] [rbp-70h]
  unsigned int v319; // [rsp+3Ch] [rbp-6Ch]
  int v320; // [rsp+3Ch] [rbp-6Ch]
  int v321; // [rsp+40h] [rbp-68h]
  int v322; // [rsp+44h] [rbp-64h]
  int v323; // [rsp+48h] [rbp-60h]
  int v324; // [rsp+4Ch] [rbp-5Ch]
  int v325; // [rsp+50h] [rbp-58h]
  unsigned int v328; // [rsp+C0h] [rbp+18h]
  int v329; // [rsp+C0h] [rbp+18h]
  int v330; // [rsp+C0h] [rbp+18h]
  int v331; // [rsp+C0h] [rbp+18h]
  unsigned int v332; // [rsp+C8h] [rbp+20h]
  int v333; // [rsp+C8h] [rbp+20h]
  int v334; // [rsp+C8h] [rbp+20h]
  int v335; // [rsp+C8h] [rbp+20h]

  v2 = a2;
  v321 = *a1;
  v325 = a1[4];
  v322 = a1[1];
  v324 = a1[3];
  v323 = a1[2];
  v285 = __ROL4__(*a2, 8) & 0xFF00FF | __ROR4__(*a2, 8) & 0xFF00FF00;
  v3 = __ROR4__(v322, 2);
  v4 = v285 + __ROL4__(*a1, 5) + (v324 ^ v322 & (v323 ^ v324)) + v325 + 1518500249;
  v277 = __ROL4__(v2[1], 8) & 0xFF00FF | __ROR4__(v2[1], 8) & 0xFF00FF00;
  v5 = __ROR4__(*a1, 2);
  v6 = v324 + 1518500249 + v277 + __ROL4__(v4, 5) + (v323 ^ *a1 & (v3 ^ v323));
  v7 = v4 & (v5 ^ v3);
  v8 = __ROR4__(v4, 2);
  v269 = __ROL4__(v2[2], 8) & 0xFF00FF | __ROR4__(v2[2], 8) & 0xFF00FF00;
  v9 = v323 + (v3 ^ v7) + 1518500249 + __ROL4__(v6, 5) + v269;
  v332 = __ROL4__(v2[3], 8) & 0xFF00FF | __ROR4__(v2[3], 8) & 0xFF00FF00;
  v10 = v6 & (v5 ^ v8);
  v11 = __ROR4__(v6, 2);
  v12 = v332 + __ROL4__(v9, 5) + (v5 ^ v10) + v3 + 1518500249;
  v13 = v8 ^ v9 & (v11 ^ v8);
  v319 = __ROL4__(v2[4], 8) & 0xFF00FF | __ROR4__(v2[4], 8) & 0xFF00FF00;
  v14 = __ROR4__(v9, 2);
  v15 = v319 + __ROL4__(v12, 5) + v13 + v5 + 1518500249;
  v16 = v11 ^ v12 & (v14 ^ v11);
  v311 = __ROL4__(v2[5], 8) & 0xFF00FF | __ROR4__(v2[5], 8) & 0xFF00FF00;
  v17 = __ROR4__(v12, 2);
  v18 = v311 + 1518500249 + __ROL4__(v15, 5) + v16 + v8;
  v304 = __ROL4__(v2[6], 8) & 0xFF00FF | __ROR4__(v2[6], 8) & 0xFF00FF00;
  v19 = v14 ^ v15 & (v17 ^ v14);
  v20 = __ROR4__(v15, 2);
  v21 = v304 + 1518500249 + __ROL4__(v18, 5) + v19 + v11;
  v292 = __ROL4__(v2[7], 8) & 0xFF00FF | __ROR4__(v2[7], 8) & 0xFF00FF00;
  v22 = v17 ^ v18 & (v20 ^ v17);
  v23 = __ROR4__(v18, 2);
  v24 = v292 + 1518500249 + __ROL4__(v21, 5) + v22 + v14;
  v25 = v20 ^ v21 & (v20 ^ v23);
  v26 = __ROR4__(v21, 2);
  v298 = __ROL4__(v2[8], 8) & 0xFF00FF | __ROR4__(v2[8], 8) & 0xFF00FF00;
  v27 = v298 + __ROL4__(v24, 5) + 1518500249 + v25 + v17;
  v28 = v23 ^ v24 & (v26 ^ v23);
  v301 = __ROL4__(v2[9], 8) & 0xFF00FF | __ROR4__(v2[9], 8) & 0xFF00FF00;
  v29 = __ROR4__(v24, 2);
  v30 = v301 + 1518500249 + __ROL4__(v27, 5) + v28 + v20;
  v328 = __ROL4__(v2[10], 8) & 0xFF00FF | __ROR4__(v2[10], 8) & 0xFF00FF00;
  v31 = v26 ^ v27 & (v29 ^ v26);
  v32 = __ROR4__(v27, 2);
  v33 = v23 + 1518500249 + v31 + __ROL4__(v30, 5) + v328;
  v281 = __ROL4__(v2[11], 8) & 0xFF00FF | __ROR4__(v2[11], 8) & 0xFF00FF00;
  v34 = v26 + 1518500249 + v281 + __ROL4__(v33, 5) + (v29 ^ v30 & (v32 ^ v29));
  v35 = __ROR4__(v30, 2);
  v36 = v33 & (v35 ^ v32);
  v37 = __ROR4__(v33, 2);
  v274 = __ROL4__(v2[12], 8) & 0xFF00FF | __ROR4__(v2[12], 8) & 0xFF00FF00;
  v38 = v29 + 1518500249 + v274 + __ROL4__(v34, 5) + (v32 ^ v36);
  v39 = v35 ^ v34 & (v35 ^ v37);
  v40 = __ROR4__(v34, 2);
  v307 = __ROL4__(v2[13], 8) & 0xFF00FF | __ROR4__(v2[13], 8) & 0xFF00FF00;
  v41 = v32 + 1518500249 + v307 + __ROL4__(v38, 5) + v39;
  v42 = v37 ^ v38 & (v40 ^ v37);
  v43 = __ROR4__(v38, 2);
  v313 = __ROL4__(v2[14], 8) & 0xFF00FF | __ROR4__(v2[14], 8) & 0xFF00FF00;
  v44 = v35 + 1518500249 + v313 + __ROL4__(v41, 5) + v42;
  v45 = v40 ^ v41 & (v43 ^ v40);
  v46 = __ROR4__(v41, 2);
  v295 = __ROL4__(v2[15], 8) & 0xFF00FF | __ROR4__(v2[15], 8) & 0xFF00FF00;
  v47 = v37 + v295 + __ROL4__(v44, 5) + 1518500249 + v45;
  v48 = __ROL4__(v285 ^ v269 ^ v298 ^ v307, 1);
  v49 = v43 ^ v44 & (v46 ^ v43);
  v50 = __ROR4__(v44, 2);
  v51 = v48 + __ROL4__(v47, 5) + 1518500249 + v49 + v40;
  v316 = v48;
  v270 = __ROL4__(v269 ^ v319 ^ v328 ^ v295, 1);
  v286 = __ROL4__(v48 ^ v332 ^ v311 ^ v281, 1);
  v52 = v46 ^ v47 & (v50 ^ v46);
  v53 = __ROR4__(v47, 2);
  v278 = __ROL4__(v277 ^ v332 ^ v301 ^ v313, 1);
  v54 = v278 + __ROL4__(v51, 5) + 1518500249 + v52 + v43;
  v55 = __ROL4__(v278 ^ v319 ^ v304 ^ v274, 1);
  v56 = v50 ^ v51 & (v50 ^ v53);
  v57 = __ROR4__(v51, 2);
  v58 = v270 + __ROL4__(v54, 5) + 1518500249 + v56 + v46;
  v59 = v53 ^ v54 & (v57 ^ v53);
  v60 = __ROR4__(v54, 2);
  v61 = v286 + __ROL4__(v58, 5) + 1518500249 + v59 + v50;
  v62 = v58 ^ v60 ^ v57;
  v63 = __ROR4__(v58, 2);
  v64 = v55 + __ROL4__(v61, 5) + 1859775393 + v62 + v53;
  v65 = __ROL4__(v311 ^ v292 ^ v307 ^ v270, 1);
  v66 = __ROL4__(v304 ^ v298 ^ v313 ^ v286, 1);
  v67 = v65 + __ROL4__(v64, 5) + 1859775393 + (v61 ^ v63 ^ v60) + v57;
  v68 = v63 ^ v64;
  v69 = __ROR4__(v64, 2);
  v70 = __ROR4__(v61, 2);
  v71 = __ROL4__(v292 ^ v301 ^ v295 ^ v55, 1);
  v72 = v66 + __ROL4__(v67, 5) + 1859775393 + (v70 ^ v68) + v60;
  v73 = __ROL4__(v48 ^ v298 ^ v328 ^ v65, 1);
  v74 = v70 ^ v67 ^ v69;
  v75 = __ROR4__(v67, 2);
  v76 = v71 + __ROL4__(v72, 5) + 1859775393 + v74 + v63;
  v77 = __ROL4__(v278 ^ v301 ^ v281 ^ v66, 1);
  v78 = v73 + __ROL4__(v76, 5) + (v72 ^ v75 ^ v69);
  v79 = __ROR4__(v72, 2);
  v80 = v78 + v70 + 1859775393;
  v81 = v76 ^ v79 ^ v75;
  v82 = __ROR4__(v76, 2);
  v83 = v69 + 1859775393 + v77 + __ROL4__(v80, 5) + v81;
  v293 = __ROL4__(v328 ^ v274 ^ v270 ^ v71, 1);
  LODWORD(v2) = v293 + __ROL4__(v83, 5) + (v80 ^ v82 ^ v79);
  v84 = __ROR4__(v80, 2);
  LODWORD(v2) = v75 + 1859775393 + v2;
  v85 = v82 ^ v83;
  v86 = __ROR4__(v83, 2);
  v289 = __ROL4__(v281 ^ v307 ^ v286 ^ v73, 1);
  v282 = __ROL4__(v274 ^ v313 ^ v55 ^ v77, 1);
  v87 = v79 + 1859775393 + (v84 ^ v85) + __ROL4__(v2, 5) + v289;
  v88 = v84 ^ v2 ^ v86;
  LODWORD(v2) = __ROR4__(v2, 2);
  v308 = __ROL4__(v307 ^ v295 ^ v65 ^ v293, 1);
  v89 = v82 + 1859775393 + v88 + __ROL4__(v87, 5) + v282;
  v90 = v87 ^ v2 ^ v86;
  v91 = __ROR4__(v87, 2);
  v92 = v84 + 1859775393 + v90 + __ROL4__(v89, 5) + v308;
  v93 = v89 ^ v91 ^ v2;
  v333 = __ROL4__(v316 ^ v313 ^ v66 ^ v289, 1);
  v94 = __ROR4__(v89, 2);
  v95 = v86 + 1859775393 + v333 + __ROL4__(v92, 5) + v93;
  v275 = __ROL4__(v278 ^ v295 ^ v71 ^ v282, 1);
  v96 = (v92 ^ v94 ^ v91) + __ROL4__(v95, 5) + v275;
  v97 = __ROR4__(v92, 2);
  v98 = v2 + 1859775393 + v96;
  v99 = v97 ^ v94 ^ v95;
  v317 = __ROL4__(v316 ^ v270 ^ v73 ^ v308, 1);
  v100 = __ROR4__(v95, 2);
  v101 = v317 + 1859775393 + __ROL4__(v98, 5) + v99 + v91;
  LODWORD(v2) = __ROL4__(v278 ^ v286 ^ v77 ^ v333, 1);
  v102 = v97 ^ v98 ^ v100;
  v103 = __ROR4__(v98, 2);
  v104 = v2 + 1859775393 + __ROL4__(v101, 5) + v102 + v94;
  v105 = v101 ^ v103 ^ v100;
  v329 = __ROL4__(v270 ^ v55 ^ v293 ^ v275, 1);
  v106 = __ROR4__(v101, 2);
  v107 = v329 + 1859775393 + __ROL4__(v104, 5) + v105 + v97;
  v108 = v104 ^ v106 ^ v103;
  v271 = __ROL4__(v317 ^ v286 ^ v65 ^ v289, 1);
  v109 = __ROR4__(v104, 2);
  v110 = v271 + 1859775393 + __ROL4__(v107, 5) + v108 + v100;
  v314 = __ROL4__(v2 ^ v55 ^ v66 ^ v282, 1);
  v111 = v308;
  v112 = (v107 ^ v109 ^ v106) + __ROL4__(v110, 5) + v314;
  v113 = __ROR4__(v107, 2);
  v114 = v109 ^ v110;
  v115 = __ROR4__(v110, 2);
  v116 = v103 + 1859775393 + v112;
  v117 = v329 ^ v65 ^ v71 ^ v308;
  v118 = v271;
  v309 = __ROL4__(v117, 1);
  v119 = v309 + __ROL4__(v116, 5) + 1859775393 + (v113 ^ v114) + v106;
  v120 = v113 ^ v116 ^ v115;
  v299 = __ROL4__(v271 ^ v66 ^ v73 ^ v333, 1);
  v121 = __ROR4__(v116, 2);
  v122 = v299 + 1859775393 + __ROL4__(v119, 5) + v120 + v109;
  v123 = v119 ^ v121 ^ v115;
  v124 = __ROR4__(v119, 2);
  v279 = __ROL4__(v314 ^ v71 ^ v77 ^ v275, 1);
  v125 = v279 + 1859775393 + __ROL4__(v122, 5) + v123 + v113;
  v302 = __ROL4__(v309 ^ v317 ^ v73 ^ v293, 1);
  v126 = v302 + (v122 & v124 | v121 & (v122 | v124));
  v127 = __ROR4__(v122, 2);
  v128 = v115 + v126 + __ROL4__(v125, 5) - 1894007588;
  v129 = __ROL4__(v2 ^ v299 ^ v77 ^ v289, 1);
  v130 = v125 & v127 | v124 & (v125 | v127);
  v131 = __ROR4__(v125, 2);
  v294 = __ROL4__(v279 ^ v329 ^ v293 ^ v282, 1);
  v132 = v121 + v129 + v130 + __ROL4__(v128, 5) - 1894007588;
  v305 = v129;
  v296 = __ROL4__(v271 ^ v302 ^ v289 ^ v111, 1);
  v133 = v131 & v128 | v127 & (v131 | v128);
  v134 = __ROR4__(v128, 2);
  v136 = v132 & v134;
  v135 = v124 + v294 + v133 + __ROL4__(v132, 5) - 1894007588;
  v137 = v131 & (v132 | v134);
  v138 = __ROR4__(v132, 2);
  v139 = v127 + v296 + (v136 | v137) + __ROL4__(v135, 5) - 1894007588;
  v283 = __ROL4__(v314 ^ v129 ^ v282 ^ v333, 1);
  v140 = v135 & v138 | v134 & (v135 | v138);
  v141 = __ROR4__(v135, 2);
  v142 = v131 + v283 + v140 + __ROL4__(v139, 5) - 1894007588;
  v143 = __ROL4__(v309 ^ v294 ^ v111 ^ v275, 1);
  v144 = v299;
  v145 = v143 + (v139 & v141 | v138 & (v139 | v141));
  v146 = __ROR4__(v139, 2);
  v147 = v134 + v145 + __ROL4__(v142, 5) - 1894007588;
  v334 = __ROL4__(v317 ^ v299 ^ v296 ^ v333, 1);
  v148 = v142 & v146 | v141 & (v142 | v146);
  v149 = __ROR4__(v142, 2);
  v150 = v138 + v334 + v148 + __ROL4__(v147, 5) - 1894007588;
  v151 = v149 & v147;
  v276 = __ROL4__(v2 ^ v279 ^ v283 ^ v275, 1);
  v152 = v146 & (v149 | v147);
  v153 = __ROR4__(v147, 2);
  v154 = v276 + (v151 | v152);
  v155 = v150 & v153;
  v156 = v141 + v154 + __ROL4__(v150, 5) - 1894007588;
  v157 = v149 & (v150 | v153);
  v158 = __ROR4__(v150, 2);
  v272 = __ROL4__(v317 ^ v302 ^ v143 ^ v329, 1);
  v290 = __ROL4__(v2 ^ v118 ^ v305 ^ v334, 1);
  v159 = v146 + v272 + (v155 | v157) + __ROL4__(v156, 5) - 1894007588;
  v160 = v290 + (v156 & v158 | v153 & (v156 | v158));
  v161 = __ROR4__(v156, 2);
  v330 = __ROL4__(v314 ^ v294 ^ v276 ^ v329, 1);
  v162 = v149 + v160 + __ROL4__(v159, 5) - 1894007588;
  v163 = v159 & v161;
  v164 = v158 & (v159 | v161);
  v165 = __ROR4__(v159, 2);
  v320 = __ROL4__(v314 ^ v299 ^ v283 ^ v290, 1);
  v300 = __ROL4__(v309 ^ v118 ^ v296 ^ v272, 1);
  v287 = __ROL4__(v309 ^ v279 ^ v143 ^ v330, 1);
  v166 = v153 + v330 + (v163 | v164) + __ROL4__(v162, 5) - 1894007588;
  v167 = v162 & v165 | v161 & (v162 | v165);
  v168 = __ROR4__(v162, 2);
  v169 = v168 & v166;
  v170 = v158 + v300 + v167 + __ROL4__(v166, 5) - 1894007588;
  v171 = v168 | v166;
  v172 = __ROR4__(v166, 2);
  v173 = __ROL4__(v170, 5) + v320 + (v169 | v165 & v171) - 1894007588 + v161;
  LODWORD(v2) = v165 - 1894007588 + v287 + (v170 & v172 | v168 & (v170 | v172)) + __ROL4__(v173, 5);
  v174 = v302;
  v175 = __ROR4__(v170, 2);
  v303 = __ROL4__(v144 ^ v302 ^ v334 ^ v300, 1);
  v318 = __ROL4__(v279 ^ v305 ^ v276 ^ v320, 1);
  v176 = v173 & v175 | v172 & (v173 | v175);
  v177 = __ROR4__(v173, 2);
  v178 = v168 - 1894007588 + v303 + v176 + __ROL4__(v2, 5);
  v315 = __ROL4__(v174 ^ v294 ^ v272 ^ v287, 1);
  v306 = __ROL4__(v305 ^ v296 ^ v290 ^ v303, 1);
  v179 = v2 & v177 | v175 & (v2 | v177);
  LODWORD(v2) = __ROR4__(v2, 2);
  v180 = v172 - 1894007588 + v318 + v179 + __ROL4__(v178, 5);
  v181 = v283;
  v182 = v178 & v2 | v177 & (v178 | v2);
  v183 = __ROR4__(v178, 2);
  v184 = v183 & v180;
  v185 = v175 - 1894007588 + v315 + v182 + __ROL4__(v180, 5);
  v186 = v2 & (v183 | v180);
  v187 = __ROR4__(v180, 2);
  v188 = v177 - 1894007588 + v306 + (v184 | v186) + __ROL4__(v185, 5);
  v189 = v272;
  v310 = __ROL4__(v294 ^ v283 ^ v330 ^ v318, 1);
  v190 = v185 & v187 | v183 & (v185 | v187);
  v191 = __ROR4__(v185, 2);
  v192 = v188 & v191;
  v193 = v2 - 1894007588 + v310 + v190 + __ROL4__(v188, 5);
  v284 = __ROL4__(v296 ^ v143 ^ v300 ^ v315, 1);
  v194 = v187 & (v188 | v191);
  v195 = __ROR4__(v188, 2);
  v196 = v183 - 1894007588 + v284 + (v192 | v194) + __ROL4__(v193, 5);
  v197 = __ROL4__(v181 ^ v334 ^ v320 ^ v306, 1);
  v198 = v197 + (v193 ^ v195 ^ v191);
  v199 = __ROR4__(v193, 2);
  v200 = v187 + v198 + __ROL4__(v196, 5) - 899497514;
  v312 = v197;
  v297 = __ROL4__(v143 ^ v276 ^ v287 ^ v310, 1);
  v335 = __ROL4__(v334 ^ v272 ^ v303 ^ v284, 1);
  v201 = v191 + v297 + (v196 ^ v199 ^ v195);
  v202 = __ROR4__(v196, 2);
  v203 = v201 + __ROL4__(v200, 5) - 899497514;
  v204 = v335 + (v202 ^ v199 ^ v200);
  v205 = __ROR4__(v200, 2);
  v206 = v195 + v204 + __ROL4__(v203, 5) - 899497514;
  v207 = v202 ^ v203 ^ v205;
  v208 = __ROR4__(v203, 2);
  v273 = __ROL4__(v276 ^ v290 ^ v318 ^ v197, 1);
  v280 = __ROL4__(v189 ^ v330 ^ v315 ^ v297, 1);
  v209 = v199 + v273 + v207 + __ROL4__(v206, 5) - 899497514;
  *a2 = v280;
  v210 = v206 ^ v208 ^ v205;
  v211 = __ROR4__(v206, 2);
  v212 = v202 - 899497514 + v280 + v210 + __ROL4__(v209, 5);
  v213 = __ROL4__(v300 ^ v306 ^ v335 ^ v290, 1);
  v214 = v205 + v213 + (v209 ^ v211 ^ v208);
  v291 = v213;
  a2[1] = v213;
  v215 = __ROR4__(v209, 2);
  v216 = __ROL4__(v320 ^ v310 ^ v273 ^ v330, 1);
  v217 = v214 + __ROL4__(v212, 5) - 899497514;
  a2[2] = v216;
  v331 = v216;
  v218 = v212 ^ v215 ^ v211;
  v219 = __ROR4__(v212, 2);
  v220 = __ROL4__(v217, 5) + v208 - 899497514 + v218 + v216;
  v221 = __ROL4__(v300 ^ v287 ^ v284 ^ v280, 1);
  a2[3] = v221;
  v222 = v221 + (v219 ^ v215 ^ v217);
  v223 = __ROR4__(v217, 2);
  v224 = __ROL4__(v320 ^ v303 ^ v197 ^ v291, 1);
  a2[4] = v224;
  v225 = v211 - 899497514 + v222 + __ROL4__(v220, 5);
  v226 = __ROL4__(v287 ^ v318 ^ v297 ^ v331, 1);
  v227 = v219 ^ v220 ^ v223;
  v228 = __ROR4__(v220, 2);
  v229 = v215 - 899497514 + v224 + v227 + __ROL4__(v225, 5);
  a2[5] = v226;
  v230 = __ROL4__(v303 ^ v315 ^ v335 ^ v221, 1);
  v231 = v225 ^ v228 ^ v223;
  v232 = __ROR4__(v225, 2);
  v233 = v219 - 899497514 + v226 + v231 + __ROL4__(v229, 5);
  a2[6] = v230;
  v288 = __ROL4__(v318 ^ v306 ^ v273 ^ v224, 1);
  v234 = v230 + (v229 ^ v232 ^ v228);
  v235 = __ROR4__(v229, 2);
  v236 = v223 + v234 + __ROL4__(v233, 5) - 899497514;
  a2[7] = v288;
  v237 = v233 ^ v235 ^ v232;
  v238 = __ROR4__(v233, 2);
  v239 = v228 + v288 + v237 + __ROL4__(v236, 5) - 899497514;
  v240 = v310 ^ v197 ^ v331 ^ v288;
  v241 = __ROL4__(v315 ^ v310 ^ v280 ^ v226, 1);
  a2[8] = v241;
  v242 = __ROL4__(v306 ^ v284 ^ v291 ^ v230, 1);
  v243 = v238 ^ v235 ^ v236;
  v244 = __ROR4__(v236, 2);
  v245 = __ROL4__(v240, 1);
  LODWORD(v2) = v232 + v241 + v243 - 899497514 + __ROL4__(v239, 5);
  v246 = __ROL4__(v284 ^ v297 ^ v221 ^ v241, 1);
  a2[9] = v242;
  v247 = v239 ^ v244;
  v248 = __ROR4__(v239, 2);
  v249 = v235 + v242 + (v238 ^ v247) + __ROL4__(v2, 5) - 899497514;
  v250 = __ROL4__(v312 ^ v335 ^ v224 ^ v242, 1);
  a2[10] = v245;
  v251 = v2 ^ v248 ^ v244;
  LODWORD(v2) = __ROR4__(v2, 2);
  v252 = v238 + v245 + v251 + __ROL4__(v249, 5) - 899497514;
  a2[11] = v246;
  v253 = v249 ^ v2 ^ v248;
  v254 = __ROR4__(v249, 2);
  v255 = v244 - 899497514 + v246 + v253 + __ROL4__(v252, 5);
  a2[12] = v250;
  v256 = v252 ^ v254 ^ v2;
  v257 = __ROR4__(v252, 2);
  v258 = __ROL4__(v255, 5) + v250 + v256 - 899497514 + v248;
  v259 = __ROL4__(v297 ^ v273 ^ v226 ^ v245, 1);
  a2[13] = v259;
  v260 = v2 + v259 - 899497514 + (v257 ^ v254 ^ v255);
  v261 = __ROR4__(v255, 2);
  v262 = v260 + __ROL4__(v258, 5);
  v263 = __ROL4__(v335 ^ v280 ^ v230 ^ v246, 1);
  v264 = __ROL4__(v273 ^ v291 ^ v288 ^ v250, 1);
  a2[14] = v263;
  v265 = v257 ^ v258 ^ v261;
  v266 = __ROR4__(v258, 2);
  a2[15] = v264;
  v267 = v254 + v263 + v265 - 899497514 + __ROL4__(v262, 5);
  *a1 = v257 - 899497514 + __ROL4__(v267, 5) + v264 + v321 + (v262 ^ v266 ^ v261);
  a1[2] = v323 + __ROR4__(v262, 2);
  a1[1] = v267 + v322;
  a1[3] = v266 + v324;
  result = (v261 + v325);
  a1[4] = result;
  return result;
}

//----- (0000000140012118) ----------------------------------------------------
char *__fastcall sub_140012118(char *a1, __int64 a2, _OWORD *a3)
{
  __int64 v4; // rbx

  v4 = a2 - a1;
  EAC_memcpy(a3, a1, a2 - a1);
  return a3 + v4;
}

//----- (0000000140012960) ----------------------------------------------------
void __fastcall sub_140012960(__int64 ProcessId_1)
{
  _DWORD *v2; // rax
  _DWORD *Buffer; // rbx
  __int64 v4; // rdi
  unsigned int v5; // eax
  __int64 ProcessId; // rax
  __int64 *v7; // r14

  if ( ProcessId_1 )
  {
    v2 = EAC_NtQuerySystemInformation(0x10u, 0x80000u, 0x1000000u, 0i64);
    Buffer = v2;
    if ( v2 )
    {
      v4 = 0i64;
      if ( *v2 )
      {
        do
        {
          v5 = Buffer[6 * v4 + 2];
          if ( v5 == ProcessId_1 && v5 > 4 && sub_140050898(*&Buffer[6 * v4 + 4]) == PsProcessType )
          {
            ProcessId = Get_PsGetProcessId(*&Buffer[6 * v4 + 4]);
            v7 = sub_14000D7E8(ProcessId);
            if ( v7 )
            {
              sub_140052970(ProcessId_1, HIWORD(Buffer[6 * v4 + 3]));
              sub_14000D924(v7);
            }
          }
          v4 = (v4 + 1);
        }
        while ( v4 < *Buffer );
      }
      Get_ExFreePool(Buffer);
    }
  }
}

//----- (0000000140012A2C) ----------------------------------------------------
char __fastcall sub_140012A2C(_DWORD *a1)
{
  char v1; // bl
  char v2; // di
  __int64 v3; // rax
  __int64 v4; // rax
  unsigned __int64 v5; // rdi
  unsigned int v6; // edx
  unsigned __int64 v7; // r8
  char v8; // cl
  int v10[6]; // [rsp+20h] [rbp-40h]
  __int16 v11; // [rsp+38h] [rbp-28h]
  __int128 v12[2]; // [rsp+3Ah] [rbp-26h] BYREF

  v1 = 0;
  v2 = 0;
  if ( !a1 || *a1 != 233 )
    return 1;
  v3 = sub_14001EFB4();
  v4 = EAC_Get_User_Module(v3);
  if ( (sub_14001E6D4(v4) & 0x84000) != 0 )
  {
    v10[0] = -311598622;
    v11 = 3893;
    v5 = 24i64;
    v10[1] = 2038353031;
    v6 = -318217847;
    v10[2] = 2139393974;
    v10[3] = 85669312;
    v7 = 0i64;
    v10[4] = 721126537;
    v10[5] = -1057976835;
    memset(v12, 0, 26);
    do
    {
      *(v12 + v7 * 4) = v10[v7] ^ v6;
      ++v7;
      v6 = ~(((v6 ^ (v6 << 13)) >> 7) ^ v6 ^ (v6 << 13) ^ ((((v6 ^ (v6 << 13)) >> 7) ^ v6 ^ (v6 << 13)) << 17));
    }
    while ( v7 < 6 );
    do
    {
      v8 = v6;
      v6 >>= 8;
      *(v12 + v5) = *(v10 + v5) ^ v8;
      ++v5;
    }
    while ( v5 < 0x1A );
    v2 = 1;
    if ( EAC_Get_User_Module(v12) )
      v1 = 1;
  }
  if ( (v2 & 1) != 0 )
    memset(v12, 0, 0x1Aui64);
  return v1;
}
// 14001E6D4: using guessed type __int64 __fastcall sub_14001E6D4(_QWORD);
// 14001EFB4: using guessed type __int64 sub_14001EFB4(void);

//----- (0000000140012B78) ----------------------------------------------------
// from @Swiftik
void __fastcall EAC_CheckIfHooked(_DWORD *OpCode, __int64 Address)
{
  __int64 v2; // rbx
  __int128 v3; // [rsp+30h] [rbp-38h] BYREF
  __int128 v4; // [rsp+40h] [rbp-28h]
  __int128 v5; // [rsp+50h] [rbp-18h]

  if ( OpCode )
  {
    v3 = 0i64;
    v4 = 0i64;
    v5 = 0i64;
    if ( Address )
    {
      if ( *OpCode == 0xE9 )
      {
        if ( (loc_140053930)(-1i64, Address, 0i64, &v3, 48i64) )
        {
          v2 = *(&v3 + 1) + *(&v4 + 1);
          EAC_IsUsermodeValidAddress(*(&v3 + 1) + *(&v4 + 1) - 16i64, 16i64, 1);
          *(v2 - 16) = xmmword_14007D790;
        }
      }
    }
  }
}
// 14007D790: using guessed type __int128 xmmword_14007D790;

//----- (0000000140012BF0) ----------------------------------------------------
__m128 *__fastcall EAC_Allocate_ProcessVirtualMemory_Erase(__int64 ProcessId, unsigned int Size, char Protect)
{
  __m128 *Address; // rbx MAPDST
  __int64 ProcessHandle; // rax MAPDST
  __int64 Lenght; // r8
  __m128 *BaseAddress; // [rsp+50h] [rbp+8h] BYREF
  __int64 RegionSize; // [rsp+68h] [rbp+20h] BYREF

  if ( !ProcessId || !Size )
    return 0i64;

  BaseAddress = 0i64;
  Address = 0i64;
  ProcessId = Size;
  RegionSize = Size;
  ProcessHandle = EAC_Get_Process_Handle(ProcessId, 8u);
  if ( ProcessHandle )
  {
    if ( Get_NtAllocateVirtualMemory(ProcessHandle, &BaseAddress, 0i64, &RegionSize, 0x3000, Protect != 0 ? 64 : 4) >= 0 )
      Address = BaseAddress;
    Get_NtClose(ProcessHandle);
  }
  if ( Address )
  {
    if ( !EAC_Erase_ProcessMemory(ProcessId, Address, (ProcessId + 0xFFF) & 0xFFFFFFFFFFFFF000ui64) )
    {
      EAC_NtFreeVirtualMemory(ProcessId, Address, Lenght);
      return 0i64;
    }
  }
  return Address;
}
// 140012C9E: variable 'Lenght' is possibly undefined

//----- (0000000140012CC0) ----------------------------------------------------
char __fastcall sub_140012CC0(__int64 ProcessId, char *Address, char *Buffer, unsigned int Size)
{
  char v7; // bl
  PVOID Object; // [rsp+28h] [rbp-40h] BYREF
  _KAPC_STATE ApcState; // [rsp+30h] [rbp-38h] BYREF
  unsigned int v11; // [rsp+70h] [rbp+8h] BYREF

  v7 = 0;
  if ( !ProcessId || !Address || !Buffer )
    return 0;

  if ( Get_PsLookupProcessByProcessId(ProcessId, &Object) >= 0 )
  {
    if ( Get_KeStackAttachProcess(Object, &ApcState) )
    {
      EAC_IsUsermodeValidAddress(Address, Size, 1);
      if ( Get_ZwProtectVirtualMemory_2(Address, Size, 0x40u, &v11) )
      {
        sub_14001D338(Address, Size);
        EAC_memcpy(Address, Buffer, Size);
        v7 = 1;
        Get_ZwProtectVirtualMemory_2(Address, Size, v11, &v11);
      }
      (loc_140054154)(Object, &ApcState);       // KeUnstackDetachProcess
    }
    ObfDereferenceObject(Object);
  }
  return v7;
}

//----- (0000000140012DB8) ----------------------------------------------------
__int64 __fastcall MmVirtualMemory(__int64 SourceAddress, __int64 NumberOfBytes, __int64 TargetAddress)
{
  __int64 ReadfBytes; // [rsp+40h] [rbp+8h] BYREF

  ReadfBytes = 0i64;

  if ( SourceAddress && NumberOfBytes && TargetAddress )
    MmCopyMemory(TargetAddress, SourceAddress, NumberOfBytes, 2u, &ReadfBytes);

  return ReadfBytes;
}

//----- (0000000140012E00) ----------------------------------------------------
__int64 __fastcall MmVirtualMemory_Win7(unsigned __int64 SourceAddress, __int64 NumberOfBytes, __int64 TargetAddress)
{
  __int64 ret; // r14
  unsigned __int64 PointedTo; // r8
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rsi
  __int64 v9; // rcx
  unsigned __int64 v10; // rsi
  __int64 v11; // rbx
  unsigned int idx; // edi
  int v13; // eax
  __int64 v14; // r15
  __int64 v15; // rbp
  __int64 PhysicalAddress; // rax
  __int64 MappedIoSpace; // rax MAPDST
  unsigned __int64 v19; // rbp
  __int64 v21; // [rsp+20h] [rbp-48h]
  unsigned __int64 OldPointedTo; // [rsp+88h] [rbp+20h]

  ret = 0i64;
  if ( SourceAddress )
  {
    if ( NumberOfBytes )
    {
      if ( SourceAddress > MmSystemRangeStart )
      {
        if ( TargetAddress )
        {
          PointedTo = SourceAddress & 0xFFFFFFFFFFFFF000ui64;
          v7 = (SourceAddress + NumberOfBytes) & 0xFFFFFFFFFFFFF000ui64;
          OldPointedTo = SourceAddress & 0xFFFFFFFFFFFFF000ui64;
          v8 = SourceAddress + NumberOfBytes - (SourceAddress & 0xFFFFFFFFFFFFF000ui64) + 4095;
          v9 = SourceAddress - (SourceAddress & 0xFFFFFFFFFFFFF000ui64);
          v10 = v8 >> 12;
          v11 = NumberOfBytes + SourceAddress - v7;
          v21 = v9;
          idx = 0;
          if ( v10 )
          {
            v13 = v10 - 1;
            do
            {
              v14 = 0i64;
              if ( !idx )
                v14 = v9;

              if ( idx != v13 || (v15 = v11) == 0 )
                v15 = 0x1000i64;

              PhysicalAddress = Get_MmGetPhysicalAddress(PointedTo + (idx << 12));
              if ( PhysicalAddress )
              {
                MappedIoSpace = EAC_MmMapIoSpace(PhysicalAddress, 0x1000i64, 1u);
                if ( MappedIoSpace )
                {
                  v19 = v15 - v14;
                  EAC_memcpy((ret + TargetAddress), (v14 + MappedIoSpace), v19);
                  ret += v19;
                  Get_MmUnmapIoSpace(MappedIoSpace, 0x1000i64);
                }
              }

              PointedTo = OldPointedTo;
              ++idx;

              v13 = v10 - 1;
              v9 = v21;
            }
            while ( idx < v10 );
          }
        }
      }
    }
  }
  return ret;
}

//----- (0000000140012F34) ----------------------------------------------------
char __fastcall Get_MmProbeAndLockPages(__int64 a1)
{
  void (__fastcall *g_MmProbeAndLockPages)(__int64, _QWORD); // rax

  g_MmProbeAndLockPages = (loc_14005B768)(qword_140085D48, &qword_140085D48, 0i64);
  if ( g_MmProbeAndLockPages )
    g_MmProbeAndLockPages(a1, 0i64);            // MmProbeAndLockPages
  return 1;
}
// 140085D48: using guessed type __int64 qword_140085D48;

//----- (0000000140013088) ----------------------------------------------------
__int64 __fastcall EAC_Read_VirtualMemory(
        unsigned __int64 SourceAddress,
        unsigned __int64 NumberOfBytes,
        void *TargetAddress)
{
  __int64 ret; // rdi

  ret = 0i64;
  if ( SourceAddress && NumberOfBytes && SourceAddress > MmSystemRangeStart && TargetAddress )
  {
    memset(TargetAddress, 0, NumberOfBytes);
    if ( KUSER_SHARED_DATA.NtMajorVersion > 6
      || KUSER_SHARED_DATA.NtMajorVersion == 6 && KUSER_SHARED_DATA.NtMinorVersion == 3 )
    {
      return MmVirtualMemory(SourceAddress, NumberOfBytes, TargetAddress);
    }
    else
    {
      return MmVirtualMemory_Win7(SourceAddress, NumberOfBytes, TargetAddress);
    }
  }
  return ret;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (00000001400130F8) ----------------------------------------------------
__int64 __fastcall MmPhysicalMemory(__int64 SourceAddress, __int64 NumberOfBytes, __int64 TargetAddress)
{
  __int64 ReadfBytes; // [rsp+40h] [rbp+8h] BYREF

  ReadfBytes = 0i64;

  if ( SourceAddress && TargetAddress )
    MmCopyMemory(TargetAddress, SourceAddress, NumberOfBytes, 1u, &ReadfBytes);

  return ReadfBytes;
}

//----- (000000014001313C) ----------------------------------------------------
bool __fastcall sub_14001313C(__int64 a1, __int64 a2, __int64 a3)
{
  return MmPhysicalMemory(a1, 0x1000i64, a3) == 0x1000;
}

//----- (0000000140013158) ----------------------------------------------------
char __fastcall sub_140013158(__int64 Address, __int64 Size)
{
  unsigned __int64 StartAddress; // rbx
  unsigned __int64 FinalAddress; // rdi

  if ( !Address )
    return 0;

  StartAddress = Address & 0xFFFFFFFFFFFFF000ui64;
  FinalAddress = (Address + Size + 4095) & 0xFFFFFFFFFFFFF000ui64;
  while ( StartAddress < FinalAddress )
  {
    if ( !Get_MmIsAddressValid(StartAddress) )
      return 0;

    StartAddress += 0x1000i64;
  }
  return 1;
}

//----- (00000001400131AC) ----------------------------------------------------
char __fastcall sub_1400131AC(unsigned __int64 BaseAddress, __int64 *AllocateOut, DWORD *SizeOfImage)
{
  char ret; // bl
  char *Memory; // rax MAPDST
  _OWORD *Allocate; // rax
  unsigned int idx; // r12d
  char Value; // r14
  unsigned int *Size; // rdi
  _IMAGE_NT_HEADERS *NtHeaders; // [rsp+78h] [rbp+20h] MAPDST BYREF

  ret = 0;
  if ( !BaseAddress || !AllocateOut )
    return 0;

  *AllocateOut = 0i64;
  if ( SizeOfImage )
    *SizeOfImage = 0;

  Memory = EAC_Allocate_Memory(0x1000ui64);
  if ( Memory )
  {
    if ( EAC_Read_VirtualMemory(BaseAddress, 0x1000ui64, Memory) == 0x1000 )
    {
      if ( GetModuleInfo(Memory, 0x1000ui64, 0i64, &NtHeaders) )
      {
        Allocate = EAC_Allocate_Memory(NtHeaders->OptionalHeader.SizeOfImage);
        *AllocateOut = Allocate;
        if ( Allocate )
        {
          memset(Allocate, 0, NtHeaders->OptionalHeader.SizeOfImage);
          EAC_memcpy(Allocate, Memory, NtHeaders->OptionalHeader.SizeOfHeaders);

          idx = 0;
          if ( !NtHeaders->FileHeader.NumberOfSections )
            goto LABEL_17;

          Value = 0;
          Size = (&NtHeaders->OptionalHeader.SizeOfInitializedData + NtHeaders->FileHeader.SizeOfOptionalHeader);
          do
          {
            if ( (Size[7] & 0x2000000) == 0
              && EAC_Read_VirtualMemory(BaseAddress + Size[1], *Size, (Size[1] + *AllocateOut)) != *Size )
            {
              Value = 1;
            }
            Size += 10;
            ++idx;
          }
          while ( idx < NtHeaders->FileHeader.NumberOfSections );

          if ( Value == 0 )
          {
LABEL_17:
            if ( SizeOfImage )
              *SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
            ret = 1;
          }
          else
          {
            Get_ExFreePool(*AllocateOut);
            *AllocateOut = 0i64;
          }
        }
      }
    }
    Get_ExFreePool(Memory);
  }
  return ret;
}

//----- (0000000140013314) ----------------------------------------------------
__int64 __fastcall EAC_MmMapIoSpace(__int64 PhysicalAddress, __int64 NumberOfBytes, unsigned int CacheType)
{
  __int64 ret; // rsi
  unsigned int Type; // r8d
  int v8; // edi
  __int64 (__fastcall *g_MmMapIoSpace)(__int64, __int64, _QWORD); // rax

  ret = 0i64;
  Type = 4;
  if ( !PhysicalAddress || !NumberOfBytes )
    return 0i64;

  if ( KUSER_SHARED_DATA.NtMajorVersion >= 10 )
  {
    if ( !CacheType )
    {
      Type = 0x204;                             // MmNonCached
      return Get_MmMapIoSpace(PhysicalAddress, NumberOfBytes, Type);
    }

    v8 = CacheType - 1;
    if ( !v8 )
      return Get_MmMapIoSpace(PhysicalAddress, NumberOfBytes, Type);

    if ( v8 == 1 )
    {
      Type = 0x404;                             // MmCached
      return Get_MmMapIoSpace(PhysicalAddress, NumberOfBytes, Type);
    }
    return 0i64;
  }

  g_MmMapIoSpace = (loc_14005B768)(qword_140085D18, &qword_140085D18, 0i64);
  if ( g_MmMapIoSpace )
    return g_MmMapIoSpace(PhysicalAddress, NumberOfBytes, CacheType);// MmMapIoSpace

  return ret;
}
// 140085D18: using guessed type __int64 qword_140085D18;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (00000001400133B8) ----------------------------------------------------
__int64 EAC_sprintf_2(_WORD *Buffer, unsigned __int64 Size, __int64 Format, ...)
{
  unsigned __int64 sizeOfBuffer; // rdx
  unsigned int ret; // edi
  unsigned __int64 TotalSize; // rsi
  int Value; // eax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, Format);
  sizeOfBuffer = Size >> 1;
  if ( sizeOfBuffer - 1 <= 0x7FFFFFFE )
  {
    TotalSize = sizeOfBuffer - 1;
    ret = 0;
    Value = Get_vsprintf(Buffer, sizeOfBuffer - 1, Format, va);
    if ( Value < 0 || Value > TotalSize )
    {
      ret = 0x80000005;
    }
    else if ( Value != TotalSize )
    {
      return ret;
    }
    Buffer[TotalSize] = 0;
    return ret;
  }

  ret = 0xC000000D;
  if ( sizeOfBuffer )
    *Buffer = 0;

  return ret;
}

//----- (0000000140013E98) ----------------------------------------------------
__int64 __fastcall Get_vsprintf(__int64 buffer, __int64 SizeInBytes, __int64 MaxCount, __int64 format)
{
  __int64 (__fastcall *g__snprintf_s)(__int64, __int64, __int64, __int64); // rax
  __int64 result; // rax
  int v10[8]; // [rsp+20h] [rbp-20h] BYREF

  g__snprintf_s = qword_140086548;
  if ( qword_140086548
    || (v10[0] = 0x9B58656D,
        v10[1] = 0xDC8086E0,
        v10[2] = 0x866E5324,
        v10[3] = 0xD75EE7AC,
        v10[4] = 0x643FFC05,
        g__snprintf_s = (loc_14003CB4C)(v10),
        (qword_140086548 = g__snprintf_s) != 0) )
  {
    result = g__snprintf_s(buffer, SizeInBytes, MaxCount, format);// _snprintf_s
  }
  else
  {
    result = 0xFFFFFFFFi64;
  }
  if ( result < 0 )
    return 0xFFFFFFFFi64;

  return result;
}
// 140086548: using guessed type __int64 qword_140086548;

//----- (0000000140015FB0) ----------------------------------------------------
__int64 __fastcall sub_140015FB0(__int64 a1, __int64 a2)
{
  unsigned int v3; // eax

  v3 = (loc_140046234)();
  if ( v3 )
    sub_140009D88(qword_1400835E0, sub_140015FB0, a2, v3);
  return 246179091i64;
}
// 1400835E0: using guessed type __int64 qword_1400835E0;

//----- (0000000140016218) ----------------------------------------------------
__int64 __fastcall sub_140016218(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 result; // rax

  if ( !byte_140083595 )
    return sub_140009D88(qword_1400835D8, sub_140016218, a2, 30000i64);
  if ( dword_140083628 )
  {
    LOBYTE(a3) = 1;
    v3 = (loc_14005B768)(&unk_140083630, &loc_140026A44, a3);
    (loc_140026A44)(v3, dword_140083628);
  }
  result = 0i64;
  memset(&unk_140083630, 0, 0x2000ui64);
  return result;
}
// 140009D88: using guessed type __int64 __fastcall sub_140009D88(_QWORD, _QWORD, _QWORD, _QWORD);
// 140083595: using guessed type char byte_140083595;
// 1400835D8: using guessed type __int64 qword_1400835D8;
// 140083628: using guessed type int dword_140083628;

//----- (0000000140016288) ----------------------------------------------------
char __fastcall sub_140016288(__int64 a1)
{
  char v2; // si
  __int64 Memory; // rax
  PVOID *v4; // rbx
  unsigned int v5; // edi
  __int64 *v6; // r14
  __int64 v7; // rdi

  v2 = 0;
  Memory = EAC_Allocate_Memory(0x1000ui64);
  v4 = Memory;
  if ( Memory )
  {
    v5 = sub_140052F70(Memory);
    if ( v5 )
    {
      ObfDereferenceObject(*v4);
      if ( v5 > 1 )
      {
        v6 = (v4 + 1);
        v7 = v5 - 1;
        do
        {
          if ( !v2 && !sub_14000A0BC(a1) )
            v2 = sub_14004CBBC(*v6);
          ObfDereferenceObject(*v6++);
          --v7;
        }
        while ( v7 );
      }
    }
    Get_ExFreePool(v4);
  }
  return v2;
}

//----- (0000000140016330) ----------------------------------------------------
int __fastcall sub_140016330(__int64 a1)
{
  char v1; // di
  __int64 i; // rcx
  __int64 *v3; // rax
  __int64 *v4; // rbx

  v1 = sub_140016288(a1);
  for ( i = 0i64; ; i = v4 )
  {
    v3 = sub_14000D890(i);
    v4 = v3;
    if ( !v3 )
      break;
    if ( v1 )
      (loc_14004503C)(v3, 12i64);
  }
  return sub_140009D88(qword_1400835E0, sub_140016330, 0i64, 0x927C0u);
}
// 1400835E0: using guessed type __int64 qword_1400835E0;

//----- (0000000140016E18) ----------------------------------------------------
bool __fastcall sub_140016E18(_BYTE *a1, unsigned int a2, __int64 a3, __int64 a4, unsigned int *a5)
{
  unsigned int *v5; // rsi
  unsigned int *v6; // rbx
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rdi
  _BYTE *v10; // rax
  _BYTE *v11; // r10
  unsigned int v12; // r11d
  unsigned int v13; // eax

  v5 = a5;
  v6 = &unk_140073BA8;
  BYTE4(a5) = 0;
  v8 = a2;
  v9 = 0i64;
  while ( 1 )
  {
    LODWORD(a5) = v6[1];
    if ( v8 >= 4 )
    {
      v10 = sub_14005D868(a1, &a5, v8);
      if ( v10 )
      {
        if ( v8 + a1 - v10 >= *v6 && EAC_CRC32(v10, *v6, 0) == *(v6 - 2) && EAC_HashCR32(v11, v12) == *(v6 - 1) )
          break;
      }
    }
    v9 += 20i64;
    v6 += 5;
    if ( v9 >= 0x294 )
    {
      v13 = *v5;
      return v13 != 0;
    }
  }
  v13 = v6[2];
  *v5 = v13;
  return v13 != 0;
}
// 140016E95: variable 'v11' is possibly undefined
// 140016E95: variable 'v12' is possibly undefined

//----- (0000000140016EDC) ----------------------------------------------------
bool sub_140016EDC()
{
  bool v0; // bl
  int v1; // edx
  unsigned __int64 v2; // rdi
  __int64 v3; // rdx
  unsigned int *v4; // rax
  unsigned int *v5; // rsi
  unsigned __int64 v6; // r14
  _DWORD *v7; // r15
  unsigned __int32 v8; // edx
  unsigned __int64 v9; // rdi
  int v10; // ecx
  unsigned __int64 i; // rdi
  char v12; // cl
  char v13; // dl
  int v15[2]; // [rsp+20h] [rbp-49h]
  _BYTE v16[3]; // [rsp+28h] [rbp-41h] BYREF
  _BYTE v17[11]; // [rsp+2Bh] [rbp-3Eh] BYREF
  char v18[16]; // [rsp+38h] [rbp-31h] BYREF
  int v19[8]; // [rsp+48h] [rbp-21h]
  __int128 v20[5]; // [rsp+68h] [rbp-1h] BYREF
  PVOID Object; // [rsp+E0h] [rbp+77h] BYREF
  char v22; // [rsp+E8h] [rbp+7Fh] BYREF

  v19[0] = 1844777007;
  v19[1] = -1350914061;
  memset(v20, 0, 32);
  v19[2] = 375744233;
  v0 = 0;
  v19[3] = 974182097;
  v1 = -1321488081;
  v19[4] = 1939029699;
  v2 = 0i64;
  v19[5] = 1492414670;
  v19[6] = -20103240;
  v19[7] = 784886981;
  do
  {
    v1 = __ROR4__(214013 * v1 + 2531011, 4);
    *(v20 + v2 * 4) = v19[v2] ^ v1;
    ++v2;
  }
  while ( v2 < 8 );
  Get_Unicode_string_Inline(v18, v20);
  if ( sub_14000CCBC(v18, v3, &Object, &v22) >= 0 )
  {
    v4 = Get_System_Information();
    v5 = v4;
    if ( v4 )
    {
      v6 = 0i64;
      if ( *v4 )
      {
        v15[0] = 448556837;
        v7 = v4 + 2;
        v15[1] = 324962359;
        qmemcpy(v16, "2@^", sizeof(v16));
        while ( 1 )
        {
          v8 = 1222843491;
          v9 = 0i64;
          memset(v17, 0, sizeof(v17));
          do
          {
            v10 = v15[v9] ^ v8;
            v8 = _byteswap_ulong(1103515245 * v8 + 12345);
            *&v17[v9 * 4] = v10;
            ++v9;
          }
          while ( v9 < 2 );
          for ( i = 8i64; i < 0xB; ++i )
          {
            v12 = v8;
            v8 >>= 8;
            v17[i] = *(v15 + i) ^ v12;
          }
          v13 = sub_14005D784(v7 + *(v7 + 19) + 40, v17);
          memset(v17, 0, sizeof(v17));
          if ( v13 )
            break;
          ++v6;
          v7 += 74;
          if ( v6 >= *v5 )
            goto LABEL_15;
        }
        v0 = (v5[74 * v6 + 9] & 0x20) != 0;
      }
LABEL_15:
      Get_ExFreePool(v5);
    }
    ObfDereferenceObject(Object);
  }
  memset(v20, 0, 0x20ui64);
  return v0;
}
// 140016F91: variable 'v3' is possibly undefined
// 14000CCBC: using guessed type __int64 __fastcall sub_14000CCBC(_QWORD, _QWORD, _QWORD, _QWORD);
// 14005D29C: using guessed type __int64 __fastcall sub_14005D29C(_QWORD, _QWORD);
// 14005D784: using guessed type __int64 __fastcall sub_14005D784(_QWORD, _QWORD);

//----- (00000001400171D8) ----------------------------------------------------
__int64 __fastcall sub_1400171D8(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rsi
  void *Memory; // rdi
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rbp
  bool i; // cf
  DWORD TimeDateStamp; // ecx
  unsigned int ret; // [rsp+40h] [rbp+8h] BYREF
  IMAGE_NT_HEADERS *NtHeaders; // [rsp+48h] [rbp+10h] BYREF

  ret = 0;
  v3 = a2 & 0xFFFFFFFFFFFFF000ui64;
  if ( a1 < MmSystemRangeStart
    || (a1 & 0xFFFFFFFFFFFFF000ui64) != a1
    || !v3
    || ((qword_140083298 ^ a1) & 0xFFFFFFFF00000000ui64) != 0 )
  {
    return 0i64;
  }
  Memory = EAC_Allocate_Memory(0x1000ui64);
  if ( Memory )
  {
    v5 = a1 + v3;
    v6 = a1;
    for ( i = a1 < v5; i && !ret; i = v6 < v5 )
    {
      if ( EAC_Read_VirtualMemory(v6, 0x1000ui64, Memory) == 0x1000 )
      {
        sub_140060074(Memory, 0x1000i64, sub_140016E18, &ret);
        if ( v6 == a1 )
        {
          if ( GetModuleInfo(Memory, 0x1000ui64, 0i64, &NtHeaders) )
          {
            if ( NtHeaders->FileHeader.NumberOfSections == 7
              && NtHeaders->OptionalHeader.AddressOfEntryPoint == 0x9064
              && NtHeaders->OptionalHeader.SizeOfImage == 0xB000 )
            {
              TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
              if ( TimeDateStamp == 0x56F975FA || TimeDateStamp == 0x57089DA8 )
              {
                ret = 0;
                break;
              }
            }
          }
          if ( !ret )
            ret = (loc_1400170EC)(Memory);
        }
      }
      v6 += 0x1000i64;
    }
    Get_ExFreePool(Memory);
  }
  return ret;
}
// 140083298: using guessed type __int64 qword_140083298;

//----- (0000000140017338) ----------------------------------------------------
__int64 __fastcall sub_140017338(_BYTE *a1)
{
  unsigned int v1; // ebx
  int v3; // ebp
  _DWORD *v4; // r11
  __int64 v5; // rsi
  int v6; // eax

  v1 = 0;
  if ( !a1 )
    return 0i64;
  v3 = EAC_CRC32(a1, 0x14u, 0);
  v4 = &unk_140073A58;
  v5 = 26i64;
  do
  {
    if ( v3 == *(v4 - 1) )
    {
      v6 = EAC_HashCR32(a1, 20i64);
      if ( v6 == *v4 )
        v1 = *(v4 - 2);
    }
    v4 += 3;
    --v5;
  }
  while ( v5 );
  return v1;
}
// 140017380: variable 'v4' is possibly undefined
// 140007CA4: using guessed type __int64 __fastcall sub_140007CA4(_QWORD, _QWORD);

//----- (00000001400173B0) ----------------------------------------------------
__int64 __fastcall sub_1400173B0(unsigned __int64 BaseAddress, unsigned __int64 Size)
{
  unsigned int ret; // ebx
  bool Value; // bl
  __int64 Buffer; // rcx
  IMAGE_NT_HEADERS *NtHeaders; // [rsp+30h] [rbp+8h] MAPDST BYREF

  ret = 0;
  NtHeaders = 0i64;

  if ( !BaseAddress || !Size )
    return 0i64;

  if ( sub_140017ADC(BaseAddress, Size, &NtHeaders) )
  {
    ret = Get_Win32Version(&NtHeaders->OptionalHeader.ImageBase + 4);
    if ( ret == 23 )
    {
      Value = 0;
      if ( GetModuleInfo(BaseAddress, Size, 0i64, &NtHeaders) )
        Value = NtHeaders->FileHeader.TimeDateStamp >= 0x5F3DE56C;

      ret = !Value ? 0x17 : 0;
    }
    if ( NtHeaders )
    {
      Buffer = *&NtHeaders->FileHeader.TimeDateStamp;
      if ( Buffer )
      {
        Get_ExFreePool(Buffer);
        *&NtHeaders->Signature = 0i64;
      }
      EAC_Free_UnicodeString(&NtHeaders->FileHeader.NumberOfSymbols);
      Get_ExFreePool(NtHeaders);
    }
  }
  return ret;
}

//----- (000000014001747C) ----------------------------------------------------
__int64 __fastcall sub_14001747C(__int64 a1)
{
  __int64 result; // rax
  unsigned int v2; // edi
  __int128 v3; // xmm1
  __int64 v4; // rcx
  __int128 v5; // xmm0
  __int128 v6; // xmm1
  __int128 v7; // xmm0
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int128 v10; // xmm0
  __int64 v11; // rax
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  _OWORD v18[15]; // [rsp+20h] [rbp-108h] BYREF
  __int64 v19; // [rsp+110h] [rbp-18h]
  int v20; // [rsp+118h] [rbp-10h]
  __int16 v21; // [rsp+11Ch] [rbp-Ch]
  char v22; // [rsp+11Eh] [rbp-Ah]
  char v23; // [rsp+11Fh] [rbp-9h]
  unsigned int v24; // [rsp+130h] [rbp+8h] BYREF
  unsigned __int64 v25; // [rsp+138h] [rbp+10h] BYREF

  result = 0i64;
  v2 = 0;
  v25 = 0i64;
  v24 = 0;
  v23 = 0;
  if ( a1 )
  {
    v3 = *(a1 + 56);
    v4 = a1 + 40;
    v18[0] = *v4;
    v5 = *(v4 + 32);
    v18[1] = v3;
    v6 = *(v4 + 48);
    v18[2] = v5;
    v7 = *(v4 + 64);
    v18[3] = v6;
    v8 = *(v4 + 80);
    v18[4] = v7;
    v9 = *(v4 + 96);
    v18[5] = v8;
    v18[6] = v9;
    v10 = *(v4 + 112);
    v4 += 128i64;
    v18[7] = v10;
    v11 = *(v4 + 112);
    v12 = *(v4 + 16);
    v18[8] = *v4;
    v13 = *(v4 + 32);
    v18[9] = v12;
    v14 = *(v4 + 48);
    v18[10] = v13;
    v15 = *(v4 + 64);
    v18[11] = v14;
    v16 = *(v4 + 80);
    v18[12] = v15;
    v17 = *(v4 + 96);
    v18[13] = v16;
    v18[14] = v17;
    v19 = v11;
    v20 = *(v4 + 120);
    v21 = *(v4 + 124);
    v22 = *(v4 + 126);
    if ( sub_14002BC44(v18, &v25, &v24) )
    {
      v2 = sub_1400173B0(v25, v24);
      if ( v25 )
        Get_ExFreePool(v25);
    }
    return v2;
  }
  return result;
}
// 14002BC44: using guessed type __int64 __fastcall sub_14002BC44(_QWORD, _QWORD, _QWORD);
// 14001747C: using guessed type _OWORD var_108[15];

//----- (0000000140017594) ----------------------------------------------------
__int64 __fastcall sub_140017594(_OWORD *a1)
{
  unsigned int v2; // ebx
  unsigned int *System_Information; // rax
  unsigned int *v4; // rsi
  unsigned int v5; // ebp
  __int64 v6; // rdi
  unsigned __int64 v7; // r8
  char *v8; // rdx
  unsigned __int64 v9; // rcx
  __int64 v10; // r8
  char v11; // dl
  _BYTE *v12; // rax
  __int64 v13; // rcx

  v2 = 0;
  KeQueryTimeIncrement();
  System_Information = Get_System_Information();
  v4 = System_Information;
  if ( !System_Information )
    goto LABEL_32;
  v5 = 0;
  if ( *System_Information )
  {
    do
    {
      if ( v2 )
        break;
      v6 = &v4[74 * v5 + 2];
      v2 = sub_1400171D8(*(v6 + 0x10), *(v6 + 24));
      if ( v2 || (v2 = sub_14001747C(v6), v2 != 22) )
      {
        if ( v2 == 5 )
        {
          v9 = 0i64;
          v10 = v6 + *(v6 + 38);
          v11 = *(v10 + 40);
          v12 = (v10 + 40);
          if ( v11 )
          {
            do
            {
              ++v12;
              ++v9;
            }
            while ( *v12 );
            if ( v9 >= 0x10 && v11 == 112 )
            {
              v13 = 1i64;
              while ( (*(v13 + v10 + 40) - 48) <= 9u )
              {
                if ( ++v13 >= 0xC )
                {
                  v2 = 0;
                  break;
                }
              }
            }
          }
        }
      }
      else if ( v6 != -40 && a1 )
      {
        v7 = 0i64;
        v8 = (*(v6 + 38) + v6 + 40);
        if ( v8 )
        {
          do
          {
            if ( !v8[v7] )
              break;
            ++v7;
          }
          while ( v7 < 0x100 );
        }
        if ( v7 > 0x104 )
          v7 = 260i64;
        EAC_memcpy(a1, v8, v7);
      }
      ++v5;
    }
    while ( v5 < *v4 );
  }
  Get_ExFreePool(v4);
  if ( !v2 )
  {
LABEL_32:
    if ( sub_140016EDC() )
    {
      return 18;
    }
    else if ( sub_14002F304() )
    {
      return 7;
    }
  }
  return v2;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140017704) ----------------------------------------------------
__int64 __fastcall sub_140017704(char *Buffer, unsigned __int64 Lenght)
{
  __int64 v4; // rcx
  __int64 result; // rax
  int TimeStamp; // ecx
  unsigned int BufferOut; // [rsp+30h] [rbp+8h] BYREF
  __int64 NtHeaders; // [rsp+40h] [rbp+18h] BYREF

  BufferOut = 0;
  if ( !Buffer || !Lenght )
    return 0i64;

  sub_140060074(Buffer, Lenght, sub_140016E18, &BufferOut);

  result = BufferOut;
  if ( !BufferOut )
  {
    result = sub_14003D4A8(v4, Buffer, Lenght);
    BufferOut = result;
    if ( !result )
    {
      result = sub_1400173B0(Buffer, Lenght);
      BufferOut = result;
    }
  }
  if ( result == 9 )
  {
    if ( !GetModuleInfo(Buffer, 0x1000ui64, 0i64, &NtHeaders) )
      return BufferOut;

    if ( *(NtHeaders + 6) != 7 )
      return BufferOut;

    if ( *(NtHeaders + 0x28) != 0x9064 )
      return BufferOut;

    if ( *(NtHeaders + 0x50) != 0xB000 )
      return BufferOut;

    TimeStamp = *(NtHeaders + 8);
    if ( TimeStamp != 0x56F975FA && TimeStamp != 0x57089DA8 )
      return BufferOut;
    return 0i64;
  }
  return result;
}
// 14001774A: variable 'v4' is possibly undefined

//----- (00000001400177C8) ----------------------------------------------------
char __fastcall Scan_Threads(PETHREAD Thread, __m128 *a2, __m128 *a3)
{
  char ret; // si
  __m128 *Memory; // rax MAPDST
  __int64 v8; // rdx
  unsigned __int64 Thread_Info_Size; // rax
  unsigned __int64 v11; // rdx
  unsigned int i; // r15d
  unsigned __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v16; // [rsp+40h] [rbp-30h] BYREF
  char v17[8]; // [rsp+48h] [rbp-28h] BYREF
  char v18[8]; // [rsp+50h] [rbp-20h] BYREF
  int v19; // [rsp+58h] [rbp-18h] BYREF
  int v20; // [rsp+5Ch] [rbp-14h]
  int v21; // [rsp+60h] [rbp-10h]
  int v22; // [rsp+64h] [rbp-Ch]
  int v23; // [rsp+68h] [rbp-8h]
  unsigned __int64 v24; // [rsp+A0h] [rbp+30h] BYREF
  __int64 v25; // [rsp+B8h] [rbp+48h] BYREF

  ret = 0;
  if ( !Thread )
    return 0;
  if ( !a3 )
    return 0;
  EAC_memset(a2, 0, 0x4D0ui64);
  EAC_memset(a3, 0, 0x208ui64);
  if ( !g_RtlVirtualUnwind )
  {
    v19 = 0x83487E6B;
    v20 = 0x9DA9D8F6;
    v21 = 0x919EE1F1;
    v22 = 0x855A7572;
    v23 = 0x12C1A7F1;
    g_RtlVirtualUnwind = (loc_14003CB4C)(&v19);
    if ( !g_RtlVirtualUnwind )
      return 0;
  }
  if ( !g_RtlLookupFunctionEntry )
  {
    v19 = 0xCB2F7245;
    v20 = 0xC39D7FBB;
    v21 = 0xE3C8E809;
    v22 = 0x3B800577;
    v23 = 0x864FC5DE;
    g_RtlLookupFunctionEntry = (loc_14003CB4C)(&v19);
    if ( !g_RtlLookupFunctionEntry )
      return 0;
  }

  Memory = EAC_Allocate_Memory(0x2000ui64);
  if ( Memory )
  {
    Thread_Info_Size = EAC_Get_System_Thread_Info(Thread, v8, Memory);
    if ( Thread_Info_Size > 0x47 && Thread_Info_Size != 0x2000 )
    {
      if ( EAC_GetNtoskrnlSection(0x747865742Ei64, &v24, &v25) )
      {
        v11 = Memory[3].m128_u64[1];
        if ( v11 >= v24 && v11 < v25 + v24 )
        {
          a2[15].m128_u64[1] = v11;
          a2[9].m128_u64[1] = &Memory[4];
          ret = 1;
          for ( i = 0; i < 0x20; ++i )
          {
            a3[a3->m128_u32[0]].m128_u64[1] = v11;
            a3[a3->m128_i32[0]++ + 1].m128_u64[0] = a2[9].m128_u64[1];
            v13 = a2[15].m128_u64[1];
            if ( v13 < MmSystemRangeStart )
              break;

            if ( a2[9].m128_u64[1] < MmSystemRangeStart )
              break;

            v14 = g_RtlLookupFunctionEntry(v13, &v16, 0i64);// RtlLookupFunctionEntry
            if ( !v14 )
              break;

            g_RtlVirtualUnwind(0i64, v16, a2[15].m128_u64[1], v14, a2, v18, v17, 0i64);// RtlVirtualUnwind
            v11 = a2[15].m128_u64[1];
            if ( !v11 )
            {
              a3->m128_i8[4] = 1;
              break;
            }
          }
        }
      }
    }
    Get_ExFreePool(Memory);
  }
  return ret;
}
// 1400178C1: variable 'v8' is possibly undefined
// 140085630: using guessed type __int64 (__fastcall *g_RtlLookupFunctionEntry)(_QWORD, _QWORD, _QWORD);
// 140085638: using guessed type __int64 (__fastcall *g_RtlVirtualUnwind)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1400177C8: using guessed type char var_28[8];
// 1400177C8: using guessed type char var_20[8];

//----- (00000001400179F8) ----------------------------------------------------
char __fastcall sub_1400179F8(unsigned __int64 BaseAddress, unsigned int Size, unsigned __int64 *a3)
{
  char ret; // bl
  unsigned __int64 v6; // rbp
  _IMAGE_NT_HEADERS *Nt_Headers; // rcx
  __int64 v8; // rax
  _DWORD *v9; // rax
  unsigned int v10; // r8d
  unsigned int i; // edx
  unsigned __int64 v12; // rcx

  ret = 0;
  v6 = Size + BaseAddress;
  if ( !BaseAddress )
    return 0;

  if ( !Size )
    return 0;

  if ( !a3 )
    return 0;

  *a3 = 0i64;

  Nt_Headers = Get_Nt_Headers(BaseAddress, Size);
  if ( !Nt_Headers )
    return 0;

  v8 = 0x98i64;
  if ( Nt_Headers->OptionalHeader.Magic != 0x10B )
    v8 = 0xA8i64;

  v9 = (&Nt_Headers->Signature + v8);
  if ( !v9 )
    return 0;

  if ( v9 < BaseAddress )
    return 0;

  if ( v9 + 2 <= v9 )
    return 0;

  if ( (v9 + 2) > v6 )
    return 0;

  v10 = v9[1];
  if ( !v10 || !*v9 )
    return 0;

  for ( i = 0; i < v10; i += *v12 )
  {
    v12 = BaseAddress + *v9 + i;
    if ( v12 < BaseAddress || v12 + 0xC <= v12 || v12 + 0xC > v6 || !*v12 )
      break;
    if ( *(v12 + 6) == 2 )
    {
      *a3 = v12;
      return 1;
    }
  }
  return ret;
}
// 140017A88: conditional instruction was optimized away because r8d.4!=0

//----- (0000000140017ADC) ----------------------------------------------------
char __fastcall sub_140017ADC(unsigned __int64 BaseAddress, __int64 Size, __int64 *a3)
{
  char v3; // bl
  char *v7; // r14
  unsigned int v8; // esi
  char *v9; // rcx
  void *Memory; // rax
  void *v11; // r15
  __int128 v13; // [rsp+30h] [rbp-30h] BYREF
  __int128 v14; // [rsp+40h] [rbp-20h]
  __int64 v15; // [rsp+50h] [rbp-10h]
  _DWORD *v16; // [rsp+A0h] [rbp+40h] BYREF
  char *v17; // [rsp+B8h] [rbp+58h] BYREF

  v3 = 0;
  v16 = 0i64;
  if ( !BaseAddress || !Size || !a3 )
    return 0;
  *a3 = 0i64;

  if ( sub_1400179F8(BaseAddress, Size, &v16) )
  {
    v7 = (v16 + 2);
    v8 = *v16 - 8;
    if ( (v16 + 2) >= BaseAddress )
    {
      v9 = &v7[v8];
      if ( v9 > v7 && v9 <= BaseAddress + Size )
      {
        Memory = EAC_Allocate_Memory(0x48ui64);
        *a3 = Memory;
        v11 = Memory;
        if ( Memory )
        {
          v15 = 0i64;
          v17 = v7;
          LODWORD(v16) = v8;
          memset(Memory, 0, 0x48ui64);
          v13 = 0i64;
          v14 = 0i64;
          if ( v7
            && v8
            && (memset(Memory, 0, 0x48ui64), sub_14004803C(1, &v17, &v16, &v13))
            && v13 == 16
            && sub_14004803C(1, &v17, &v16, &v13)
            && v13 == 6
            && v14 == 9
            && **(&v13 + 1) == 0x7010DF78648862Ai64
            && *(*(&v13 + 1) + 8i64) == 2
            && sub_14004803C(1, &v17, &v16, &v13)
            && !v13
            && sub_14004803C(1, &v17, &v16, &v13)
            && v13 == 16
            && v14
            && sub_1400109F0(*(&v13 + 1), v14, v11) )
          {
            return 1;
          }
          else
          {
            Get_ExFreePool(*a3);
          }
        }
      }
    }
  }
  return v3;
}
// 1400109F0: using guessed type __int64 __fastcall sub_1400109F0(_QWORD, _QWORD, _QWORD);

//----- (0000000140017EE8) ----------------------------------------------------
LONG_PTR sub_140017EE8()
{
  LONG_PTR result; // rax

  g_EAC_ProcessIg = 0i64;
  qword_140083248 = 0i64;
  qword_140083250 = 0i64;
  qword_140083258 = 0i64;
  if ( g_Object )
  {
    result = ObfDereferenceObject(g_Object);
    g_Object = 0i64;
  }
  _InterlockedExchange(&dword_140083230, 0);
  return result;
}
// 140083230: using guessed type int dword_140083230;
// 140083238: using guessed type __int64 g_EAC_ProcessIg;
// 140083248: using guessed type __int64 qword_140083248;
// 140083250: using guessed type __int64 qword_140083250;
// 140083258: using guessed type __int64 qword_140083258;

//----- (0000000140018D70) ----------------------------------------------------
// from @Swiftik
void __stdcall ntoskrnl_Checks()
{
  unsigned __int64 StartAddress; // rax MAPDST
  unsigned __int64 Address; // rsi
  unsigned __int64 v3; // rdi
  __int64 Memory; // rax
  __int64 Buffer; // rbx
  unsigned __int64 v6; // r8
  int v7; // eax
  int v8; // r9d
  _BYTE *v9; // rdx
  char v10; // cl
  unsigned int v11; // r9d
  unsigned __int64 v12; // rcx
  int BuildNumber; // [rsp+30h] [rbp+8h] BYREF

  StartAddress = __readmsr(0xC0000082);
  Address = (StartAddress & 0xFFFFFFFFFFFFF000ui64) + 0xFF1;
  if ( KeGetCurrentIrql() <= 1u )
  {
    v3 = 0i64;
    if ( StartAddress )
    {
      if ( Check_ntoskrnl_Address(StartAddress) )
      {
        while ( StartAddress < Address
             && ((*StartAddress & 0xFFFFFF) != 0x158D4C
              || (*(StartAddress + 7) & 0xFFFFFF) != 0x1D8D4C
              || *(StartAddress + 0xE) != 0xF7
              || !Check_ntoskrnl_Address(*(StartAddress + 3) + StartAddress + 7)) )
          ++StartAddress;
      }
      else
      {
        BuildNumber = Get_BuildNumber();
        Memory = EAC_Allocate_Memory(0x8208ui64);
        Buffer = Memory;
        if ( Memory )
        {
          EAC_memset((Memory + 8), 0, 0x8200ui64);

          *Buffer = 0i64;
          *(Buffer + 8) = 0xDF3D27CD;
          v6 = 0x18i64;
          *(Buffer + 0xC) = 0x44D42E2C;
          *(Buffer + 0x10) = 0xE4C38803;
          *(Buffer + 0x18) = 0x837AE360;
          *(Buffer + 0x1C) = 0x6FB2F211;
          v7 = 0x23A77D4D * (&BuildNumber >> 2);
          v8 = v7 ^ 0x7990B03C;
          *(Buffer + 20) = v7 ^ 0x80912765;

          do
          {
            v9 = &BuildNumber + v3;
            v10 = v3++ & 3;
            ++v6;
            v11 = __ROL4__(1684061933 * v8 + 2138265961, 2);
            v9[Buffer + 8 - &BuildNumber + 24] = *v9 ^ (v11 >> (8 * v10));
            v8 = *v9 ^ v11;
          }
          while ( v3 < 4 );
          v12 = (v6 + 255) & 0xFFFFFFFFFFFFFF00ui64;
          while ( v6 < v12 )
          {
            v8 *= 0x23A77D4D;
            *(v6 + Buffer + 8) = BYTE1(v8);
            ++v6;
          }

          *(Buffer + 0x18) ^= v8;
          *(Buffer + 0x1C) ^= v3;
          *Buffer = v6;
          (loc_140016B54)(0x4158077Ai64, Buffer + 8);
          Get_ExFreePool(Buffer);
        }
      }
    }
  }
}

//----- (0000000140018F48) ----------------------------------------------------
char __fastcall sub_140018F48(int a1, __int64 a2, _QWORD *a3)
{
  unsigned __int64 v3; // r9
  unsigned int v4; // edi
  unsigned __int64 v5; // rcx
  __int128 *v6; // rdi
  int v7; // eax
  unsigned __int32 v8; // edx
  char v9; // dl
  __int64 v10; // xmm1_8
  unsigned int v11; // edx
  unsigned __int64 v12; // rdi
  int v13; // ecx
  char v14; // cl
  __int16 v15; // ax
  __int64 v16; // xmm1_8
  unsigned int v17; // edi
  unsigned __int64 v18; // rdx
  char v19; // cl
  int v20; // eax
  unsigned int v21; // edx
  int v22; // eax
  char result; // al
  int v24[3]; // [rsp+0h] [rbp-A9h]
  char v25; // [rsp+Ch] [rbp-9Dh]
  __int64 v26; // [rsp+10h] [rbp-99h] BYREF
  int v27; // [rsp+18h] [rbp-91h]
  char v28; // [rsp+1Ch] [rbp-8Dh]
  __m128i v29; // [rsp+20h] [rbp-89h]
  int v30; // [rsp+30h] [rbp-79h]
  int v31; // [rsp+34h] [rbp-75h]
  __int16 v32; // [rsp+38h] [rbp-71h]
  __m128i v33; // [rsp+3Ah] [rbp-6Fh]
  int v34; // [rsp+4Ah] [rbp-5Fh]
  int v35; // [rsp+4Eh] [rbp-5Bh]
  char v36; // [rsp+52h] [rbp-57h]
  __int128 v37; // [rsp+58h] [rbp-51h] BYREF
  int v38; // [rsp+68h] [rbp-41h]
  char v39; // [rsp+6Ch] [rbp-3Dh]
  __m128i si128; // [rsp+70h] [rbp-39h]
  int v41; // [rsp+80h] [rbp-29h]
  __int16 v42; // [rsp+84h] [rbp-25h]
  __int128 v43; // [rsp+88h] [rbp-21h] BYREF
  int v44; // [rsp+98h] [rbp-11h]
  __int16 v45; // [rsp+9Ch] [rbp-Dh]
  __m128i v46; // [rsp+A0h] [rbp-9h]
  int v47; // [rsp+B0h] [rbp+7h]
  char v48; // [rsp+B4h] [rbp+Bh]
  __int128 v49; // [rsp+B8h] [rbp+Fh] BYREF
  __int64 v50; // [rsp+C8h] [rbp+1Fh]
  char v51; // [rsp+D0h] [rbp+27h]
  __int128 v52; // [rsp+D8h] [rbp+2Fh] BYREF
  __int64 v53; // [rsp+E8h] [rbp+3Fh]
  __int16 v54; // [rsp+F0h] [rbp+47h]

  v3 = 0i64;
  if ( a3 )
  {
    memset(a3, 0, 0x80ui64);
    switch ( a1 )
    {
      case 0:
        v26 = 0i64;
        v21 = 1632371199;
        v27 = 0;
        v28 = 0;
        v24[0] = 319780517;
        v24[1] = -1752272584;
        v24[2] = 1445562961;
        v25 = 29;
        do
        {
          *(&v26 + v3 * 4) = v24[v3] ^ v21;
          ++v3;
          v21 = __ROL4__(
                  ((v21 ^ (v21 >> 7)) << 9) ^ v21 ^ (v21 >> 7) ^ ((((v21 ^ (v21 >> 7)) << 9) ^ v21 ^ (v21 >> 7)) >> 13),
                  2);
        }
        while ( v3 < 3 );
        v5 = 13i64;
        v6 = &v26;
        v28 = v25 ^ v21;
        v22 = v27;
        *a3 = v26;
        *(a3 + 2) = v22;
        *(a3 + 12) = v28;
        goto LABEL_24;
      case 1:
        v17 = -1760801025;
        v44 = 0;
        v18 = 20i64;
        v45 = 0;
        si128 = _mm_load_si128(xmmword_14007E6C0);
        v41 = 189951347;
        v42 = 29641;
        v43 = 0i64;
        do
        {
          *(&v43 + v3 * 4) = si128.m128i_i32[v3] ^ v17;
          ++v3;
          v17 = ~(((v17 ^ (v17 << 13)) >> 17) ^ v17 ^ (v17 << 13) ^ (32
                                                                   * (((v17 ^ (v17 << 13)) >> 17) ^ v17 ^ (v17 << 13))));
        }
        while ( v3 < 5 );
        do
        {
          v19 = v17;
          v17 >>= 8;
          *(&v43 + v18) = si128.m128i_i8[v18] ^ v19;
          ++v18;
        }
        while ( v18 < 0x16 );
        v20 = v44;
        v6 = &v43;
        v5 = 22i64;
        *a3 = v43;
        *(a3 + 4) = v20;
        *(a3 + 10) = v45;
        goto LABEL_24;
      case 2:
        v11 = -528101744;
        v53 = 0i64;
        v12 = 24i64;
        v54 = 0;
        v29 = _mm_load_si128(&xmmword_14007E650);
        v30 = -1834078609;
        v31 = 1111201138;
        v52 = 0i64;
        v32 = -31977;
        do
        {
          v13 = v29.m128i_i32[v3] ^ v11;
          v11 = __ROL4__(214013 * v11 + 2531011, 3);
          *(&v52 + v3 * 4) = v13;
          ++v3;
        }
        while ( v3 < 6 );
        do
        {
          v14 = v11;
          v11 >>= 8;
          *(&v52 + v12) = v29.m128i_i8[v12] ^ v14;
          ++v12;
        }
        while ( v12 < 0x1A );
        v6 = &v52;
        v15 = v54;
        v16 = v53;
        v5 = 26i64;
        *a3 = v52;
        a3[2] = v16;
        *(a3 + 12) = v15;
        goto LABEL_24;
      case 3:
        v8 = -1885272666;
        v50 = 0i64;
        v51 = 0;
        v33 = _mm_load_si128(xmmword_14007E6E0);
        v34 = 1258822288;
        v35 = 1825327644;
        v49 = 0i64;
        v36 = -65;
        do
        {
          *(&v49 + v3 * 4) = v33.m128i_i32[v3] ^ v8;
          ++v3;
          v8 = _byteswap_ulong(((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13) ^ (32
                                                                            * (((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13))));
        }
        while ( v3 < 6 );
        v5 = 25i64;
        v6 = &v49;
        v9 = v36 ^ v8;
        v51 = v9;
        v10 = v50;
        *a3 = v49;
        a3[2] = v10;
        *(a3 + 24) = v9;
        goto LABEL_24;
      case 4:
        v38 = 0;
        v4 = -1419355917;
        v39 = 0;
        v46 = _mm_load_si128(xmmword_14007E510);
        v47 = 1103387987;
        v48 = 122;
        v37 = 0i64;
        do
        {
          *(&v37 + v3 * 4) = v46.m128i_i32[v3] ^ v4;
          ++v3;
          v4 = ~(((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7) ^ ((((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7)) >> 13));
        }
        while ( v3 < 5 );
        v5 = 21i64;
        v39 = v48 ^ v4;
        v6 = &v37;
        v7 = v38;
        *a3 = v37;
        *(a3 + 4) = v7;
        *(a3 + 20) = v39;
LABEL_24:
        result = 1;
        memset(v6, 0, v5);
        return result;
    }
  }
  return 0;
}
// 14007E510: using guessed type __m128i xmmword_14007E510[6];
// 14007E650: using guessed type __int128 xmmword_14007E650;
// 14007E6C0: using guessed type __m128i xmmword_14007E6C0[2];
// 14007E6E0: using guessed type __m128i xmmword_14007E6E0[2];

//----- (0000000140019380) ----------------------------------------------------
char __fastcall sub_140019380(unsigned __int64 a1, _DWORD *a2)
{
  __int64 v4; // rax
  int ProcessWow64Process; // ebp
  unsigned __int8 v6; // cl
  unsigned __int64 v7; // rsi
  char v9[24]; // [rsp+20h] [rbp-58h] BYREF
  int v10; // [rsp+38h] [rbp-40h]
  char v11[33]; // [rsp+40h] [rbp-38h] BYREF
  int v12; // [rsp+61h] [rbp-17h]

  v4 = Get_PsGetCurrentProcess();
  ProcessWow64Process = Get_PsGetProcessWow64Process(v4);
  if ( a1 && a2 )
  {
    v6 = 0;
    v7 = a1 + 64;
    while ( a1 < v7 )
    {
      if ( ProcessWow64Process == 64 )
      {
        if ( !sub_1400210C8(a1, v11) || (v12 & 0x1000) != 0 )
          return 0;
        v6 = v11[0];
      }
      else if ( ProcessWow64Process == 32 )
      {
        if ( !sub_14004973C(a1, v9) || (v10 & 0x1000) != 0 )
          return 0;
        v6 = v9[0];
      }
      if ( v6 == 5 && *a1 == 0xB8 )
      {
        *a2 = *(a1 + 1);
        return 1;
      }
      a1 += v6;
    }
  }
  return 0;
}
// 14004973C: using guessed type __int64 __fastcall sub_14004973C(_QWORD, _QWORD);
// 140019380: using guessed type char var_38[33];
// 140019380: using guessed type char var_58[24];

//----- (000000014001943C) ----------------------------------------------------
__int64 __fastcall sub_14001943C(unsigned __int8 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // rax
  int ProcessWow64Process; // eax
  unsigned int v7; // r13d
  char v8; // r12
  unsigned __int8 v10; // bl
  unsigned __int8 v11; // si
  unsigned __int64 v12; // rdi
  unsigned __int8 *v13; // r14
  int v14; // ebp
  __int16 v15; // ax
  bool v16; // zf
  unsigned __int8 *v17; // rdx
  unsigned __int8 v18; // r8
  unsigned __int8 v19; // al
  bool v20; // zf
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  bool v24; // zf
  bool v25; // zf
  int v26; // ecx
  unsigned __int8 v27; // cl
  unsigned __int8 *v28; // rax
  __int16 v29; // cx
  char v30[24]; // [rsp+20h] [rbp-88h] BYREF
  int v31; // [rsp+38h] [rbp-70h]
  char v32[33]; // [rsp+40h] [rbp-68h] BYREF
  int v33; // [rsp+61h] [rbp-47h]

  v5 = Get_PsGetCurrentProcess();
  ProcessWow64Process = Get_PsGetProcessWow64Process(v5);
  v7 = 0;
  v8 = 0;
  if ( !a1 )
    return 0i64;
  v10 = 0;
  v11 = 0;
  v12 = &a1[a2];
  v13 = a1;
  v14 = ProcessWow64Process;
  while ( v13 < v12 )
  {
    if ( v14 != 64 )
    {
      if ( v14 != 32 )
        goto LABEL_28;
      if ( !sub_14004973C(v13, v30) )
        break;
      v15 = v31;
      if ( (v31 & 0x1000) != 0 )
        break;
      v11 = v30[0];
      if ( (v31 & 0x200) != 0 )
      {
        if ( (v31 & 4) != 0 )
          goto LABEL_22;
        if ( (v31 & 8) != 0 )
          goto LABEL_24;
        v16 = (v31 & 0x10) == 0;
      }
      else
      {
LABEL_21:
        if ( (v15 & 0x40) != 0 )
        {
LABEL_22:
          v10 = v11 - 1;
          goto LABEL_28;
        }
        if ( (v15 & 0x80u) != 0 )
        {
LABEL_24:
          v10 = v11 - 2;
          goto LABEL_28;
        }
        v16 = (v15 & 0x100) == 0;
      }
      v10 = v11;
      if ( v16 )
        goto LABEL_28;
LABEL_27:
      v10 = v11 - 4;
      goto LABEL_28;
    }
    if ( !sub_1400210C8(v13, v32) )
      goto LABEL_66;
    v15 = v33;
    if ( (v33 & 0x1000) != 0 )
      goto LABEL_66;
    v11 = v32[0];
    if ( (v33 & 0x200) == 0 )
      goto LABEL_21;
    if ( (v33 & 4) != 0 )
      goto LABEL_22;
    if ( (v33 & 8) != 0 )
      goto LABEL_24;
    if ( (v33 & 0x10) != 0 )
      goto LABEL_27;
    v10 = v32[0];
    if ( (v33 & 0x20) != 0 )
      v10 = v32[0] - 8;
LABEL_28:
    if ( v10 )
      v7 = EAC_CRC32(v13, v10, v7);
    v17 = v13;
    if ( !v13 )
      goto LABEL_67;
    v18 = *v13;
    v19 = *v13;
    if ( *v13 >= 0x40u && v18 <= 0x4Fu )
    {
      v17 = v13 + 1;
      v19 = v13[1];
    }
    if ( v19 <= 0x7Au )
    {
      if ( v19 == 122 )
        goto LABEL_66;
      if ( v19 <= 0x74u )
      {
        if ( v19 == 116 )
          goto LABEL_66;
        if ( v19 == 15 )
        {
          if ( (v17[1] + 0x80) > 0xFu )
            goto LABEL_60;
          goto LABEL_66;
        }
        v21 = v19 - 112;
        v20 = v19 == 112;
        goto LABEL_40;
      }
      v26 = v19 - 117;
      v25 = v19 == 117;
LABEL_47:
      if ( v25 )
        goto LABEL_66;
      v21 = v26 - 1;
      v20 = v21 == 0;
LABEL_40:
      if ( v20 )
        goto LABEL_66;
      v22 = v21 - 1;
      if ( !v22 )
        goto LABEL_66;
      v23 = v22 - 1;
      if ( !v23 )
        goto LABEL_66;
      v24 = v23 == 1;
      goto LABEL_59;
    }
    if ( v19 <= 0xE3u )
    {
      if ( v19 == 227 )
        goto LABEL_66;
      v26 = v19 - 123;
      v25 = v19 == 123;
      goto LABEL_47;
    }
    if ( v19 == 233 || v19 == 234 || v19 == 235 )
      goto LABEL_66;
    if ( v19 != 255 )
      goto LABEL_60;
    v27 = v17[1];
    if ( ((v27 - 37) & 0xF7) == 0 )
      goto LABEL_66;
    if ( ((v27 - 36) & 0xF7) != 0 )
      goto LABEL_60;
    v24 = ((v17[2] + 27) & 0x3F) == 0;
LABEL_59:
    if ( !v24 )
    {
LABEL_60:
      v28 = v13;
      if ( (v18 - 64) <= 0xFu )
        v28 = v13 + 1;
      v29 = *v28;
      if ( *v28 != 1807 && v29 != 13583 && (v29 + 62) > 1u && (v29 + 54) > 5u )
        goto LABEL_67;
    }
LABEL_66:
    v8 = 1;
LABEL_67:
    v13 += v11;
    if ( v8 )
      break;
  }
  if ( a3 )
    *a3 = v13 - a1;
  return v7;
}
// 14004973C: using guessed type __int64 __fastcall sub_14004973C(_QWORD, _QWORD);
// 14001943C: using guessed type char var_68[33];
// 14001943C: using guessed type char var_88[24];

//----- (0000000140019DA8) ----------------------------------------------------
char sub_140019DA8()
{
  char v0; // bl
  __int64 v1; // rax
  __int64 v2; // r14
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // r15
  __int64 v7; // r12
  __int64 v8; // rax
  __int64 Memory; // rax
  __int64 v10; // rdi
  int v12; // [rsp+20h] [rbp-20h] BYREF
  int v13; // [rsp+24h] [rbp-1Ch]
  int v14; // [rsp+28h] [rbp-18h]
  int v15; // [rsp+2Ch] [rbp-14h]
  int v16; // [rsp+30h] [rbp-10h]

  v12 = -825024639;
  v0 = 0;
  v13 = 2097833677;
  v14 = 1355939634;
  v15 = -178154794;
  v16 = -1206614498;
  v1 = (loc_14003CB4C)(&v12);
  v12 = 1540406161;
  v2 = v1;
  v13 = -1963014191;
  v14 = 317384544;
  v15 = -323377466;
  v16 = -1671286033;
  v3 = (loc_14003CB4C)(&v12);
  v12 = 1721926307;
  v4 = v3;
  v13 = -770610160;
  v14 = -1365801869;
  v15 = -1963943786;
  v16 = 662017267;
  v5 = (loc_14003CB4C)(&v12);
  v6 = (loc_140019CE0)(1i64);
  v7 = (loc_140019CE0)(2i64);
  v8 = (loc_140019CE0)(0i64);
  if ( v2 && v4 && v5 && v5 == v7 && v2 == v6 && v4 == v8 )
    return 1;
  Memory = EAC_Allocate_Memory(0x8208ui64);
  v10 = Memory;
  if ( Memory )
  {
    EAC_memset((Memory + 8), 0, 0x8200ui64);
    *(v10 + 8) = -694122234;
    *(v10 + 12) = -2111592970;
    *(v10 + 16) = -1168599208;
    *(v10 + 20) = 548383193;
    *(v10 + 24) = 1476975862;
    *(v10 + 28) = 1223410033;
    *v10 = 24i64;
    (loc_140016B54)(821084367i64, v10 + 8, 24i64);
    Get_ExFreePool(v10);
  }
  return v0;
}

//----- (000000014001A460) ----------------------------------------------------
void sub_14001A460()
{
  if ( byte_140083597 )
  {
    if ( qword_140085690 )
    {
      sub_140023184(qword_140085690);
      qword_140085690 = 0i64;
    }
    byte_140083597 = 0;
  }
  if ( byte_140085688 )
  {
    if ( qword_140085698 )
    {
      sub_140023184(qword_140085698);
      qword_140085698 = 0i64;
    }
    byte_140085688 = 0;
  }
}
// 140083597: using guessed type char byte_140083597;
// 140085688: using guessed type char byte_140085688;

//----- (000000014001AB0C) ----------------------------------------------------
__int64 sub_14001AB0C()
{
  __int64 v0; // rax
  __int64 v1; // r8
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 v4; // rax
  __int64 v5; // r8
  unsigned int v6; // eax
  int v7; // r11d
  __int64 result; // rax
  int v9; // [rsp+20h] [rbp-20h] BYREF
  int v10; // [rsp+24h] [rbp-1Ch]
  int v11; // [rsp+28h] [rbp-18h]
  int v12; // [rsp+2Ch] [rbp-14h]
  int v13; // [rsp+30h] [rbp-10h]

  dword_1400856B0 = sub_14003EEF8();
  v9 = 0xE00C9209;
  v10 = -1557243020;
  v11 = -1763462318;
  v12 = 112234731;
  v13 = -1167515093;
  v0 = (loc_14003CB4C)(&v9);
  LOBYTE(v1) = 1;
  qword_1400856B8 = (loc_14005B768)(v0, &qword_1400856B8, v1);
  v9 = -1980715155;
  v10 = 1923740328;
  v11 = -1669466867;
  v12 = -2067659638;
  v13 = -7982577;
  v2 = (loc_14003CB4C)(&v9);
  LOBYTE(v3) = 1;
  qword_1400856C0 = (loc_14005B768)(v2, &qword_1400856C0, v3);
  v9 = 180328763;
  v10 = -1919528409;
  v11 = 647420263;
  v12 = -1611806626;
  v13 = -1693355423;
  v4 = (loc_14003CB4C)(&v9);
  LOBYTE(v5) = 1;
  qword_1400856C8 = (loc_14005B768)(v4, &qword_1400856C8, v5);
  v6 = EAC_HashCR32(&dword_1400856B0, 0x20u);
  result = -490119821 * (v7 ^ v6);
  dword_1400856D0 = result;
  return result;
}
// 14001AB59: variable 'v1' is possibly undefined
// 14001AB9E: variable 'v3' is possibly undefined
// 14001ABE3: variable 'v5' is possibly undefined
// 14001AC03: variable 'v7' is possibly undefined
// 1400856B0: using guessed type int dword_1400856B0;
// 1400856B8: using guessed type __int64 qword_1400856B8;
// 1400856C0: using guessed type __int64 qword_1400856C0;
// 1400856C8: using guessed type __int64 qword_1400856C8;
// 1400856D0: using guessed type int dword_1400856D0;

//----- (000000014001AC5C) ----------------------------------------------------
__int64 __fastcall sub_14001AC5C(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 (__fastcall *v6)(__int64, _QWORD, __int64); // rax

  v6 = (loc_14005B768)(qword_1400856B8, &qword_1400856B8, 0i64);
  if ( v6 )
    return v6(a1, a2, a3);
  else
    return 0xC0000002i64;
}
// 1400856B8: using guessed type __int64 qword_1400856B8;

//----- (000000014001AEE8) ----------------------------------------------------
__int64 __fastcall EAC_Allocate_Memory(unsigned __int64 Size)
{
  int g_Seed; // eax

  g_Seed = EAC_Generate_Seed(0, 45);
  return Get_ExAllocatePoolWithTag(Size, *&aClfcclficlfocl[4 * g_Seed]);
}

//----- (000000014001AF18) ----------------------------------------------------
void *__fastcall EAC_Allocate_Memory_2(__int64 UnsafeNumberOfBytes, __int64 Size)
{
  int v4; // eax
  unsigned __int64 NumberOfBytes; // rbx
  void *result; // rax

  v4 = EAC_Generate_Seed(0, 45);
  NumberOfBytes = Size * UnsafeNumberOfBytes;
  result = Get_ExAllocatePoolWithTag(NumberOfBytes, *&aClfcclficlfocl[4 * v4]);
  if ( result )
    memset(result, 0, NumberOfBytes);

  return result;
}

//----- (000000014001AF6C) ----------------------------------------------------
__int64 __fastcall Get_ExAllocatePoolWithTag(unsigned __int64 Size, unsigned int Tag)
{
  __int64 (__fastcall *g_ExAllocatePoolWithTag)(__int64, unsigned __int64, _QWORD); // r9
  unsigned __int64 NumberOfBytes; // r14
  __int64 v4; // rdi
  __int64 PoolType; // rcx
  __int64 v9; // rax
  _DWORD *v10; // rdx
  _DWORD *v11; // rcx
  volatile signed __int32 *v12; // rax
  int v13[5]; // [rsp+20h] [rbp-30h] BYREF
  int v14[7]; // [rsp+34h] [rbp-1Ch] BYREF

  g_ExAllocatePoolWithTag = g_ExAllocatePool;
  NumberOfBytes = Size + 0x10;
  v4 = 0i64;
  if ( !g_ExAllocatePool )
  {
    v13[0] = 0xB2EDA0AC;
    v13[1] = 0x6596CDF1;
    v13[2] = 0xD2A50DA9;
    v13[3] = 0x8DC2637F;
    v13[4] = 0xE905487C;

    g_ExAllocatePool = (loc_14003CB4C)(v13);
    g_ExAllocatePoolWithTag = g_ExAllocatePool;

    if ( !g_ExAllocatePool )
      return 0i64;
  }
  if ( !g_ExFreePoolWithTag )
  {
    v14[0] = 0xB953F283;
    v14[1] = 0xC0A8DBB0;
    v14[2] = 0xACC9AFBA;
    v14[3] = 0xAF748B31;
    v14[4] = 0x2DA312FD;

    g_ExFreePoolWithTag = (loc_14003CB4C)(v14);
    if ( !g_ExFreePoolWithTag )
      return 0i64;

    g_ExAllocatePoolWithTag = g_ExAllocatePool;
  }
  if ( Size && NumberOfBytes > Size && Tag )
  {
    if ( KUSER_SHARED_DATA.NtMajorVersion > 6
      || KUSER_SHARED_DATA.NtMajorVersion == 6 && KUSER_SHARED_DATA.NtMinorVersion - 2 <= 1 )
    {
      PoolType = 0x200i64;
    }
    else
    {
      PoolType = 0i64;
    }
    v9 = g_ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);// ExAllocatePoolWithTag
    v4 = v9;
    if ( v9 )
    {
      *v9 = Tag;
      *(v9 + 8) = Size;
    }
    _InterlockedIncrement(&dword_1400856AC);
    _InterlockedExchangeAdd(&dword_1400856E8, Size);

    v10 = &unk_140085700;
    if ( v9 )
      v10 = &unk_1400856F8;

    v11 = &unk_140085704;
    if ( v9 )
      v11 = &unk_1400856FC;

    v12 = &unk_1400856F4;
    if ( v4 )
      v12 = &unk_1400856F0;

    _InterlockedIncrement(v12);

    if ( !*v10 || *v10 > Size )
      *v10 = Size;
    if ( *v11 < Size )
      *v11 = Size;
  }
  return (v4 + 0x10) & -(v4 != 0);
}
// 1400856AC: using guessed type int dword_1400856AC;
// 1400856D8: using guessed type __int64 g_ExAllocatePool;
// 1400856E0: using guessed type __int64 (__fastcall *qword_1400856E0)(_QWORD, _QWORD);
// 1400856E8: using guessed type int dword_1400856E8;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014001B10C) ----------------------------------------------------
__int64 __fastcall Get_ExFreePool(__int64 Buffer)
{
  __int64 result; // rax

  if ( Buffer )
  {
    _InterlockedExchangeAdd(&dword_1400856E8, -*(Buffer - 8));
    _InterlockedDecrement(&dword_1400856AC);
    return g_ExFreePoolWithTag(Buffer - 0x10, *(Buffer - 0x10));
  }
  return result;
}
// 1400856AC: using guessed type int dword_1400856AC;
// 1400856E0: using guessed type __int64 (__fastcall *g_ExFreePoolWithTag)(_QWORD, _QWORD);
// 1400856E8: using guessed type int dword_1400856E8;

//----- (000000014001B13C) ----------------------------------------------------
__int64 EAC_sprintf(UNICODE_STRING *unicode_string, __int64 format, ...)
{
  USHORT Length; // cx
  unsigned __int64 MaximumLength; // rax
  unsigned int ret; // ebx
  unsigned __int64 v6; // rsi
  int Value; // eax
  va_list va; // [rsp+50h] [rbp+18h] BYREF

  va_start(va, format);
  Length = unicode_string->Length;
  if ( (Length & 1) != 0 )
    return 0xC000000D;

  MaximumLength = unicode_string->MaximumLength;
  if ( (MaximumLength & 1) != 0 )
    return 0xC000000D;

  if ( Length > MaximumLength )
    return 0xC000000D;

  if ( MaximumLength == 0xFFFF )
    return 0xC000000D;

  ret = 0;
  if ( !unicode_string->Buffer && (Length || MaximumLength) )
  {
    return 0xC000000D;
  }
  else
  {
    v6 = MaximumLength >> 1;
    Value = Get_vsprintf(unicode_string->Buffer, MaximumLength >> 1, format, va);
    if ( Value < 0 || Value > v6 )
    {
      LOWORD(Value) = v6;
      ret = 0x80000005;
    }
    unicode_string->Length = 2 * Value;
  }
  return ret;
}

//----- (000000014001B1D0) ----------------------------------------------------
bool sub_14001B1D0()
{
  char v1; // [rsp+20h] [rbp-60h]
  int v2[6]; // [rsp+30h] [rbp-50h] BYREF
  int v3[13]; // [rsp+48h] [rbp-38h] BYREF
  __int16 v4; // [rsp+7Ch] [rbp-4h]
  char v5; // [rsp+7Eh] [rbp-2h]
  __int64 v6; // [rsp+90h] [rbp+10h] BYREF
  __int64 v7; // [rsp+98h] [rbp+18h] BYREF

  v3[0] = 0x245C8948;
  v3[1] = 0x81485710;
  v3[2] = 0x110EC;
  v3[3] = 0x58B4800;
  v3[4] = 0xAAAAAAAA;
  v3[5] = 0x48C43348;
  v3[6] = 0x248489;
  v3[7] = 0x48000001;
  v3[8] = 0x5824948B;
  v3[9] = 0x4C000001;
  v3[10] = 0x6024948B;
  v3[11] = 0x48000001;
  v3[12] = 0x6824BC8B;
  v4 = 1;
  v5 = 0;
  v2[0] = 0xADEC6386;
  v2[1] = 0x5DA98780;
  v2[2] = 0xC82F5C53;
  v2[3] = 0xE7CD3D8A;
  v2[4] = 0x2359FE88;

  g_RtlCreateUserThread = (loc_14003CB4C)(v2);
  if ( g_RtlCreateUserThread )
    return 1;

  if ( Get_BuildNumber() != 7601 || !EAC_GetNtoskrnlSection(0x45474150i64, &v7, &v6) )
    return 0;

  v1 = 170;
  g_RtlCreateUserThreadEx = (loc_1400328D0)(v7, v6, v3, 0x37i64, v1);
  return g_RtlCreateUserThreadEx != 0i64;
}
// 140085940: using guessed type __int64 (__fastcall *g_RtlCreateUserThread)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140085948: using guessed type __int64 (__fastcall *qword_140085948)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014001B2D4) ----------------------------------------------------
__int64 __fastcall EAC_CreateUserThread(OBJECT_ATTRIBUTES *Object, char Flag)
{
  int Status; // esi MAPDST
  __int64 ProcessHandle; // rcx
  __int64 unknown; // r8
  struct_EAC_Memory_Data *VirtualMemory; // rax
  struct_EAC_Memory_Data *EAC_Memory_Data; // r14
  __int64 ModuleName_1; // rax
  __int64 User_Module; // r11
  char v12; // r12
  _BYTE *v13; // rax
  ULONG64 BaseModule; // r11
  __int64 Module; // rax
  unsigned int v17; // eax
  __int64 Status_2; // [rsp+60h] [rbp-1A8h] BYREF
  int v19; // [rsp+68h] [rbp-1A0h]
  int v20; // [rsp+6Ch] [rbp-19Ch]
  int v21[3]; // [rsp+70h] [rbp-198h] BYREF
  char v22; // [rsp+7Ch] [rbp-18Ch]
  int Data[6]; // [rsp+7Eh] [rbp-18Ah] BYREF
  __int16 v24; // [rsp+96h] [rbp-172h]
  struct_EAC_Memory_Data *v25; // [rsp+98h] [rbp-170h]
  UNICODE_STRING unicode_string; // [rsp+A0h] [rbp-168h] BYREF
  char v27[12]; // [rsp+B0h] [rbp-158h] BYREF
  char v28[14]; // [rsp+BCh] [rbp-14Ch] BYREF
  char v29[30]; // [rsp+CAh] [rbp-13Eh] BYREF
  int ThreadInfo[12]; // [rsp+E8h] [rbp-120h] BYREF
  _KAPC_STATE ApcState; // [rsp+118h] [rbp-F0h] BYREF
  char ModuleName[184]; // [rsp+150h] [rbp-B8h] BYREF
  HANDLE Handle; // [rsp+228h] [rbp+20h] BYREF

  Status = 0xC0000001;
  LODWORD(Status_2) = 0xC0000001;
  v25 = 0i64;

  if ( !EAC_Copy_Unicode_from_Unicode(&Object->ObjectName, &unicode_string) )
    return 0xC000000Di64;

  if ( Get_KeStackAttachProcess(*&Object->Length, &ApcState) )
  {
    VirtualMemory = EAC_Allocate_ProcessVirtualMemory(ProcessHandle, 0x1000i64, unknown, 0x40);
    EAC_Memory_Data = VirtualMemory;
    v25 = VirtualMemory;
    if ( !VirtualMemory )
      goto LABEL_30;

    sub_14001D338(VirtualMemory, 0x1000i64);

    EAC_Memory_Data->oword0 = xmmword_14006D620;
    EAC_Memory_Data->oword10 = xmmword_14006D630;
    EAC_Memory_Data->oword20 = xmmword_14006D640;
    EAC_Memory_Data->oword30 = xmmword_14006D650;

    Data[0] = 0xD02EF8C;
    Data[1] = 0x88982795;
    Data[2] = 0x99652182;
    Data[3] = 0xAE5B7954;
    Data[4] = 0xA9217829;
    Data[5] = 0xA7BBD2D3;
    v24 = 0x9A19;

    ModuleName_1 = EAC_Get_Module_Name(Data, v29);
    User_Module = EAC_Get_User_Module(ModuleName_1);
    memset(v29, 0, 0x1Aui64);

    if ( !User_Module )
      goto LABEL_30;

    if ( Flag )
    {
      v21[0] = 0xA173F31E;
      v21[1] = 0xC1FC7B59;
      v21[2] = 0xCF5B86EF;
      v22 = 24;
      v12 = 1;
      v13 = sub_14001B718(v21, v28);
    }
    else
    {
      HIDWORD(Status_2) = 0x738489F0;
      v19 = 0xAFB5A6EF;
      v20 = 0x74C8F4DB;
      v12 = 2;
      v13 = sub_14001B794(&Status_2 + 4, v27);
    }
    EAC_Memory_Data->StartParameter = sub_14001DA84(BaseModule, v13);
    if ( (v12 & 2) != 0 )
    {
      v12 &= ~2u;
      memset(v27, 0, sizeof(v27));
    }
    if ( (v12 & 1) != 0 )
      memset(v28, 0, 0xDui64);

    if ( !EAC_Memory_Data->StartParameter )
      goto LABEL_30;

    if ( Flag )
    {
      EAC_Memory_Data->ModuleName = &EAC_Memory_Data->Buffer;
      EAC_memcpy(&EAC_Memory_Data->Buffer, unicode_string.Buffer, unicode_string.Length);
    }
    else if ( !EAC_Compare_Unicode_Size_String(ModuleName, 0x40i64, &unicode_string.Length)
           || (Module = EAC_Get_User_Module(ModuleName), (EAC_Memory_Data->ModuleName = Module) == 0i64) )
    {
LABEL_30:
      if ( EAC_Memory_Data )
        EAC_Free_Memory(EAC_Memory_Data);

      (loc_140054154)(*&Object->Length, &ApcState);// KeUnstackDetachProcess
      return Status;
    }
    if ( g_RtlCreateUserThread )
    {
      Status = g_RtlCreateUserThread(           // RtlCreateUserThread
                 -1i64,
                 0i64,
                 0i64,
                 0i64,
                 0i64,
                 0i64,
                 EAC_Memory_Data,
                 &EAC_Memory_Data->StartParameter,
                 &Handle,
                 0i64);
    }
    else
    {
      if ( !g_RtlCreateUserThreadEx )
      {
        Status = 0xC0000002;
        LODWORD(Status_2) = 0xC0000002;
LABEL_24:
        if ( Status >= 0 )
        {
          ZwWaitForSingleObject(Handle, 0, 0i64);
          Status = Get_NtQueryInformationThread(Handle, 0, ThreadInfo, 0x30u);
          LODWORD(Status_2) = Status;
          if ( Status >= 0 )
          {
            v17 = LOWORD(ThreadInfo[0]) | 0xC0070000;
            if ( ThreadInfo[0] <= 0 )
              v17 = ThreadInfo[0];

            Status = ThreadInfo[0] != 0 ? v17 : 0;
            LODWORD(Status_2) = Status;
          }
          Get_NtClose(Handle);
        }
        goto LABEL_30;
      }
      Status = g_RtlCreateUserThreadEx(
                 -1i64,
                 0i64,
                 0i64,
                 0i64,
                 0i64,
                 0i64,
                 0i64,
                 EAC_Memory_Data,
                 &EAC_Memory_Data->StartParameter,
                 &Handle,
                 0i64,
                 0i64,
                 Status_2);
    }
    LODWORD(Status_2) = Status;
    goto LABEL_24;
  }
  return Status;
}
// 14001B34B: variable 'ProcessHandle' is possibly undefined
// 14001B34B: variable 'unknown' is possibly undefined
// 14001B492: variable 'BaseModule' is possibly undefined
// 14006D620: using guessed type __int128 xmmword_14006D620;
// 14006D630: using guessed type __int128 xmmword_14006D630;
// 14006D640: using guessed type __int128 xmmword_14006D640;
// 14006D650: using guessed type __int128 xmmword_14006D650;
// 140085940: using guessed type __int64 (__fastcall *g_RtlCreateUserThread)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 140085948: using guessed type __int64 (__fastcall *g_RtlCreateUserThreadEx)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 14001B2D4: using guessed type _KAPC_STATE ApcState;
// 14001B2D4: using guessed type int ThreadInfo[12];

//----- (000000014001B690) ----------------------------------------------------
__int64 __fastcall sub_14001B690(__int64 Data, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 idx; // r9
  unsigned __int64 i; // r10
  int v6; // ecx
  char v7; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 24) = 0;
  v3 = 224915431;
  idx = 24i64;
  for ( i = 0i64; i < 0x18; i += 4i64 )
  {
    v6 = *(Data + i) ^ v3;
    v3 = __ROR4__(43675 * v3 + 10156225, 2);
    *(a2 + i) = v6;
  }
  do
  {
    v7 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + idx) = *(Data + idx) ^ v7;
    ++idx;
  }
  while ( idx < 0x1A );

  return result;
}

//----- (000000014001B718) ----------------------------------------------------
__int64 __fastcall sub_14001B718(__int64 a1, __int64 a2)
{
  unsigned int v2; // r8d
  unsigned __int64 v3; // r10
  __int64 result; // rax

  *a2 = 0i64;
  v2 = 0xC5129C52;
  *(a2 + 8) = 0;
  v3 = 0i64;
  *(a2 + 12) = 0;
  do
  {
    *(a2 + v3) = *(a1 + v3) ^ v2;
    v3 += 4i64;
    v2 = ~(((v2 ^ (v2 << 13)) >> 7) ^ v2 ^ (v2 << 13) ^ ((((v2 ^ (v2 << 13)) >> 7) ^ v2 ^ (v2 << 13)) << 17));
  }
  while ( v3 < 0xC );
  result = a2;
  *(a2 + 12) = *(a1 + 12) ^ v2;
  return result;
}

//----- (000000014001B794) ----------------------------------------------------
__int64 __fastcall sub_14001B794(__int64 a1, __int64 a2)
{
  int v2; // r8d
  unsigned __int64 Offset; // r9
  __int64 result; // rax

  v2 = 1860710520;
  *a2 = 0i64;
  Offset = 0i64;
  *(a2 + 8) = 0;
  do
  {
    v2 = __ROR4__(0x6EE9 * v2 + 0xE83078, 3);
    result = a2;
    *(a2 + Offset) = *(a1 + Offset) ^ v2;
    Offset += 4i64;
  }
  while ( Offset < 0xC );
  return result;
}

//----- (000000014001B7E4) ----------------------------------------------------
bool __fastcall EAC_Write_Unknown_File(__int64 Object)
{
  struct _UNICODE_STRING *unicode_string; // r14
  bool ret; // bl MAPDST
  char v4; // di
  unsigned int v5; // edx
  unsigned __int64 idx; // rdi
  unsigned __int64 i; // r8
  int v8; // ecx
  char v9; // cl
  int Status; // eax
  char v11; // dl
  __m128 *Buffer; // rax MAPDST
  __int64 Unknown; // rdx
  int v17[21]; // [rsp+20h] [rbp-79h]
  __int16 v18; // [rsp+74h] [rbp-25h]
  __m128 Data[7]; // [rsp+76h] [rbp-23h] BYREF

  unicode_string = (Object + 0x10);
  ret = 0;
  v4 = 0;
  if ( !sub_14005D2DC(Object + 0x10, 0x1000u) )
    goto LABEL_6;

  v17[0] = 1622517306;
  v18 = -26;
  v17[1] = 1904163181;
  v17[2] = 413218829;
  v17[3] = 9672168;
  v17[4] = -635690208;
  v17[5] = -1916859107;
  v17[6] = 646752469;
  v17[7] = -1321741467;
  v17[8] = -65873807;
  v17[9] = -2031851441;
  v17[10] = 1756386477;
  v17[11] = 1617510246;
  v17[12] = -2068915532;
  v17[13] = 959619160;
  v17[14] = 1814013008;
  v17[15] = -1450203717;
  v17[16] = -1722756070;
  v17[17] = -1998465969;
  v17[18] = -453928905;
  v17[19] = -374072576;
  v17[20] = 276059131;
  EAC_memset(Data, 0, 0x56ui64);
  v5 = 1625728614;
  idx = 84i64;
  for ( i = 0i64; i < 21; ++i )
  {
    v8 = v17[i] ^ v5;
    v5 = __ROL4__(1140671485 * v5 + 12820163, 4);
    Data[0].m128_i32[i] = v8;
  }
  do
  {
    v9 = v5;
    v5 >>= 8;
    Data[0].m128_i8[idx] = *(v17 + idx) ^ v9;
    ++idx;
  }
  while ( idx < 0x56 );
  v4 = 1;
  Status = EAC_sprintf(unicode_string, Data, __rdtsc());
  v11 = 0;
  if ( Status < 0 )
LABEL_6:

    v11 = 1;
  if ( (v4 & 1) != 0 )
    memset(Data, 0, 0x56ui64);

  if ( v11 )
    return 0;

  Buffer = (loc_14000CD18)(&unk_14006D660, 0x5FE8i64);
  if ( Buffer )
  {
    if ( EAC_Write_File(unicode_string, Unknown, Buffer) )
    {
      *(Object + 8) = 1;
      ret = EAC_CreateUserThread(Object, 1) >= 0;
      *(Object + 9) = ret;
    }
    EAC_memset(Buffer, 0, 0x5FE8ui64);
    Get_ExFreePool(Buffer);
  }
  return ret;
}
// 14001B99E: variable 'Unknown' is possibly undefined
// 14001B7E4: using guessed type __m128 Data;

//----- (000000014001B9F0) ----------------------------------------------------
__int64 __fastcall sub_14001B9F0(OBJECT_ATTRIBUTES *Object)
{
  __int64 result; // rax

  if ( Object )
  {
    if ( LOBYTE(Object->RootDirectory) )
      Get_ZwDeleteFile(&Object->ObjectName);

    result = EAC_Free_UnicodeString(&Object->ObjectName);
    if ( *&Object->Length )
      result = ObfDereferenceObject(*&Object->Length);

    *&Object->Length = 0i64;
    *&Object->ObjectName = 0i64;
  }
  return result;
}

//----- (000000014001BA40) ----------------------------------------------------
char __fastcall sub_14001BA40(PVOID Object)
{
  char v1; // bp
  char v2; // r14
  unsigned __int64 v4; // rbx
  PVOID *v5; // rax
  char *v6; // rbx
  unsigned __int64 v7; // rax
  _QWORD *v8; // rcx
  char *v9; // rdi
  __int64 v10; // rax

  v1 = 0;
  v2 = 0;
  if ( !Object || !byte_140085689 )
    return 0;
  ExAcquireFastMutex(&stru_140085708);
  v4 = 0i64;
  v5 = &unk_140085740;
  while ( *v5 != Object )
  {
    ++v4;
    v5 += 4;
    if ( v4 >= 0x10 )
    {
      v6 = 0i64;
      goto LABEL_7;
    }
  }
  v6 = &unk_140085740 + 32 * v4;
  if ( v6 )
  {
    v1 = v6[9];
    v9 = v6;
    goto LABEL_15;
  }
LABEL_7:
  v7 = 0i64;
  v8 = &unk_140085740;
  while ( *v8 )
  {
    ++v7;
    v8 += 4;
    if ( v7 >= 0x10 )
    {
      v9 = 0i64;
      goto LABEL_14;
    }
  }
  v10 = 32 * v7;
  *(&unk_140085740 + v10 + 8) = 0i64;
  v9 = &unk_140085740 + v10;
  *(&unk_140085740 + v10 + 16) = 0i64;
  *(&unk_140085740 + v10 + 24) = 0i64;
  *(&unk_140085740 + v10) = Object;
  if ( (&unk_140085740 + v10) )
    goto LABEL_15;
LABEL_14:
  v2 = 1;
LABEL_15:
  ExReleaseFastMutex(&stru_140085708);
  if ( v6 )
    return v1;
  if ( !v2 && (ObfReferenceObject(Object), EAC_Write_Unknown_File(v9)) )
    return 1;
  else
    return 0;
}
// 140085689: using guessed type char byte_140085689;

//----- (000000014001BB4C) ----------------------------------------------------
__int64 sub_14001BB4C()
{
  OBJECT_ATTRIBUTES *Object; // rbx
  __int64 idx; // rdi
  __int64 result; // rax

  if ( byte_140085689 )
  {
    Object = &unk_140085740;
    idx = 16i64;
    do
    {
      if ( *&Object->Length )
      {
        if ( BYTE1(Object->RootDirectory) )
          EAC_CreateUserThread(Object, 0);

        result = sub_14001B9F0(Object);
      }
      Object = (Object + 0x20);
      --idx;
    }
    while ( idx );
  }
  return result;
}
// 140085689: using guessed type char byte_140085689;

//----- (000000014001BEAC) ----------------------------------------------------
void __fastcall sub_14001BEAC(unsigned int a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v5; // rbx
  __int64 v7; // rsi
  __int64 v9; // r13
  char v10; // bp
  unsigned __int64 v11; // r12
  _OWORD *v12; // rax
  __int64 v13; // rdi
  unsigned int v14; // r14d
  __int64 v15; // r13
  unsigned __int64 v16; // rbp
  __int64 v17; // [rsp+40h] [rbp-48h] BYREF
  _UNICODE_STRING v18; // [rsp+48h] [rbp-40h] BYREF

  if ( a1 )
  {
    v5 = 0i64;
    v7 = a3;
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          v9 = a5;
          if ( a5 )
          {
            v10 = EAC_GetMappedFilename(-1i64, *(a2 + 8), &v18);
            v11 = 0x8000i64;
            v12 = sub_14004ADA0(
                    *(a2 + 8),
                    0x1000ui64,
                    0x8000ui64,
                    2,
                    *(a5 + 40),
                    (&v18 & -(v10 != 0)),
                    *(a5 + 16),
                    &v17);
            v13 = v12;
            if ( v12 )
            {
              *(v12 + 14) = *a2;
              *(v12 + 22) = *(a2 + 24);
            }
            if ( v10 )
              EAC_Free_UnicodeString(&v18);
            if ( v13 )
            {
              v14 = 0;
              if ( a4 )
              {
                v15 = v17;
                do
                {
                  v16 = (*(v7 + 8) + 1);
                  if ( v16 > v11 )
                    break;
                  EAC_memcpy((v5 + v15), *v7, v16);
                  v5 += v16;
                  v11 -= v16;
                  ++v14;
                  v7 += 16i64;
                }
                while ( v14 < a4 );
                v9 = a5;
              }
              (loc_14001BD24)(v9, a1, v13, v5);
              Get_ExFreePool(v13);
            }
          }
        }
      }
    }
  }
}
// 14001BEAC: using guessed type _UNICODE_STRING var_40;

//----- (000000014001C00C) ----------------------------------------------------
void __fastcall sub_14001C00C(__int64 a1, __int64 a2)
{
  char v4; // si
  char v5; // r15
  unsigned __int64 v6; // r8
  unsigned __int32 v7; // edi
  unsigned __int64 v8; // rdx
  char v9; // dl
  char v10; // dl
  unsigned __int32 v11; // ebx
  unsigned __int64 v12; // rdi
  unsigned __int32 v13; // edx
  __int64 v14; // rax
  char v15; // dl
  int v16; // edi
  int v17; // esi
  unsigned int v18; // r12d
  __int64 v19; // r13
  unsigned __int64 i; // rdx
  int v21[8]; // [rsp+30h] [rbp-D0h]
  __int16 v22; // [rsp+50h] [rbp-B0h]
  int v23[17]; // [rsp+52h] [rbp-AEh]
  int v24[18]; // [rsp+96h] [rbp-6Ah]
  _UNICODE_STRING v25; // [rsp+E0h] [rbp-20h] BYREF
  _BYTE v26[34]; // [rsp+F0h] [rbp-10h] BYREF
  char v27[68]; // [rsp+112h] [rbp+12h] BYREF
  __m128 v28[7]; // [rsp+156h] [rbp+56h] BYREF

  v4 = 0;
  v5 = 0;
  if ( EAC_GetMappedFilename(-1i64, *(a2 + 8), &v25) )
  {
    v21[0] = 1231943912;
    v22 = 21231;
    v6 = 32i64;
    v21[1] = 1872861278;
    v21[2] = -36087613;
    v21[3] = -1162899470;
    v5 = 1;
    v21[4] = -6509788;
    v7 = 1226700937;
    v21[5] = -2064672267;
    v8 = 0i64;
    v21[6] = -2036462706;
    v21[7] = -2029501606;
    memset(v26, 0, sizeof(v26));
    do
    {
      *&v26[v8 * 4] = v21[v8] ^ v7;
      ++v8;
      v7 = _byteswap_ulong(((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13) ^ (32
                                                                        * (((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13))));
    }
    while ( v8 < 8 );
    do
    {
      v9 = v7;
      v7 >>= 8;
      v26[v6] = *(v21 + v6) ^ v9;
      ++v6;
    }
    while ( v6 < 0x22 );
    v10 = sub_14005D25C(&v25, v26);
    memset(v26, 0, sizeof(v26));
    if ( v10 )
      goto LABEL_20;
  }
  sub_140050E64(a1, 0x6386C161u, *(a2 + 8), (&v25 & -(v5 != 0)));
  v11 = 0x2E47A56E;
  if ( !a1 )
    goto LABEL_12;

  v23[0] = 0x7B46ABDC;
  v23[1] = 0xFAB612A4;
  v23[2] = 0x808EECD5;
  v23[3] = 0xF7BAC7A9;
  v23[4] = 0xE5DD8120;
  v23[5] = 0x6CEEC716;
  v23[6] = 0x59A28419;
  v23[7] = 0xE390C11D;
  v23[8] = 0x4D991FAC;
  v23[9] = 0xB13A31C0;
  v23[10] = 0xDF37C646;
  v23[11] = 0x552E39BE;
  v23[12] = 0xC298242D;
  v23[13] = 0xA5DA229;
  v23[14] = 0xEE68B22D;
  v23[15] = 0x52B44FDC;
  v23[16] = 0x704C73D1;
  EAC_memset(v28, 0, 0x44ui64);
  v12 = 0i64;
  v13 = 0x2E47A56E;
  do
  {
    v13 = _byteswap_ulong(((v13 ^ (v13 << 13)) >> 17) ^ v13 ^ (v13 << 13) ^ (32
                                                                           * (((v13 ^ (v13 << 13)) >> 17) ^ v13 ^ (v13 << 13))));
    v28[0].m128_i32[v12] = v23[v12] ^ v13;
    ++v12;
  }
  while ( v12 < 17 );
  v14 = *(a1 + 0x210);
  v4 = 1;
  if ( v14 && !*(v14 + 0x20) )
    v15 = 1;
  else
LABEL_12:
    v15 = 0;
  if ( (v4 & 1) != 0 )
    memset(v28, 0, 0x44ui64);
  if ( v15 )
  {
    v16 = *(a2 + 32);
    v17 = *(a2 + 40);
    v18 = *(a2 + 36);
    v19 = *(a2 + 24);
    v24[0] = 2068229084;
    v24[1] = -88730972;
    v24[2] = -2138116907;
    v24[3] = -138754135;
    v24[4] = -438468320;
    v24[5] = 1827587862;
    v24[6] = 1503822873;
    v24[7] = -477052643;
    v24[8] = 1301880748;
    v24[9] = -1321586240;
    v24[10] = -549992890;
    v24[11] = 1429092798;
    v24[12] = -1030216659;
    v24[13] = 173908521;
    v24[14] = -295128531;
    v24[15] = 1387548636;
    v24[16] = 1884058577;
    EAC_memset(v27, 0, 0x44ui64);
    for ( i = 0i64; i < 17; ++i )
    {
      v11 = _byteswap_ulong(((v11 ^ (v11 << 13)) >> 17) ^ v11 ^ (v11 << 13) ^ (32
                                                                             * (((v11 ^ (v11 << 13)) >> 17) ^ v11 ^ (v11 << 13))));
      *&v27[i * 4] = v24[i] ^ v11;
    }
    EAC_sprintf_Allocate_Memory(*(a1 + 0x210), v27, v19, v18, v17, v16);
    memset(v27, 0, sizeof(v27));
  }
  if ( v5 )
LABEL_20:
    EAC_Free_UnicodeString(&v25);
}
// 14001C00C: using guessed type __m128 var_7A[7];

//----- (000000014001C3EC) ----------------------------------------------------
int __fastcall sub_14001C3EC(__int64 a1, unsigned int *a2)
{
  unsigned int v3; // r14d
  __int64 v4; // rsi
  unsigned __int64 v5; // r12
  __int64 Memory; // rax
  __int64 v7; // r13
  unsigned __int64 v8; // rax
  char *v9; // rdi
  char *BaseAddress; // rax
  int v11; // r14d
  __int64 v12; // rax
  bool v13; // dl
  unsigned int v14; // r14d
  __m128 *v15; // rax
  ULONG64 v16; // rdx
  unsigned __int64 v17; // rdi
  __int64 v18; // rdx
  unsigned int v19; // eax
  __int64 v20; // rcx
  __int64 k; // r8
  unsigned int v22; // r14d
  unsigned int v23; // eax
  unsigned int v24; // edi
  unsigned __int64 v25; // rcx
  __int64 v26; // rdx
  unsigned int j; // r11d
  int v28; // edx
  int v29; // r9d
  int v30; // r10d
  unsigned int v31; // r14d
  bool v32; // zf
  char v33; // al
  unsigned int v34; // eax
  __int64 v35; // rax
  __int64 v36; // r14
  unsigned __int64 v37; // rsi
  int v38; // edi
  unsigned __int64 v39; // r10
  unsigned __int64 v40; // r9
  unsigned int v41; // edi
  unsigned __int64 v42; // rcx
  __int64 v43; // r14
  int v44; // edi
  unsigned __int64 v45; // r9
  unsigned __int64 v46; // r11
  unsigned int v47; // edi
  unsigned __int64 v48; // rcx
  __int64 v50; // [rsp+20h] [rbp-198h]
  __int64 v51; // [rsp+28h] [rbp-190h]
  int v52; // [rsp+38h] [rbp-180h] BYREF
  int v53; // [rsp+3Ch] [rbp-17Ch]
  int v54; // [rsp+40h] [rbp-178h]
  int v55; // [rsp+44h] [rbp-174h]
  int v56; // [rsp+48h] [rbp-170h]
  int v57; // [rsp+4Ch] [rbp-16Ch]
  int v58; // [rsp+50h] [rbp-168h]
  int v59; // [rsp+54h] [rbp-164h]
  int v60; // [rsp+58h] [rbp-160h]
  int v61; // [rsp+5Ch] [rbp-15Ch]
  int v62; // [rsp+60h] [rbp-158h]
  int v63; // [rsp+64h] [rbp-154h]
  int v64; // [rsp+68h] [rbp-150h]
  int v65; // [rsp+6Ch] [rbp-14Ch]
  int v66; // [rsp+70h] [rbp-148h]
  int v67; // [rsp+74h] [rbp-144h]
  int v68; // [rsp+78h] [rbp-140h]
  ULONG64 i; // [rsp+80h] [rbp-138h] BYREF
  char *v70; // [rsp+88h] [rbp-130h]
  unsigned __int64 v71; // [rsp+98h] [rbp-120h]
  int v72; // [rsp+A0h] [rbp-118h]
  unsigned int v73; // [rsp+A4h] [rbp-114h]
  int v74; // [rsp+A8h] [rbp-110h]
  unsigned int v75; // [rsp+B0h] [rbp-108h]
  int v76; // [rsp+B4h] [rbp-104h] BYREF
  int v77; // [rsp+B8h] [rbp-100h]
  int v78; // [rsp+BCh] [rbp-FCh]
  __int64 v79; // [rsp+C0h] [rbp-F8h]
  int v80; // [rsp+C8h] [rbp-F0h]
  unsigned int v81; // [rsp+CCh] [rbp-ECh]
  unsigned __int64 v82; // [rsp+D0h] [rbp-E8h]
  __int64 v83; // [rsp+D8h] [rbp-E0h]
  unsigned __int64 v84; // [rsp+E0h] [rbp-D8h]
  __int64 v85; // [rsp+E8h] [rbp-D0h]
  __int64 v86; // [rsp+F0h] [rbp-C8h]
  __int64 v87; // [rsp+F8h] [rbp-C0h]
  unsigned __int64 v88; // [rsp+100h] [rbp-B8h]
  char v89[68]; // [rsp+108h] [rbp-B0h] BYREF
  _KAPC_STATE ApcState[2]; // [rsp+150h] [rbp-68h] BYREF
  unsigned int v92; // [rsp+1D0h] [rbp+18h]
  unsigned int v93; // [rsp+1D8h] [rbp+20h]

  v3 = 0;
  v92 = 0;
  v75 = 0;
  v4 = 0i64;
  v5 = 0i64;
  v76 = 0;
  v82 = 0i64;
  LODWORD(Memory) = KeQueryTimeIncrement();
  if ( !a2 || *a2 == 197 )
    return Memory;
  Memory = EAC_Allocate_Memory(0x4000ui64);
  v7 = Memory;
  v86 = Memory;
  if ( !Memory )
    goto LABEL_108;
  Memory = EAC_Allocate_Memory(0x400ui64);
  v4 = Memory;
  v79 = Memory;
  if ( !Memory )
    goto LABEL_108;
  Memory = EAC_Allocate_Memory(0x8000ui64);
  v5 = Memory;
  v87 = Memory;
  if ( !Memory )
    goto LABEL_108;
  v83 = Memory + 2;
  v85 = Memory + 0x8000;

  if ( !Get_KeStackAttachProcess(*(a2 + 1), ApcState) )
    goto LABEL_94;

  for ( i = 0i64; !*(a2 + 0x218) && (loc_140053930)(-1i64, i, 0i64, &i, 48i64); i += v71 )
  {
    v8 = (v71 + 4095) & 0xFFFFFFFFFFFFF000ui64;
    if ( !v8 )
      v8 = 4096i64;
    v71 = v8;
    v9 = v70;
    if ( v70 != i )
      goto LABEL_19;
    if ( v74 == 0x1000000 )
    {
      if ( !v70 || !sub_14001D8AC(v70) && !sub_14001D80C(v9) )
      {
        BaseAddress = Get_PsGetProcessSectionBaseAddress(*(a2 + 1));
        if ( v70 != BaseAddress )
        {
          sub_14001C00C(a2, &i);
          goto LABEL_35;
        }
      }
LABEL_19:
      if ( v74 == 0x1000000 && (v73 & 0x100) != 0 )
      {
        sub_140050E64(a2, 0x3AAE2F93u, v70, 0i64);
        v52 = -162874441;
        v53 = 1641820161;
        v54 = 786773158;
        v55 = -1238687746;
        v56 = -2035185395;
        v57 = 2130162904;
        v58 = 560092214;
        v59 = 2126777083;
        v60 = -1530090162;
        v61 = -1285144218;
        v62 = 407679399;
        v63 = -1330724977;
        v64 = 2135383223;
        v65 = -652532151;
        v66 = 992736160;
        v67 = 1068481831;
        v68 = -1815564945;
        v11 = v3 | 1;
        v13 = 0;
        if ( sub_14001CE44(&v52, v89) )
        {
          v12 = *(a2 + 66);
          if ( v12 )
          {
            if ( !*(v12 + 32) )
              v13 = 1;
          }
        }
        v14 = v11 & 0xFFFFFFFE;
        v92 = v14;
        memset(v89, 0, sizeof(v89));
        if ( v13 )
        {
          v52 = -162874441;
          v53 = 1641820161;
          v54 = 786773158;
          v55 = -1238687746;
          v56 = -2035185395;
          v57 = 2130162904;
          v58 = 560092214;
          v59 = 2126777083;
          v60 = -1530090162;
          v61 = -1285144218;
          v62 = 407679399;
          v63 = -1330724977;
          v64 = 2135383223;
          v65 = -652532151;
          v66 = 992736160;
          v67 = 1068481831;
          v68 = -1815564945;
          v15 = sub_14001CE44(&v52, v89);
          LODWORD(v51) = v72;
          LODWORD(v50) = v74;
          EAC_sprintf_Allocate_Memory(*(a2 + 0x42), v15, v71, v73, v50, v51);
          memset(v89, 0, sizeof(v89));
        }
        v75 = v14;
        goto LABEL_35;
      }
    }
    if ( Get_MmGetPhysicalAddress(i) )
    {
      v16 = *(a2 + 23);
      if ( v16 >= i && v16 < v71 + i )
        continue;
    }
    else if ( v71 <= 0x1000 || !Get_MmGetPhysicalAddress(i - 4096 + v71) )
    {
      continue;
    }
LABEL_35:
    v17 = v71;
    v84 = v71;
    v88 = v71;
    v18 = v71;
    if ( v71 > 0x100000 )
      v18 = 0x100000i64;
    v71 = v18;
    EAC_IsUsermodeValidAddress(i, v18, 1);
    v19 = Check_Address(&i, v7, 1024);
    v22 = v19;
    v93 = v19;
    if ( v19 )
    {
      v23 = sub_14003D3BC(v20, 2i64, v7, v19);
      v24 = v23;
      if ( (v23 != 1807354419 || v74 == 0x20000)
        && (v23 != 2115592180 || v73 == 64)
        && (v23 != 1600944267 || v74 == 0x20000) )
      {
        if ( v23 == 1715624708 )
        {
          if ( v74 == 0x1000000
            || (v25 = *a2, v25 <= 0x3E) && (v26 = 0x4002000800121000i64, _bittest64(&v26, v25))
            || v25 == 81
            || v25 == 89 )
          {
            v24 = 0;
          }
        }
        if ( v24 )
          goto LABEL_70;
      }
      v24 = 0;
      for ( j = 0; ; ++j )
      {
        v81 = j;
        if ( j >= v22 )
          break;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        for ( k = 0i64; ; k = (k + 1) )
        {
          v80 = k;
          v31 = *(v7 + 16i64 * j + 8);
          v32 = k == v31;
          if ( k >= v31 )
            break;
          v33 = *(k + *(v7 + 16i64 * j));
          if ( v33 == 120 )
          {
            v28 |= 1u;
            v30 = 0;
            v78 = 0;
            v77 = ++v29;
            if ( v29 == 3 )
              v28 |= 4u;
          }
          else
          {
            if ( v33 != 63 )
            {
              v32 = k == v31;
              break;
            }
            v28 |= 2u;
            v29 = 0;
            v77 = 0;
            v78 = ++v30;
            if ( v30 == 2 )
              v28 |= 8u;
          }
        }
        if ( v32 && v28 == 15 )
        {
          v24 = 2000911142;
          v22 = v93;
          break;
        }
        v22 = v93;
      }
      v4 = v79;
      if ( v24 )
LABEL_70:
        sub_14001BEAC(v24, &i, v7, v22, a2);
      v17 = v84;
    }
    if ( v71 > 0x1000 )
      v83 = sub_140032954(&i, v4, k, v83, v85, &v76);
    v82 += v71;
    if ( v82 >= 0x1400000 )
    {
      v82 = 0i64;
      *(a1 + 40) = KUSER_SHARED_DATA.TickCountQuad;
    }
    v71 = v17;
    v3 = v92;
  }
  if ( (((loc_140054154)(*(a2 + 1), ApcState), v34 = a2[10], v34 != 64) || i >= 0x7FFFFFF0000i64)// KeUnstackDetachProcess
    && (v34 != 32 || i >= 0x7FFE0000)
    || !sub_140052928(*(a2 + 1))
    || *(a2 + 536) )
  {
LABEL_94:
    v37 = 24i64;
    goto LABEL_95;
  }
  v35 = EAC_Allocate_Memory(0x8208ui64);
  v36 = v35;
  if ( v35 )
  {
    EAC_memset((v35 + 8), 0, 0x8200ui64);
    *v36 = 0i64;
  }
  else
  {
    v36 = 0i64;
  }
  v37 = 24i64;
  if ( v36 )
  {
    *(v36 + 8) = -1417995409;
    *(v36 + 12) = -7958710;
    *(v36 + 16) = 2058849236;
    *(v36 + 20) = (-1787513475 * (&i >> 2)) ^ 0x16751F01;
    *(v36 + 24) = -1772766137;
    *(v36 + 28) = 761586442;
    v38 = (-1787513475 * (&i >> 2)) ^ 0xC6565F4B;
    v39 = 0i64;
    v40 = 24i64;
    do
    {
      v41 = __ROR4__(
              ((v38 ^ (v38 << 13)) >> 7) ^ v38 ^ (v38 << 13) ^ ((((v38 ^ (v38 << 13)) >> 7) ^ v38 ^ (v38 << 13)) << 17),
              4);
      *(&i + v39 + v36 + 8 - &i + 24) = *(&i + v39) ^ (v41 >> (8 * (v39 & 3)));
      v38 = *(&i + v39++) ^ v41;
      ++v40;
    }
    while ( v39 < 8 );
    v42 = (v40 + 255) & 0xFFFFFFFFFFFFFF00ui64;
    while ( v40 < v42 )
    {
      v38 *= -1787513475;
      *(v40 + v36 + 8) = BYTE1(v38);
      ++v40;
    }
    *(v36 + 24) ^= v38;
    *(v36 + 28) ^= v39;
    *v36 = v40;
    (loc_140045210)(a2, 1099170139i64, v36 + 8);
    Get_ExFreePool(v36);
  }
LABEL_95:
  LODWORD(Memory) = v76;
  if ( v76 )
  {
    *v5 = v76;
    Memory = EAC_Allocate_Memory(0x8208ui64);
    v43 = Memory;
    if ( Memory )
    {
      LODWORD(Memory) = EAC_memset((Memory + 8), 0, 0x8200ui64);
      *v43 = 0i64;
    }
    else
    {
      v43 = 0i64;
    }
    if ( v43 )
    {
      *(v43 + 8) = -1417995409;
      *(v43 + 12) = -7958710;
      *(v43 + 16) = 2058849236;
      *(v43 + 20) = (-1787513475 * (v5 >> 2)) ^ 0x16751F01;
      *(v43 + 24) = -1772766137;
      *(v43 + 28) = 761586442;
      v44 = (-1787513475 * (v5 >> 2)) ^ 0xC6565F4B;
      v45 = 0i64;
      v46 = (v83 - v5);
      if ( v83 != v5 )
      {
        do
        {
          if ( v45 >= 0x8000 )
            break;
          v47 = __ROR4__(
                  ((v44 ^ (v44 << 13)) >> 7) ^ v44 ^ (v44 << 13) ^ ((((v44 ^ (v44 << 13)) >> 7) ^ v44 ^ (v44 << 13)) << 17),
                  4);
          *(v43 + 8 + v45 + 24) = *(v45 + v5) ^ (v47 >> (8 * (v45 & 3)));
          v44 = *(v45 + v5) ^ v47;
          ++v45;
          ++v37;
        }
        while ( v45 < v46 );
      }
      v48 = (v37 + 255) & 0xFFFFFFFFFFFFFF00ui64;
      while ( v37 < v48 )
      {
        v44 *= -1787513475;
        *(v37 + v43 + 8) = BYTE1(v44);
        ++v37;
      }
      *(v43 + 24) ^= v44;
      *(v43 + 28) ^= v45;
      *v43 = v37;
      (loc_140045210)(a2, 1394482290i64, v43 + 8, v37, 0i64);
      LODWORD(Memory) = Get_ExFreePool(v43);
    }
  }
  v4 = v79;
LABEL_108:
  if ( v5 )
    LODWORD(Memory) = Get_ExFreePool(v5);
  if ( v4 )
    LODWORD(Memory) = Get_ExFreePool(v4);
  if ( v7 )
    LODWORD(Memory) = Get_ExFreePool(v7);
  return Memory;
}
// 14001CC91: conditional instruction was optimized away because r14.8!=0
// 14001CDDE: conditional instruction was optimized away because r14.8!=0
// 14001C79B: variable 'v50' is possibly undefined
// 14001C79B: variable 'v51' is possibly undefined
// 14001C89B: variable 'v20' is possibly undefined
// 14001CA65: variable 'k' is possibly undefined
// 14001D80C: using guessed type __int64 __fastcall sub_14001D80C(_QWORD);
// 14001D8AC: using guessed type __int64 __fastcall sub_14001D8AC(_QWORD);
// 14003D3BC: using guessed type __int64 __fastcall sub_14003D3BC(_QWORD, _QWORD, _QWORD, _QWORD);
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014001CE44) ----------------------------------------------------
__m128 *__fastcall sub_14001CE44(__int64 a1, __m128 *a2)
{
  unsigned int v4; // r8d
  unsigned __int64 i; // rdx
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x44ui64);
  v4 = 0xEFA37BE4;
  for ( i = 0i64; i < 17; ++i )
  {
    v4 = ~(((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13) ^ ((((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13)) << 17));
    result = a2;
    a2->m128_i32[i] = *(a1 + i * 4) ^ v4;
  }
  return result;
}

//----- (000000014001D2CC) ----------------------------------------------------
ULONG64 __fastcall EAC_IsUsermodeValidAddress(ULONG64 Address, __int64 Size, int Flag)
{
  ULONG64 FinalAddress; // rcx
  ULONG64 result; // rax

  if ( Size )
  {
    if ( Flag != 1 && Flag != 8 )
      ExRaiseDatatypeMisalignment();

    if ( ((Flag - 1) & Address) != 0 )
      ExRaiseDatatypeMisalignment();

    FinalAddress = Address + Size - 1;
    if ( FinalAddress < Address || (result = MmUserProbeAddress, FinalAddress >= MmUserProbeAddress) )
      ExRaiseAccessViolation();
  }
  return result;
}

//----- (000000014001D338) ----------------------------------------------------
char __fastcall sub_14001D338(char *Address, __int64 Size)
{
  char *StartAddress; // rbx
  ULONG64 VirtualMemory; // rdi
  unsigned __int64 FinalAddress; // rdi
  char result; // al

  if ( Size )
  {
    StartAddress = Address;
    VirtualMemory = &Address[Size - 1];
    if ( VirtualMemory < Address || VirtualMemory >= MmUserProbeAddress )
      ExRaiseAccessViolation();

    FinalAddress = (VirtualMemory & 0xFFFFFFFFFFFFF000ui64) + 0x1000;
    do
    {
      result = *StartAddress;
      *StartAddress = *StartAddress;
      StartAddress = ((StartAddress & 0xFFFFFFFFFFFFF000ui64) + 0x1000);
    }
    while ( StartAddress != FinalAddress );
  }
  return result;
}

//----- (000000014001D394) ----------------------------------------------------
_IMAGE_NT_HEADERS *__fastcall Get_Nt_Headers(__int64 BaseAddress, unsigned __int64 Size)
{
  _IMAGE_NT_HEADERS *ret; // r9
  __int64 e_lfanew; // rdx
  IMAGE_NT_HEADERS *NtHeaders; // r8
  WORD Magic; // cx
  bool IsSize; // zf
  __int64 Value; // rax

  ret = 0i64;
  if ( BaseAddress )
  {
    if ( Size >= 0x1000 && *BaseAddress == 0x5A4D )
    {
      e_lfanew = *(BaseAddress + 0x3C);
      if ( e_lfanew > 0 && e_lfanew <= Size - 0x108 )
      {
        NtHeaders = (e_lfanew + BaseAddress);
        if ( *(e_lfanew + BaseAddress) == 0x4550 )
        {
          Magic = NtHeaders->OptionalHeader.Magic;
          if ( Magic == 0x10B
            && NtHeaders->FileHeader.SizeOfOptionalHeader == 0xE0
            && NtHeaders->FileHeader.Machine == 0x14C )
          {
            IsSize = HIDWORD(NtHeaders->OptionalHeader.SizeOfHeapReserve) == 16;
          }
          else
          {
            if ( Magic != 0x20B
              || NtHeaders->FileHeader.SizeOfOptionalHeader != 0xF0
              || NtHeaders->FileHeader.Machine != 0x8664 )
            {
              return ret;
            }

            IsSize = NtHeaders->OptionalHeader.NumberOfRvaAndSizes == 16;
          }
          if ( IsSize )
          {

            Value = 0x108i64;
            if ( Magic == 0x10B )
              Value = 0xF8i64;

            if ( Size >= e_lfanew + Value + 40 * NtHeaders->FileHeader.NumberOfSections )
              return NtHeaders;
          }
        }
      }
    }
  }
  return ret;
}

//----- (000000014001D494) ----------------------------------------------------
char __fastcall Get_Module_Architecture(IMAGE_NT_HEADERS *Nt_Headers)
{
  WORD Magic; // ax

  if ( !Nt_Headers )
    return 0;

  Magic = Nt_Headers->OptionalHeader.Magic;
  if ( Magic == 0x10B )
    return 32;

  if ( Magic == 0x20B )
    return 64;
  else
    return 0;
}

//----- (000000014001D4BC) ----------------------------------------------------
char __fastcall GetModuleInfo(__int64 BaseAddress, unsigned __int64 Size, _QWORD *AddressOut, __int64 *NtHeadersOut)
{
  char ret; // bl
  __int64 NtHeaders; // rax

  ret = 0;
  NtHeaders = Get_Nt_Headers(BaseAddress, Size);
  if ( NtHeaders )
  {
    if ( AddressOut )
      *AddressOut = BaseAddress;

    if ( NtHeadersOut )
      *NtHeadersOut = NtHeaders;

    return 1;
  }
  return ret;
}

//----- (000000014001D510) ----------------------------------------------------
_DWORD *__fastcall sub_14001D510(unsigned __int64 Address, _IMAGE_NT_HEADERS *NtHeaders)
{
  WORD NumberOfSections; // r11
  _DWORD *v3; // r8
  bool v5; // cf
  WORD idx; // r9
  int v7; // eax
  unsigned __int64 v8; // rcx

  NumberOfSections = NtHeaders->FileHeader.NumberOfSections;
  v3 = (&NtHeaders->OptionalHeader.Magic + NtHeaders->FileHeader.SizeOfOptionalHeader);
  v5 = NumberOfSections != 0;
  idx = 0;
  while ( v5 )
  {
    v7 = v3[2];
    if ( !v7 )
      v7 = v3[4];

    v8 = v3[3];
    if ( Address >= v8 && Address < (v7 + v8) )
      return v3;

    ++idx;
    v3 += 0xA;
    v5 = idx < NumberOfSections;
  }
  return 0i64;
}

//----- (000000014001D56C) ----------------------------------------------------
_DWORD *__fastcall sub_14001D56C(unsigned __int64 Address, _IMAGE_NT_HEADERS *NtHeaders, __int64 BaseAddress)
{
  _DWORD *result; // rax

  result = sub_14001D510(Address, NtHeaders);
  if ( result )
    return (BaseAddress + Address - (result[3] - result[5]));

  return result;
}

//----- (000000014001D5A0) ----------------------------------------------------
__int64 __fastcall sub_14001D5A0(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // rdx
  unsigned int *v6; // r9
  unsigned __int64 v7; // r10
  unsigned __int64 v9; // rcx

  v3 = *(a2 + 20);
  v4 = a2 + 24;
  v5 = *(a2 + 6);
  v6 = (v3 + v4);
  v7 = 0i64;
  if ( !v5 )
    return 0i64;
  while ( 1 )
  {
    v9 = v6[5];
    if ( a1 >= v9 && a1 < v9 + v6[4] )
      break;
    ++v7;
    v6 += 10;
    if ( v7 >= v5 )
      return 0i64;
  }
  if ( v6 )
    return a3 + a1 + v6[3] - v6[5];
  else
    return 0i64;
}

//----- (000000014001D5F4) ----------------------------------------------------
__int64 __fastcall Get_User_Module_x86(__int64 string)
{
  unsigned __int64 DllBase; // rbx
  PEPROCESS CurrentProcess; // rax
  __int64 Peb32; // rax MAPDST
  __int64 Ldr; // rdi
  unsigned int *InLoadOrderModuleList; // rdi
  ULONG64 Address; // rcx MAPDST
  __int16 BaseDllName; // [rsp+28h] [rbp-20h] BYREF
  unsigned __int16 BaseDllName_Size; // [rsp+2Ah] [rbp-1Eh]

  DllBase = 0i64;
  CurrentProcess = IoGetCurrentProcess();
  Peb32 = Get_PsGetProcessWow64Process2(CurrentProcess);
  if ( Peb32 )
  {
    EAC_IsUsermodeValidAddress(Peb32, 0x3Ci64, 1);
    Ldr = *(Peb32 + 0xC);                       // _PEB32::Ldr
    if ( Ldr )
    {
      EAC_IsUsermodeValidAddress(Ldr, 0x24i64, 1);
      InLoadOrderModuleList = *(Ldr + 0xC);     // InLoadOrderModuleList
      if ( InLoadOrderModuleList )
      {
        EAC_IsUsermodeValidAddress(InLoadOrderModuleList, 0x44i64, 1);
        if ( string )
        {
          while ( InLoadOrderModuleList[6] )
          {
            BaseDllName = *(InLoadOrderModuleList + 0x16);// BaseDllName
            BaseDllName_Size = *(InLoadOrderModuleList + 0x17);// BaseDllName_Size
            Address = InLoadOrderModuleList[12];
            EAC_IsUsermodeValidAddress(Address, BaseDllName_Size, 1);
            if ( !Get_CompareUnicodeString(&BaseDllName, string) )
              goto LABEL_7;

            InLoadOrderModuleList = *InLoadOrderModuleList;
            EAC_IsUsermodeValidAddress(InLoadOrderModuleList, 0x44i64, 1);
          }
        }
        else
        {
LABEL_7:
          DllBase = InLoadOrderModuleList[6];
        }
      }
    }
  }
  return DllBase & -(DllBase < MmHighestUserAddress);
}

//----- (000000014001D6F8) ----------------------------------------------------
__int64 __fastcall EAC_Get_User_Module_x64(WCHAR *string)
{
  struct _LIST_ENTRY *DllBase; // rbx
  PEPROCESS CurrentProcess; // rax
  _PEB *ProcessPeb; // rax
  PPEB_LDR_DATA Ldr; // rdi
  _LIST_ENTRY *CurrentEntry; // rdi

  DllBase = 0i64;
  CurrentProcess = IoGetCurrentProcess();
  ProcessPeb = Get_PsGetProcessPeb(CurrentProcess);
  if ( ProcessPeb )
  {
    Ldr = ProcessPeb->Ldr;
    if ( Ldr )
    {
      EAC_IsUsermodeValidAddress(ProcessPeb->Ldr, 0x40i64, 1);
      CurrentEntry = Ldr->InLoadOrderModuleList.Flink;
      if ( CurrentEntry )
      {
        EAC_IsUsermodeValidAddress(CurrentEntry, 0x88i64, 1);
        if ( string )
        {
          while ( CurrentEntry[3].Flink )
          {
            EAC_IsUsermodeValidAddress(CurrentEntry[6].Flink, WORD1(CurrentEntry[5].Blink), 1);

            if ( !Get_CompareUnicodeString(&CurrentEntry[5].Blink, string) )
              goto LABEL_7;

            CurrentEntry = CurrentEntry->Flink;
            EAC_IsUsermodeValidAddress(CurrentEntry, 0x88i64, 1);
          }
        }
        else
        {
LABEL_7:
          DllBase = CurrentEntry[3].Flink;
        }
      }
    }
  }
  return DllBase & -(DllBase < MmHighestUserAddress);
}

//----- (000000014001D7D8) ----------------------------------------------------
__int64 __fastcall EAC_Get_User_Module(__int64 ModuleName)
{
  __int64 CurrentProcess; // rax

  CurrentProcess = Get_PsGetCurrentProcess();
  if ( Get_PsGetProcessWow64Process(CurrentProcess) == 32 )
    return EAC_Get_User_Module_x86(ModuleName);
  else
    return EAC_Get_User_Module_x64(ModuleName);
}

//----- (000000014001D80C) ----------------------------------------------------
unsigned int *__fastcall sub_14001D80C(__int64 a1)
{
  PEPROCESS CurrentProcess; // rax
  __int64 ProcessWow64Process2; // rax
  __int64 v4; // rbx
  __int64 v5; // rbx
  unsigned int *v6; // rbx
  __int64 v7; // rax

  if ( a1 )
  {
    CurrentProcess = IoGetCurrentProcess();
    ProcessWow64Process2 = Get_PsGetProcessWow64Process2(CurrentProcess);
    v4 = ProcessWow64Process2;
    if ( ProcessWow64Process2 )
    {
      EAC_IsUsermodeValidAddress(ProcessWow64Process2, 60i64, 1);
      v5 = *(v4 + 12);
      if ( v5 )
      {
        EAC_IsUsermodeValidAddress(v5, 36i64, 1);
        v6 = *(v5 + 12);
        if ( v6 )
        {
          EAC_IsUsermodeValidAddress(v6, 68i64, 1);
          while ( 1 )
          {
            v7 = v6[6];
            if ( !v7 )
              break;
            if ( v7 == a1 )
              return v6;
            v6 = *v6;
            EAC_IsUsermodeValidAddress(v6, 68i64, 1);
          }
        }
      }
    }
  }
  return 0i64;
}

//----- (000000014001D8AC) ----------------------------------------------------
struct _LIST_ENTRY *__fastcall sub_14001D8AC(struct _LIST_ENTRY *a1)
{
  PEPROCESS CurrentProcess; // rax
  _PEB *ProcessPeb; // rax
  PPEB_LDR_DATA Ldr; // rbx
  struct _LIST_ENTRY *Flink; // rbx
  struct _LIST_ENTRY *CurrentEntry; // rax

  if ( a1 )
  {
    CurrentProcess = IoGetCurrentProcess();
    ProcessPeb = Get_PsGetProcessPeb(CurrentProcess);
    if ( ProcessPeb )
    {
      Ldr = ProcessPeb->Ldr;
      if ( Ldr )
      {
        EAC_IsUsermodeValidAddress(ProcessPeb->Ldr, 0x40i64, 1);
        Flink = Ldr->InLoadOrderModuleList.Flink;
        if ( Flink )
        {
          EAC_IsUsermodeValidAddress(Flink, 136i64, 1);
          while ( 1 )
          {
            CurrentEntry = Flink[3].Flink;
            if ( !CurrentEntry )
              break;

            if ( CurrentEntry == a1 )
              return Flink;

            Flink = Flink->Flink;
            EAC_IsUsermodeValidAddress(Flink, 0x88i64, 1);
          }
        }
      }
    }
  }
  return 0i64;
}

//----- (000000014001D944) ----------------------------------------------------
__int64 __fastcall Check_Module_Architecture(ULONG64 BaseModule)
{
  unsigned int ret; // ebx
  _IMAGE_NT_HEADERS *Nt_Headers; // rax

  ret = 0;
  EAC_IsUsermodeValidAddress(BaseModule, 0x1000i64, 1);

  Nt_Headers = Get_Nt_Headers(BaseModule, 0x1000ui64);
  if ( Nt_Headers )
    return Get_Module_Architecture(Nt_Headers);

  return ret;
}

//----- (000000014001D99C) ----------------------------------------------------
__int64 __fastcall sub_14001D99C(__int64 a1, unsigned __int64 a2)
{
  __int16 v2; // cx
  __int64 v4; // [rsp+30h] [rbp+8h] BYREF

  if ( a1 && a2 >= 0x1000 && GetModuleInfo(a1, a2, 0i64, &v4) )
  {
    v2 = *(v4 + 4);
    if ( v2 == 332 )
      return 32i64;
    if ( v2 == -31132 )
      return 64i64;
  }
  return 0i64;
}

//----- (000000014001D9F4) ----------------------------------------------------
ULONG64 __fastcall EAC_Get_AddressOfEntryPoint(ULONG64 BaseAddress)
{
  __int64 ret; // rbx
  _IMAGE_NT_HEADERS *Nt_Headers; // rax

  ret = 0i64;
  EAC_IsUsermodeValidAddress(BaseAddress, 4096i64, 1);

  Nt_Headers = Get_Nt_Headers(BaseAddress, 0x1000ui64);
  if ( Nt_Headers )
    return Get_AddressOfEntryPoint(BaseAddress, Nt_Headers);

  return ret;
}

//----- (000000014001DA50) ----------------------------------------------------
ULONG64 __fastcall Get_AddressOfEntryPoint(__int64 BaseAddress, _IMAGE_NT_HEADERS *NtHeaders)
{
  ULONG64 ret; // [rsp+20h] [rbp-18h]

  ret = BaseAddress + NtHeaders->OptionalHeader.AddressOfEntryPoint;
  EAC_IsUsermodeValidAddress(ret, 8i64, 1);
  return ret;
}

//----- (000000014001DA84) ----------------------------------------------------
ULONG64 __fastcall sub_14001DA84(ULONG64 BaseModule, _BYTE *a2)
{
  ULONG64 ret; // rbx
  int v5; // edx
  __int64 v6; // rcx
  unsigned int *v7; // rcx
  __int64 v8; // rax
  unsigned int *v9; // rsi
  __int64 v10; // r8
  ULONG64 v11; // r13
  ULONG64 v12; // r12
  unsigned __int64 v13; // rcx
  __int64 v14; // rax
  __int64 i; // r14
  ULONG64 v17; // [rsp+60h] [rbp+8h]

  ret = 0i64;
  if ( !BaseModule || !a2 )
    return 0i64;

  v5 = Check_Module_Architecture(BaseModule);

  if ( v5 )
  {
    v6 = 0x88i64;
    if ( v5 == 32 )
      v6 = 0x78i64;

    v7 = (BaseModule + *(BaseModule + 0x3C) + v6);
    v8 = *v7;
    if ( v8 )
    {
      if ( v7[1] )
      {
        v9 = (BaseModule + v8);
        EAC_IsUsermodeValidAddress(BaseModule + v8, 40i64, 1);
        v10 = v9[5];
        if ( v10 )
        {
          v11 = BaseModule + v9[8];
          v12 = BaseModule + v9[7];
          v17 = BaseModule + v9[9];
          if ( a2 > 0xFFFF )
          {
            EAC_IsUsermodeValidAddress(v11, 4i64 * v9[6], 1);
            for ( i = 0i64; i < v9[6]; i = (i + 1) )
            {
              if ( sub_14005D784(BaseModule + *(v11 + 4 * i), a2, 0x100ui64) )
              {
                v14 = *(v17 + 2i64 * i);
                goto LABEL_17;
              }
            }
          }
          else
          {
            v13 = v9[4];
            if ( a2 >= v13 && a2 < v13 + v10 )
            {
              v14 = a2 - v13;
LABEL_17:
              ret = BaseModule + *(v12 + 4 * v14);
            }
          }
          if ( ret )
            EAC_IsUsermodeValidAddress(ret, 8i64, 1);
        }
      }
    }
  }
  return ret;
}

//----- (000000014001DBF4) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001DBF4(unsigned __int64 a1, unsigned __int64 a2, _BYTE *a3)
{
  __int64 v5; // rbx
  unsigned __int64 v6; // r14
  __int64 v7; // r8
  unsigned int v8; // r9d
  unsigned __int16 *v9; // rdx
  char *v10; // rax
  __int64 v12; // [rsp+50h] [rbp+8h] BYREF

  v5 = 0i64;
  v6 = a1 + a2;
  if ( !a1 || !a2 || !a3 )
    return 0i64;
  if ( GetModuleInfo(a1, a2, 0i64, &v12) )
  {
    v7 = *(v12 + 136);
    if ( v7 )
    {
      v8 = *(v12 + 140);
      if ( v8 )
      {
        v9 = (a1 + v7);
        if ( a1 + v7 >= a1 )
        {
          v10 = v9 + v8;
          if ( v10 > v9 && v10 <= v6 )
            return sub_14001E220(a1, v9, v7, v8, a3);
        }
      }
    }
  }
  return v5;
}

//----- (000000014001DCA8) ----------------------------------------------------
char __fastcall sub_14001DCA8(__int64 SourceAddress, unsigned __int64 a2, void *Data, unsigned int *a4)
{
  char ret; // bl
  unsigned int v5; // r15d
  unsigned __int64 TargetAddress; // rax MAPDST
  DWORD Resource_Directory_Size; // eax
  unsigned __int16 *Buffer; // rax MAPDST
  __int64 ReadfBytes; // rax
  __int64 Length; // rcx MAPDST
  DWORD VirtualAddress; // edx
  unsigned __int64 Buffer_TotalSize; // r8
  unsigned __int64 v17; // r14
  unsigned __int64 v18; // rsi
  unsigned __int64 v19; // r11
  unsigned int v20; // r12d
  __int64 v21; // r10
  __int64 v22; // r13
  DWORD Resource_Directory_Address; // ebp
  unsigned __int16 *v24; // rdx
  unsigned __int16 *v25; // rax
  unsigned int *v26; // r9
  __int64 v27; // rax
  __int64 v28; // rdx
  char *v29; // rdi
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rcx
  unsigned __int64 v32; // rdx
  _IMAGE_NT_HEADERS *NtHeaders; // [rsp+20h] [rbp-78h] MAPDST BYREF
  char *v35; // [rsp+28h] [rbp-70h]
  unsigned __int64 v36; // [rsp+30h] [rbp-68h]
  char Flag; // [rsp+A0h] [rbp+8h]

  ret = 0;
  Flag = 0;
  v35 = 0i64;
  v5 = -1;
  v36 = 0i64;

  if ( !SourceAddress || !a2 || !Data )
    return 0;

  memset(Data, 0, 0x10ui64);
  TargetAddress = EAC_Allocate_Memory(0x1000ui64);
  if ( TargetAddress )
  {
    if ( MmVirtualMemory(SourceAddress, 0x1000i64, TargetAddress) == 0x1000 )
    {
      if ( GetModuleInfo(TargetAddress, 0x1000ui64, 0i64, &NtHeaders) )
      {
        if ( NtHeaders >= TargetAddress
          && &NtHeaders[1].FileHeader.NumberOfSymbols > NtHeaders
          && &NtHeaders[1].FileHeader.NumberOfSymbols <= TargetAddress + 0x1000 )
        {
          if ( NtHeaders->OptionalHeader.DataDirectory[2].VirtualAddress )
          {
            Resource_Directory_Size = NtHeaders->OptionalHeader.DataDirectory[2].Size;
            if ( Resource_Directory_Size )
            {
              Buffer = EAC_Allocate_Memory(Resource_Directory_Size);
              if ( Buffer )
              {
                ReadfBytes = MmVirtualMemory(
                               SourceAddress + NtHeaders->OptionalHeader.DataDirectory[2].VirtualAddress,
                               NtHeaders->OptionalHeader.DataDirectory[2].Size,
                               Buffer);
                Length = NtHeaders->OptionalHeader.DataDirectory[2].Size;
                if ( ReadfBytes == Length )
                {
                  VirtualAddress = NtHeaders->OptionalHeader.DataDirectory[2].VirtualAddress;
                  Buffer_TotalSize = Buffer + Length;
                  v17 = Buffer + *(Buffer + 8) - VirtualAddress;
                  v18 = Buffer + *(Buffer + 7) - VirtualAddress;
                  v19 = Buffer + *(Buffer + 9) - VirtualAddress;
                  if ( v17 >= Buffer
                    && v17 + 4 > v17
                    && v17 + 4 <= Buffer_TotalSize
                    && v19 >= Buffer
                    && v19 + 2 > v19
                    && v19 + 2 <= Buffer_TotalSize
                    && v18 >= Buffer
                    && v18 + 4 > v18
                    && v18 + 4 <= Buffer_TotalSize )
                  {
                    v20 = *(Buffer + 6);
                    v21 = 0i64;
                    if ( v20 )
                    {
                      v22 = Length;
                      Resource_Directory_Address = NtHeaders->OptionalHeader.DataDirectory[2].VirtualAddress;
                      do
                      {
                        v24 = (v17 + 4 * v21);
                        if ( v24 < Buffer )
                          break;
                        if ( v24 + 2 <= v24 )
                          break;
                        if ( (v24 + 2) > Buffer_TotalSize )
                          break;
                        v25 = (v19 + 2 * v21);
                        if ( v25 < Buffer )
                          break;
                        if ( v25 + 1 <= v25 )
                          break;
                        if ( (v25 + 1) > Buffer_TotalSize )
                          break;
                        v26 = (v18 + 4i64 * *v25);
                        if ( v26 < Buffer )
                          break;
                        if ( v26 + 1 <= v26 )
                          break;
                        if ( (v26 + 1) > Buffer_TotalSize )
                          break;
                        v27 = *v24 - Resource_Directory_Address;
                        v28 = v27;
                        v29 = Buffer + v27;
                        if ( Buffer + v27 >= Buffer_TotalSize && v27 < v22 )
                          break;
                        v30 = 0i64;
                        if ( !v29 || v22 == v28 )
                          goto LABEL_41;
                        do
                        {
                          if ( !v29[v30] )
                            break;
                          ++v30;
                        }
                        while ( v30 < v22 - v28 );
                        v31 = 256i64;
                        if ( v30 < 0x100 )
                        {
LABEL_41:
                          v31 = 0i64;
                          if ( v29 && v22 != v28 )
                          {
                            do
                            {
                              if ( !v29[v31] )
                                break;
                              ++v31;
                            }
                            while ( v31 < v22 - v28 );
                          }
                        }
                        if ( v29 < Buffer )
                          break;
                        if ( &v29[v31] <= v29 )
                          break;
                        if ( &v29[v31] > Buffer_TotalSize )
                          break;
                        v32 = *v26;
                        if ( v32 <= a2 && a2 - v32 < v5 )
                        {
                          v35 = v29;
                          v5 = a2 - v32;
                          v36 = v31;
                          Flag = 1;
                          if ( a2 == v32 )
                            break;
                        }
                        v21 = (v21 + 1);
                      }
                      while ( v21 < v20 );
                      if ( v35 )
                        sub_14005D918(Data, v35, v36);
                    }
                  }
                  if ( a4 )
                  {
                    if ( v5 != -1 )
                      *a4 = v5;
                  }
                }
                Get_ExFreePool(Buffer);
              }
              ret = Flag;
            }
          }
        }
      }
    }
    Get_ExFreePool(TargetAddress);
  }
  return ret;
}

//----- (000000014001E220) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001E220(
        __int64 a1,
        unsigned __int16 *a2,
        unsigned int a3,
        unsigned int a4,
        _BYTE *a5)
{
  unsigned __int64 v6; // rsi
  unsigned __int64 v8; // rbx
  char *v11; // rcx
  char *v12; // r13
  unsigned int *v13; // rax
  unsigned int v14; // r15d
  unsigned int *v15; // r8
  unsigned __int64 v16; // rax
  unsigned int v17; // edx
  unsigned __int64 v18; // rcx
  __int64 v19; // rax
  unsigned int v20; // edx
  unsigned __int64 v21; // rax
  unsigned __int16 *v22; // rax
  unsigned int *v23; // rcx
  unsigned int *v25; // [rsp+20h] [rbp-58h]
  char *v26; // [rsp+30h] [rbp-48h]
  char *v28; // [rsp+88h] [rbp+10h]
  unsigned int v29; // [rsp+98h] [rbp+20h]

  v6 = a2 + a4;
  v8 = 0i64;
  if ( !a1 || !a2 || !a3 || !a4 || !a5 )
    return 0i64;
  v11 = a2 + *(a2 + 8) - a3;
  v28 = v11;
  v12 = a2 + *(a2 + 7) - a3;
  v26 = a2 + *(a2 + 9) - a3;
  if ( a5 <= 0xFFFF )
  {
    if ( a5 < *(a2 + 5) )
    {
      v13 = &v12[4 * (a5 - 1)];
      if ( v13 >= a2 && v13 + 1 > v13 && (v13 + 1) <= v6 )
        v8 = a1 + *v13;
    }
    goto LABEL_34;
  }
  v14 = 0;
  v29 = *(a2 + 6);
  if ( !v29 )
    goto LABEL_34;
  v15 = (a2 + *(a2 + 8) - a3);
  v25 = v11;
  while ( 1 )
  {
    v16 = &v11[4 * v14];
    if ( v16 >= a2 )
      break;
LABEL_25:
    ++v15;
    ++v14;
    v25 = v15;
    if ( v14 >= v29 )
      goto LABEL_34;
  }
  if ( v16 + 4 <= v16
    || v16 + 4 > v6
    || *v15 <= a3
    || (v17 = *v15 - a3, v18 = a2 + v17, v17 >= a4)
    || (v19 = a4 - v17, v20 = a4 - v17, v18 < a2)
    || (v21 = v18 + v19, v21 <= v18)
    || v21 > v6 )
  {
LABEL_24:
    v11 = v28;
    goto LABEL_25;
  }
  if ( !sub_14005D784(v18, a5, v20) )
  {
    v15 = v25;
    goto LABEL_24;
  }
  v22 = &v26[2 * v14];
  if ( v22 >= a2 && v22 + 1 > v22 && (v22 + 1) <= v6 )
  {
    v23 = &v12[4 * *v22];
    if ( v23 >= a2 && v23 + 1 > v23 && (v23 + 1) <= v6 )
      v8 = a1 + *v23;
  }
LABEL_34:
  if ( v8 >= a2 )
    v8 &= -(v6 < v8);
  return v8;
}

//----- (000000014001E410) ----------------------------------------------------
char *__fastcall sub_14001E410(unsigned __int64 a1, unsigned __int64 a2, _BYTE *a3)
{
  _DWORD *v3; // rdi
  _IMAGE_NT_HEADERS *v7; // rsi
  WORD Machine; // ax
  IMAGE_DATA_DIRECTORY *DataDirectory; // rax
  unsigned __int64 VirtualAddress; // rcx
  _DWORD *v11; // rax
  _IMAGE_NT_HEADERS *v12; // rdx
  _DWORD *v13; // rbp
  _DWORD *v14; // r12
  _IMAGE_NT_HEADERS *v15; // rdx
  _DWORD *v16; // rax
  unsigned __int64 v17; // rcx
  _DWORD *v18; // r14
  _IMAGE_NT_HEADERS *v19; // rdx
  _IMAGE_NT_HEADERS *v20; // rax
  unsigned int v21; // ebp
  __int64 i; // r14
  _DWORD *v23; // rax
  _DWORD *v24; // rax
  _IMAGE_NT_HEADERS *v26; // [rsp+60h] [rbp+8h] BYREF
  _DWORD *v27; // [rsp+78h] [rbp+20h] BYREF

  v3 = 0i64;
  if ( !a1 || !a2 || a3 < 0x10000 || !GetModuleInfo(a1, a2, &v27, &v26) )
    return 0i64;
  v7 = v26;
  Machine = v26->FileHeader.Machine;
  if ( Machine == 332 )
  {
    DataDirectory = v26->OptionalHeader.DataDirectory;
  }
  else
  {
    if ( Machine != 0x8664 )
      return 0i64;
    DataDirectory = &v26->OptionalHeader.DataDirectory[2];
  }
  VirtualAddress = DataDirectory->VirtualAddress;
  if ( !VirtualAddress )
    return 0i64;
  if ( !DataDirectory->Size )
    return 0i64;
  v11 = sub_14001D56C(VirtualAddress, v26, a1);
  v13 = v11;
  if ( !v11 )
    return 0i64;
  if ( !v11[5] )
    return 0i64;
  v14 = sub_14001D56C(v11[8], v12, a1);
  v16 = sub_14001D56C(v13[7], v15, a1);
  v17 = v13[9];
  v18 = v16;
  v27 = v16;
  v20 = sub_14001D56C(v17, v19, a1);
  v26 = v20;
  if ( !v14 || !v18 || !v20 )
    return 0i64;
  v21 = v13[6];
  for ( i = 0i64; i < v21; ++v14 )
  {
    v23 = sub_14001D56C(*v14, v7, a1);
    if ( !v23 )
      break;
    if ( sub_14005D784(v23, a3, 0x100ui64) )
    {
      v24 = sub_14001D56C(v27[*(&v26->Signature + i)], v7, a1);
      v3 = v24;
      if ( v24 && v24 >= a1 && v24 < a1 + a2 )
        return v24 - a1;
      return v3;
    }
    i = (i + 1);
  }
  return v3;
}
// 14001E4CC: variable 'v12' is possibly undefined
// 14001E4DA: variable 'v15' is possibly undefined
// 14001E4ED: variable 'v19' is possibly undefined

//----- (000000014001E5A4) ----------------------------------------------------
char __fastcall sub_14001E5A4(ULONG64 BaseModule, CHAR *a2)
{
  char v3; // di
  __int64 v4; // rcx
  int v5; // edx
  __int64 v6; // rcx
  unsigned int *v7; // rcx
  __int64 v8; // rax
  ULONG64 i; // rsi
  __int64 v10; // rax
  CHAR *v11; // rbx
  STRING String2; // [rsp+30h] [rbp-38h] BYREF
  STRING String1; // [rsp+40h] [rbp-28h] BYREF

  v3 = 0;
  if ( BaseModule )
  {
    if ( a2 )
    {
      String2.Buffer = a2;
      v4 = -1i64;
      do
        ++v4;
      while ( a2[v4] );
      String2.Length = v4;
      String2.MaximumLength = v4 + 1;
      if ( v4 )
      {
        v5 = Check_Module_Architecture(BaseModule);
        if ( v5 )
        {
          v6 = 144i64;
          if ( v5 == 32 )
            v6 = 128i64;

          v7 = (BaseModule + *(BaseModule + 0x3C) + v6);
          v8 = *v7;
          if ( v8 )
          {
            if ( v7[1] )
            {
              for ( i = BaseModule + v8; ; i += 0x14i64 )
              {
                EAC_IsUsermodeValidAddress(i, 0x14i64, 1);
                v10 = *(i + 0xC);
                if ( !v10 )
                  break;

                v11 = (BaseModule + v10);
                EAC_IsUsermodeValidAddress(BaseModule + v10, String2.Length, 1);
                String1.Buffer = v11;
                String1.Length = String2.Length;
                String1.MaximumLength = String2.Length;
                if ( !RtlCompareString(&String1, &String2, 1u) )
                  return 1;
              }
            }
          }
        }
      }
    }
  }
  return v3;
}

//----- (000000014001E6D4) ----------------------------------------------------
__int64 __fastcall sub_14001E6D4(__int64 a1)
{
  unsigned int v2; // ebx
  __int64 v3; // rax
  __int64 v4; // rax

  v2 = 0;
  if ( Check_Process_Architecture() == 32 )
  {
    v3 = sub_14001D80C(a1);
    if ( v3 )
      return *(v3 + 52);
  }
  else
  {
    v4 = sub_14001D8AC(a1);
    if ( v4 )
      return *(v4 + 104);
  }
  return v2;
}
// 14001D80C: using guessed type __int64 __fastcall sub_14001D80C(_QWORD);
// 14001D8AC: using guessed type __int64 __fastcall sub_14001D8AC(_QWORD);

//----- (000000014001E728) ----------------------------------------------------
char __fastcall sub_14001E728(ULONG64 BaseModule)
{
  char v2; // bl
  int v3; // edx
  __int64 v4; // rax

  v2 = 0;
  v3 = Check_Module_Architecture(BaseModule);
  if ( v3 )
  {
    v4 = 0xF8i64;
    if ( v3 == 32 )
      v4 = 0xE8i64;

    return *(v4 + BaseModule + *(BaseModule + 0x3C)) != 0;
  }
  return v2;
}

//----- (000000014001E77C) ----------------------------------------------------
char __fastcall sub_14001E77C(ULONG64 BaseModule, __int64 a2, int a3)
{
  char ret; // bl
  int Module_Architecture; // edx
  __int64 v8; // rcx
  unsigned int *v9; // rcx
  __int64 v10; // rax
  ULONG64 v11; // rsi
  __int64 v12; // rax
  ULONG64 v13; // rdi
  unsigned int i; // ecx
  char v15; // dl

  ret = 0;
  if ( !BaseModule || !a2 )
    return 0;

  Module_Architecture = Check_Module_Architecture(BaseModule);
  if ( Module_Architecture )
  {
    v8 = 0xB8i64;
    if ( Module_Architecture == 32 )
      v8 = 0xA8i64;

    v9 = (BaseModule + *(BaseModule + 0x3C) + v8);
    v10 = *v9;
    if ( v10 )
    {
      if ( v9[1] )
      {
        v11 = BaseModule + v10;
        EAC_IsUsermodeValidAddress(BaseModule + v10, 0x1Ci64, 1);
        v12 = *(v11 + 0x14);
        if ( v12 )
        {
          if ( *(v11 + 0xC) == 2 )
          {
            v13 = v12 + BaseModule;
            EAC_IsUsermodeValidAddress(v13 + 0x18, 256i64, 1);
            if ( *(v13 + 0x18) )
            {
              for ( i = 0; i < 0xFF; ++i )
              {
                if ( i >= a3 - 1 )
                  break;

                v15 = *(i + v13 + 0x18);
                if ( !v15 )
                  break;

                *(i + a2) = v15;
              }
              *(i + a2) = 0;
              return 1;
            }
          }
        }
      }
    }
  }
  return ret;
}

//----- (000000014001E884) ----------------------------------------------------
char __fastcall sub_14001E884(unsigned __int64 BaseAddress, unsigned int Size, _OWORD *a3)
{
  char v5; // di
  __int64 v6; // rsi
  _IMAGE_NT_HEADERS *Nt_Headers; // rax
  IMAGE_DATA_DIRECTORY *v8; // r8
  _DWORD *v9; // rax
  _IMAGE_NT_HEADERS *v10; // rdx
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rcx
  __int64 v13; // r14
  char *v14; // rax
  char *v15; // rdx
  char *v16; // rax
  unsigned int v17; // eax
  __int64 v18; // rbx

  v5 = 0;
  if ( a3 )
  {
    if ( BaseAddress )
    {
      v6 = Size;
      Nt_Headers = Get_Nt_Headers(BaseAddress, Size);
      if ( Nt_Headers )
      {
        v8 = &Nt_Headers->OptionalHeader.DataDirectory[6];
        if ( Nt_Headers->OptionalHeader.Magic != 267 )
          v8 = &Nt_Headers->OptionalHeader.DataDirectory[8];
        if ( v8->VirtualAddress )
        {
          if ( v8->Size )
          {
            v9 = sub_14001D56C(v8->VirtualAddress, Nt_Headers, BaseAddress);
            if ( v9 >= BaseAddress && v9 + 7 > v9 )
            {
              v11 = BaseAddress + v6;
              if ( (v9 + 7) <= v11 )
              {
                v12 = v9[5];
                if ( v12 )
                {
                  v13 = v9[4];
                  if ( v13 )
                  {
                    if ( v9[3] == 2 )
                    {
                      v14 = sub_14001D56C(v12, v10, BaseAddress);
                      v15 = v14;
                      if ( v14 >= BaseAddress )
                      {
                        v16 = &v14[v13];
                        if ( v16 > v15 && v16 <= v11 && *v15 == 1396986706 )
                        {
                          v17 = v13 - 25;
                          if ( (v13 - 25) > 0xFF )
                            v17 = 255;
                          v18 = v17;
                          EAC_memcpy(a3, v15 + 24, v17);
                          *(a3 + v18) = 0;
                          return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v5;
}
// 14001E93A: variable 'v10' is possibly undefined

//----- (000000014001E9B4) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001E9B4(unsigned __int64 BaseAddress, unsigned int Size, char Flag)
{
  __int64 ret; // rbx
  unsigned __int64 result; // rax
  __int64 v7; // r12
  _IMAGE_NT_HEADERS *Nt_Headers; // rax
  _IMAGE_NT_HEADERS *Nt_Headers_2; // rdx
  IMAGE_DATA_DIRECTORY *Directory; // r15
  __int64 VirtualAddress; // rax
  unsigned __int64 Directory_Size; // r14
  unsigned int *v13; // rdi
  unsigned int *v14; // rcx
  unsigned int v15; // edx
  __m128i v16; // xmm1
  unsigned int v17; // r8d
  __int64 v18; // rax
  __int64 v19; // rax
  __m128i v20; // [rsp+30h] [rbp-F8h] BYREF
  unsigned int v21; // [rsp+40h] [rbp-E8h]
  __int128 *v22; // [rsp+48h] [rbp-E0h]
  char *v23; // [rsp+50h] [rbp-D8h]
  int v24[6]; // [rsp+58h] [rbp-D0h] BYREF
  __m128 v25[4]; // [rsp+70h] [rbp-B8h] BYREF
  int v26; // [rsp+B8h] [rbp-70h]
  char v27[24]; // [rsp+C0h] [rbp-68h] BYREF
  __m128i v28; // [rsp+D8h] [rbp-50h]
  char v29; // [rsp+F0h] [rbp-38h] BYREF

  ret = 0i64;
  result = 0i64;
  v20 = 0i64;
  v21 = 0;
  if ( BaseAddress && Size )
  {
    v7 = Size;
    Nt_Headers = Get_Nt_Headers(BaseAddress, Size);
    if ( Nt_Headers && Get_Module_Architecture(Nt_Headers) == 64 )
    {
      Directory = &Nt_Headers_2->OptionalHeader.DataDirectory[3];
      if ( Nt_Headers_2->OptionalHeader.Magic != 0x10B )
        Directory = &Nt_Headers_2->OptionalHeader.DataDirectory[5];

      VirtualAddress = Directory->VirtualAddress;
      if ( VirtualAddress )
      {
        Directory_Size = Directory->Size;
        if ( Directory_Size )
        {
          v13 = Flag ? (VirtualAddress + BaseAddress) : sub_14001D56C(VirtualAddress, Nt_Headers_2, BaseAddress);
          if ( v13 >= BaseAddress
            && (v13 + Directory_Size) > v13
            && v13 + Directory_Size <= v7 + BaseAddress
            && !(Directory_Size % 0xC) )
          {
            v14 = v13;
            v15 = 0;
            while ( v14 < &v13[3 * (Directory_Size / 0xC)] )
            {
              if ( v15 > *v14 )
                return ret;
              v15 = *v14;
              v14 += 3;
            }
            if ( v13 )
            {
              v24[0] = 1732584193;
              v24[1] = -271733879;
              v24[2] = -1732584194;
              v24[3] = 271733878;
              v24[4] = -1009589776;
              EAC_memset(v25, 0, 0x48ui64);
              v26 = 0;
              v18 = sub_140010C68(v24, v13, Directory_Size);
              v19 = sub_140010B2C(v18, v27);
              v16 = *v19;
              v28 = *v19;
              v17 = *(v19 + 16);
            }
            else
            {
              v16 = 0i64;
              v17 = 0;
            }
            v22 = &v20;
            v23 = &v29;
            v20 = v16;
            v21 = v17;
            return v17 ^ _mm_cvtsi128_si32(_mm_srli_si128(v16, 8)) ^ _mm_cvtsi128_si32(v16) | ((_mm_cvtsi128_si32(
                                                                                                  _mm_srli_si128(
                                                                                                    v16,
                                                                                                    12)) ^ _mm_cvtsi128_si32(_mm_srli_si128(v16, 4)) ^ Directory->Size) << 32);
          }
        }
      }
    }
    return ret;
  }
  return result;
}
// 14001EA2F: variable 'Nt_Headers_2' is possibly undefined
// 14001E9B4: using guessed type __m128 var_B8[4];
// 14001E9B4: using guessed type char var_68[24];

//----- (000000014001EBF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001EBF0(ULONG64 BaseAddress)
{
  __int64 ret; // rbx
  _IMAGE_NT_HEADERS *Nt_Headers; // rax
  __int64 v5; // rdx
  unsigned int Size; // ebx

  ret = 0i64;
  if ( !BaseAddress )
    return 0i64;

  EAC_IsUsermodeValidAddress(BaseAddress, 0x1000i64, 1);
  Nt_Headers = Get_Nt_Headers(BaseAddress, 0x1000ui64);
  if ( Nt_Headers )
  {
    if ( Get_Module_Architecture(Nt_Headers) == 64 )
    {
      Size = *(v5 + 0x50);
      EAC_IsUsermodeValidAddress(BaseAddress, Size, 1);
      return sub_14001E9B4(BaseAddress, Size, 1);
    }
  }
  return ret;
}
// 14001EC3E: variable 'v5' is possibly undefined

//----- (000000014001EC7C) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001EC7C(unsigned __int64 Address, unsigned int Size)
{
  __m128 *v4; // rsi
  _IMAGE_NT_HEADERS *Nt_Headers; // rcx
  __int64 v6; // rdi
  _IMAGE_NT_HEADERS *NtHeaders; // rdx
  DWORD *p_NumberOfSymbols; // rcx
  __int64 v10; // rax
  __m128i *v11; // rax
  int v12[6]; // [rsp+28h] [rbp-E0h] BYREF
  __m128 v13[4]; // [rsp+40h] [rbp-C8h] BYREF
  int v14; // [rsp+88h] [rbp-80h]
  char v15[24]; // [rsp+90h] [rbp-78h] BYREF
  __m128 v16[32]; // [rsp+A8h] [rbp-60h] BYREF

  EAC_memset(v16, 0, 0x200ui64);
  v4 = v16;
  if ( Address )
  {
    if ( Size >= 0x200 )
    {
      Nt_Headers = Get_Nt_Headers(Address, Size);
      if ( Nt_Headers )
      {
        while ( Nt_Headers > Address )
        {
          Nt_Headers = (Nt_Headers - 4);
          if ( Nt_Headers->Signature == 0x68636952 )
          {
            if ( Nt_Headers > Address )
            {
              v6 = *&Nt_Headers->FileHeader.Machine;
              NtHeaders = Nt_Headers;
              while ( Nt_Headers > Address )
              {
                Nt_Headers = (Nt_Headers - 4);
                if ( (Nt_Headers->Signature ^ v6) == 0x536E6144 )
                {
                  if ( Nt_Headers <= Address )
                    return 0i64;
                  if ( *&Nt_Headers->FileHeader.Machine != v6 )
                    return 0i64;
                  if ( Nt_Headers->FileHeader.TimeDateStamp != v6 )
                    return 0i64;
                  if ( Nt_Headers->FileHeader.PointerToSymbolTable != v6 )
                    return 0i64;
                  p_NumberOfSymbols = &Nt_Headers->FileHeader.NumberOfSymbols;
                  if ( (((NtHeaders - p_NumberOfSymbols) >> 2) - 2) > 0x7E )
                    return 0i64;
                  while ( p_NumberOfSymbols < NtHeaders )
                  {
                    v4->m128_i32[0] = *p_NumberOfSymbols ^ v6;
                    v4 = (v4 + 4);
                    ++p_NumberOfSymbols;
                  }
                  v12[0] = 1732584193;
                  v12[1] = -271733879;
                  v12[2] = -1732584194;
                  v12[3] = 271733878;
                  v12[4] = -1009589776;
                  EAC_memset(v13, 0, 0x48ui64);
                  v14 = 0;
                  v10 = sub_140010C68(v12, v16, v4 - v16);
                  v11 = sub_140010B2C(v10, v15);
                  return _mm_cvtsi128_si32(*v11) ^ _mm_cvtsi128_si32(_mm_srli_si128(*v11, 8)) ^ v11[1].m128i_u32[0] | ((_mm_cvtsi128_si32(_mm_srli_si128(*v11, 4)) ^ _mm_cvtsi128_si32(_mm_srli_si128(*v11, 12)) ^ v6) << 32);
                }
              }
            }
            return 0i64;
          }
        }
      }
    }
  }
  return 0i64;
}
// 14001EC7C: using guessed type __m128 var_268[4];
// 14001EC7C: using guessed type __m128 var_200[32];
// 14001EC7C: using guessed type char var_218[24];

//----- (000000014001EE0C) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001EE0C(ULONG64 Address)
{
  if ( !Address )
    return 0i64;

  EAC_IsUsermodeValidAddress(Address, 4096i64, 1);
  return sub_14001EC7C(Address, 0x1000u);
}

//----- (000000014001EE54) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001EE54(__int64 Address, unsigned int Size)
{
  IMAGE_NT_HEADERS *Nt_Headers; // rax
  __int64 v3; // rbx
  char *v4; // rbx
  __int128 v5; // xmm0
  unsigned int v6; // eax
  __int64 v7; // rax
  __int64 v8; // rax
  int v10[6]; // [rsp+38h] [rbp-31h] BYREF
  __m128 v11[4]; // [rsp+50h] [rbp-19h] BYREF
  int v12; // [rsp+98h] [rbp+2Fh]
  char v13[32]; // [rsp+A0h] [rbp+37h] BYREF

  if ( !Address )
    return 0i64;

  if ( Size < 0x200 )
    return 0i64;

  Nt_Headers = Get_Nt_Headers(Address, Size);
  if ( !Nt_Headers )
    return 0i64;

  v3 = 0x78i64;

  if ( Nt_Headers->OptionalHeader.Magic != 0x10B )
    v3 = 0x88i64;

  v4 = Nt_Headers + v3;
  if ( v4 )
  {
    v10[0] = 1732584193;
    v10[1] = -271733879;
    v10[2] = -1732584194;
    v10[3] = 271733878;
    v10[4] = -1009589776;
    EAC_memset(v11, 0, 0x48ui64);
    v12 = 0;
    v7 = sub_140010C68(v10, v4, 0x80ui64);
    v8 = sub_140010B2C(v7, v13);
    v5 = *v8;
    v6 = *(v8 + 16);
  }
  else
  {
    v5 = 0i64;
    v6 = 0;
  }
  return ((DWORD1(v5) ^ HIDWORD(v5)) << 32) | v5 ^ DWORD2(v5) ^ v6;
}
// 14001EE54: using guessed type __m128 var_70[4];
// 14001EE54: using guessed type char var_20[32];

//----- (000000014001EF3C) ----------------------------------------------------
unsigned __int64 __fastcall sub_14001EF3C(ULONG64 Address)
{
  if ( !Address )
    return 0i64;

  EAC_IsUsermodeValidAddress(Address, 4096i64, 1);
  return sub_14001EE54(Address, 0x1000u);
}

//----- (000000014001EF84) ----------------------------------------------------
bool __fastcall sub_14001EF84(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // rax

  v5 = (loc_1400327F4)(a1, 4096i64, a3, 8i64);
  if ( v5 )
    *v5 = *a4;
  return v5 != 0i64;
}

//----- (000000014001EFB4) ----------------------------------------------------
__int16 *sub_14001EFB4()
{
  unsigned int v0; // edx
  unsigned __int64 v1; // r8
  unsigned __int64 v2; // rdi
  int v3; // ecx
  char v4; // cl
  _BYTE *v5; // rcx
  int v6; // r8d
  int v7; // r9d
  unsigned int v8; // edx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rdi
  char v11; // cl
  __int64 v12; // rdi
  __int16 *v13; // rdx
  __int64 v14; // rcx
  __int16 v15; // ax
  __int16 *v16; // rax
  int v18[6]; // [rsp+0h] [rbp-70h]
  __int16 v19; // [rsp+18h] [rbp-58h]
  _BYTE v20[26]; // [rsp+1Ah] [rbp-56h] BYREF
  int v21[7]; // [rsp+34h] [rbp-3Ch]
  __int16 v22; // [rsp+50h] [rbp-20h]
  _BYTE v23[30]; // [rsp+52h] [rbp-1Eh] BYREF

  if ( !word_140086408 )
  {
    if ( KUSER_SHARED_DATA.NtMajorVersion < 6
      || KUSER_SHARED_DATA.NtMajorVersion == 6 && !KUSER_SHARED_DATA.NtMinorVersion )
    {
      v18[0] = -1169244354;
      v19 = -26463;
      v18[1] = 1561695159;
      v8 = -1171538091;
      v9 = 0i64;
      v18[2] = 867560276;
      v18[3] = -1234988968;
      v10 = 24i64;
      v18[4] = 1133952663;
      v18[5] = -464928738;
      memset(v20, 0, sizeof(v20));
      do
      {
        *&v20[v9 * 4] = v18[v9] ^ v8;
        ++v9;
        v8 = __ROR4__(
               ((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13) ^ (32 * (((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13))),
               2);
      }
      while ( v9 < 6 );
      do
      {
        v11 = v8;
        v8 >>= 8;
        v20[v10] = *(v18 + v10) ^ v11;
        ++v10;
      }
      while ( v10 < 0x1A );
      v5 = v20;
      v6 = 0;
      v7 = 2;
    }
    else
    {
      v21[0] = 220183364;
      v22 = -13391;
      v21[1] = 1567233723;
      v0 = 226147119;
      v1 = 0i64;
      v2 = 28i64;
      v21[2] = -1139719694;
      v21[3] = 725682787;
      v21[4] = -521454772;
      v21[5] = 678319831;
      v21[6] = -1281408437;
      memset(v23, 0, sizeof(v23));
      do
      {
        v3 = v21[v1] ^ v0;
        v0 = ~(214013 * v0 + 2531011);
        *&v23[v1 * 4] = v3;
        ++v1;
      }
      while ( v1 < 7 );
      do
      {
        v4 = v0;
        v0 >>= 8;
        v23[v2] = *(v21 + v2) ^ v4;
        ++v2;
      }
      while ( v2 < 0x1E );
      v5 = v23;
      v6 = 1;
      v7 = 0;
    }
    v12 = 16i64;
    v13 = &word_140086408;
    v14 = v5 - &word_140086408;
    do
    {
      if ( v12 == -2147483630 )
        break;
      v15 = *(v13 + v14);
      if ( !v15 )
        break;
      *v13++ = v15;
      --v12;
    }
    while ( v12 );
    v16 = v13 - 1;
    if ( v12 )
      v16 = v13;
    *v16 = 0;
    if ( v7 )
      memset(v20, 0, sizeof(v20));
    if ( v6 )
      memset(v23, 0, sizeof(v23));
  }
  return &word_140086408;
}
// 140086408: using guessed type __int16 word_140086408;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014001F20C) ----------------------------------------------------
char __fastcall sub_14001F20C(__int64 a1, __int64 a2)
{
  const UNICODE_STRING *v2; // r14
  char v4; // r13
  __int64 v5; // r8
  unsigned int v6; // r12d
  unsigned __int64 BaseAddress; // rbx
  unsigned __int64 Size_1; // r15
  char *v9; // rdi
  _DWORD *v10; // r12
  _IMAGE_NT_HEADERS *Nt_Headers; // rax
  __int64 v12; // rcx
  int *v13; // rcx
  unsigned int v14; // edi
  int v15; // r8d
  unsigned int v16; // edx
  unsigned __int64 v17; // rcx
  char v18; // al
  int v19; // r15d
  char *v20; // r12
  int v21; // r15d
  char *v22; // rcx
  UNICODE_STRING *Memory; // rax
  __int64 Buffer; // rcx
  _IMAGE_NT_HEADERS *NtHeaders_2; // rax MAPDST
  WORD Magic; // ax
  char v28; // cl
  __m128 *v29; // rdi
  _IMAGE_NT_HEADERS *NtHeaders_1; // rcx
  __int64 v31; // r15
  _IMAGE_NT_HEADERS *v32; // rdx
  DWORD *p_NumberOfSymbols; // rcx
  unsigned __int64 v34; // rdi
  bool v35; // zf
  _IMAGE_NT_HEADERS *NtHeaders; // rax
  __int64 v37; // rdi
  char *v38; // rdi
  __int128 v39; // xmm0
  unsigned int v40; // eax
  __int64 v41; // rax
  __m128i *v42; // rax
  unsigned __int64 v43; // rdi
  __int64 v44; // rax
  __int64 v45; // rax
  unsigned __int64 v46; // rdx
  __int64 v48; // [rsp+20h] [rbp-E0h]
  char *v49; // [rsp+38h] [rbp-C8h] BYREF
  __int128 v50; // [rsp+40h] [rbp-C0h] BYREF
  __int128 v51; // [rsp+50h] [rbp-B0h]
  __int64 v52; // [rsp+60h] [rbp-A0h]
  __int128 v53; // [rsp+68h] [rbp-98h] BYREF
  struct _UNICODE_STRING unicode_string; // [rsp+80h] [rbp-80h] BYREF
  int v55; // [rsp+90h] [rbp-70h] BYREF
  int v56; // [rsp+94h] [rbp-6Ch]
  int v57; // [rsp+98h] [rbp-68h]
  int v58; // [rsp+9Ch] [rbp-64h]
  int v59; // [rsp+A0h] [rbp-60h]
  __m128 v60[4]; // [rsp+A8h] [rbp-58h] BYREF
  int v61; // [rsp+F0h] [rbp-10h]
  __m128 v62[35]; // [rsp+100h] [rbp+0h] BYREF
  unsigned __int64 Buf; // [rsp+348h] [rbp+248h] BYREF
  char v64; // [rsp+350h] [rbp+250h]
  ULONG Size; // [rsp+358h] [rbp+258h] BYREF

  v2 = 0i64;
  v64 = 0;
  Buf = 0i64;
  Size = 0;
  v4 = 0;
  unicode_string = 0i64;
  if ( !a2 || !a1 || !*(a1 + 8) || !*a1 || !*(a1 + 2) )
    return 0;

  memset(a2, 0, 0x338ui64);
  sub_14005D720(a2, 256i64, a1);
  if ( sub_14003F39C(v5, &unicode_string) )
  {
    if ( EAC_ReadFile(&unicode_string, &Buf, &Size) )
    {
      v6 = Size;
      BaseAddress = Buf;
      Size_1 = Size;
      v48 = Size;
      if ( Buf && Size )
      {
        v9 = (Size + Buf);
        v49 = v9;
        v10 = 0i64;
        Nt_Headers = Get_Nt_Headers(Buf, Size);
        if ( Nt_Headers )
        {
          v12 = 152i64;
          if ( Nt_Headers->OptionalHeader.Magic != 0x10B )
            v12 = 168i64;

          v13 = (Nt_Headers + v12);
          if ( v13 )
          {
            if ( v13 >= BaseAddress && v13 + 2 > v13 && v13 + 2 <= v9 )
            {
              v14 = v13[1];
              if ( v14 )
              {
                v15 = *v13;
                if ( *v13 )
                {
                  v16 = 0;
                  while ( 1 )
                  {
                    v17 = BaseAddress + v15 + v16;
                    if ( v17 < BaseAddress || v17 + 12 <= v17 || v17 + 12 > v49 || !*v17 )
                    {
LABEL_26:
                      v18 = 0;
                      goto LABEL_28;
                    }
                    if ( *(v17 + 6) == 2 )
                      break;
                    v16 += *v17;
                    if ( v16 >= v14 )
                      goto LABEL_26;
                  }
                  v10 = (BaseAddress + v15 + v16);
                  v18 = 1;
LABEL_28:
                  if ( v18 )
                  {
                    v19 = *v10;
                    v20 = (v10 + 2);
                    v21 = v19 - 8;
                    if ( v20 >= BaseAddress )
                    {
                      v22 = &v20[v21];
                      if ( v22 > v20 && v22 <= BaseAddress + v48 )
                      {
                        Memory = EAC_Allocate_Memory(0x48ui64);
                        v2 = Memory;
                        if ( Memory )
                        {
                          v52 = 0i64;
                          v49 = v20;
                          LODWORD(Buf) = v21;
                          memset(Memory, 0, 0x48ui64);
                          v50 = 0i64;
                          v51 = 0i64;
                          if ( v20
                            && v21
                            && (memset(Memory, 0, 0x48ui64), sub_14004803C(1, &v49, &Buf, &v50))
                            && v50 == 16
                            && sub_14004803C(1, &v49, &Buf, &v50)
                            && v50 == 6
                            && v51 == 9
                            && **(&v50 + 1) == 0x7010DF78648862Ai64
                            && *(*(&v50 + 1) + 8i64) == 2
                            && sub_14004803C(1, &v49, &Buf, &v50)
                            && !v50
                            && sub_14004803C(1, &v49, &Buf, &v50)
                            && v50 == 16
                            && v51
                            && sub_1400109F0(*(&v50 + 1), v51, v2) )
                          {
                            v4 = 1;
                          }
                          else
                          {
                            Get_ExFreePool(v2);
                          }
                        }
                      }
                    }
                    Size_1 = v48;
                  }
                }
              }
            }
          }
        }
        v6 = Size;
        if ( v4 )
        {
          sub_14005D720(a2 + 568, 256i64, &v2[1].Length);
          if ( !RtlCompareUnicodeString(v2 + 1, v2, 0) )
            *(a2 + 257) = 1;
          if ( v2 )
          {
            Buffer = v2->Buffer;
            if ( Buffer )
            {
              Get_ExFreePool(Buffer);
              *v2 = 0i64;
            }
            EAC_Free_UnicodeString(&v2[1]);
            Get_ExFreePool(v2);
          }
        }
      }
      NtHeaders_2 = Get_Nt_Headers(BaseAddress, Size_1);
      if ( NtHeaders_2 )
      {
        Magic = NtHeaders_2->OptionalHeader.Magic;
        v4 = 1;
        if ( Magic == 267 )
          v28 = 32;
        else
          v28 = Magic != 523 ? 0 : 0x40;
        *(a2 + 256) = v28;
        EAC_memset(v62, 0, 0x200ui64);
        v29 = v62;
        if ( BaseAddress )
        {
          if ( v6 >= 0x200 )
          {
            NtHeaders_1 = Get_Nt_Headers(BaseAddress, Size_1);
            if ( NtHeaders_1 )
            {
              while ( NtHeaders_1 > BaseAddress )
              {
                NtHeaders_1 = (NtHeaders_1 - 4);
                if ( NtHeaders_1->Signature == 0x68636952 )
                {
                  if ( NtHeaders_1 <= BaseAddress )
                    break;
                  v31 = *&NtHeaders_1->FileHeader.Machine;
                  v32 = NtHeaders_1;
                  do
                  {
                    if ( NtHeaders_1 <= BaseAddress )
                      goto LABEL_76;
                    NtHeaders_1 = (NtHeaders_1 - 4);
                  }
                  while ( (NtHeaders_1->Signature ^ v31) != 0x536E6144 );

                  if ( NtHeaders_1 <= BaseAddress
                    || *&NtHeaders_1->FileHeader.Machine != v31
                    || NtHeaders_1->FileHeader.TimeDateStamp != v31
                    || NtHeaders_1->FileHeader.PointerToSymbolTable != v31
                    || (p_NumberOfSymbols = &NtHeaders_1->FileHeader.NumberOfSymbols,
                        (((v32 - p_NumberOfSymbols) >> 2) - 2) > 0x7E) )
                  {
LABEL_76:
                    Size_1 = v6;
                    break;
                  }
                  while ( p_NumberOfSymbols < v32 )
                  {
                    v29->m128_i32[0] = *p_NumberOfSymbols ^ v31;
                    v29 = (v29 + 4);
                    ++p_NumberOfSymbols;
                  }
                  v55 = 1732584193;
                  v56 = -271733879;
                  v57 = -1732584194;
                  v58 = 271733878;
                  v59 = -1009589776;
                  EAC_memset(v60, 0, 0x48ui64);
                  v61 = 0;
                  v41 = sub_140010C68(&v55, v62, v29 - v62);
                  v42 = sub_140010B2C(v41, &v53);
                  v43 = v31 ^ _mm_cvtsi128_si32(_mm_srli_si128(*v42, 4)) ^ _mm_cvtsi128_si32(_mm_srli_si128(*v42, 12));
                  Size_1 = v6;
                  v34 = _mm_cvtsi128_si32(*v42) ^ _mm_cvtsi128_si32(_mm_srli_si128(*v42, 8)) ^ v42[1].m128i_u32[0] | (v43 << 32);
                  goto LABEL_78;
                }
              }
            }
          }
        }
        v34 = 0i64;
LABEL_78:
        v35 = *(a2 + 256) == 64;
        *(a2 + 280) = v34;
        if ( v35 )
          *(a2 + 288) = sub_14001E9B4(BaseAddress, v6, 0);
        *(a2 + 304) = NtHeaders_2->OptionalHeader.AddressOfEntryPoint;
        *(a2 + 308) = NtHeaders_2->OptionalHeader.SizeOfCode;
        if ( BaseAddress && v6 >= 0x200 && (NtHeaders = Get_Nt_Headers(BaseAddress, Size_1)) != 0i64 )
        {
          v37 = 120i64;
          if ( NtHeaders->OptionalHeader.Magic != 267 )
            v37 = 136i64;
          v38 = NtHeaders + v37;
          if ( v38 )
          {
            v55 = 1732584193;
            v56 = -271733879;
            v57 = -1732584194;
            v58 = 271733878;
            v59 = -1009589776;
            EAC_memset(v60, 0, 0x48ui64);
            v61 = 0;
            v44 = sub_140010C68(&v55, v38, 0x80ui64);
            v45 = sub_140010B2C(v44, &v50);
            v39 = *v45;
            v40 = *(v45 + 16);
          }
          else
          {
            v39 = 0i64;
            v40 = 0;
          }
          v53 = v39;
          v46 = ((DWORD1(v39) ^ HIDWORD(v39)) << 32) | v39 ^ DWORD2(v39) ^ v40;
        }
        else
        {
          v46 = 0i64;
        }
        *(a2 + 296) = v46;
        sub_14001E884(BaseAddress, v6, (a2 + 312));
        *(a2 + 260) = NtHeaders_2->OptionalHeader.CheckSum;
        *(a2 + 268) = NtHeaders_2->OptionalHeader.SizeOfImage;
        *(a2 + 264) = NtHeaders_2->FileHeader.TimeDateStamp;
      }
      else
      {
        v4 = v64;
      }
      *(a2 + 272) = v6;
      if ( BaseAddress )
        Get_ExFreePool(BaseAddress);
    }
    EAC_Free_UnicodeString(&unicode_string);
  }
  return v4;
}
// 14001F374: conditional instruction was optimized away because edi.4!=0
// 14001F2A4: variable 'v5' is possibly undefined
// 1400109F0: using guessed type __int64 __fastcall sub_1400109F0(_QWORD, _QWORD, _QWORD);
// 14001F20C: using guessed type __m128 var_230[35];
// 14001F20C: using guessed type __m128 var_288[4];
// 14001F20C: using guessed type __int128 var_2C8;

//----- (000000014001F8E4) ----------------------------------------------------
char __fastcall sub_14001F8E4(__int64 Process, __int64 eData)
{
  __int64 v4; // rcx
  unsigned __int16 *Buffer; // rdi MAPDST
  _KAPC_STATE ApcState; // [rsp+20h] [rbp-38h] BYREF

  if ( !Process || !eData || !sub_140052928(Process) )
    return 0;

  memset(eData, 0, 0x338ui64);
  if ( Get_KeStackAttachProcess(Process, &ApcState) )
  {
    LOBYTE(v4) = 1;
    Buffer = (loc_140008758)(v4);
    if ( Buffer )
    {
      *(eData + 0x100) = *(*Buffer + 0x1Ei64);
      sub_14005D720(eData, 0x100i64, Buffer + 0xC);
      *(eData + 0x104) = *(*Buffer + 0x250i64);
      *(eData + 0x10C) = *(*Buffer + 0x240i64);
      *(eData + 0x108) = *(*Buffer + 0x234i64);
      *(eData + 0x130) = *(*Buffer + 0x24Ci64);
      *(eData + 0x134) = *(*Buffer + 0x248i64);
      sub_14001E77C(*(*Buffer + 0xEi64), eData + 0x138, 0x100);
      *(eData + 0x118) = sub_14001EE0C(*(*Buffer + 0xEi64));
      *(eData + 0x120) = sub_14001EBF0(*(*Buffer + 0xEi64));
      *(eData + 0x128) = sub_14001EF3C(*(*Buffer + 0xEi64));
      sub_140008BF4(Buffer);
    }
    (loc_140054154)(Process, &ApcState);        // KeUnstackDetachProcess
  }
  return 1;
}
// 14001F93B: variable 'v4' is possibly undefined
// 14001F8E4: using guessed type _KAPC_STATE ApcState;

//----- (000000014001FF98) ----------------------------------------------------
__int64 __fastcall Get_ObReferenceObjectByName(_UNICODE_STRING *String)
{
  __int64 ObjectType; // rdi
  int (__fastcall *g_ObReferenceObjectByName)(_UNICODE_STRING *, __int64, __int64, _QWORD, __int64, char, _QWORD, __int64 *); // rax
  __int64 AccessState; // r8
  char AccessMode; // [rsp+28h] [rbp-30h]
  _UNICODE_STRING ObjectName; // [rsp+40h] [rbp-18h] BYREF
  __int64 Object; // [rsp+68h] [rbp+10h] BYREF

  Object = 0i64;
  ObjectType = sub_14004CB58();

  if ( !ObjectType
    || !String
    || !String->Buffer
    || !String->Length
    || !String->MaximumLength
    || !EAC_Allocate_Unicode_string(&ObjectName, &String->Length, String->Length) )
  {
    return 0i64;
  }

  g_ObReferenceObjectByName = (loc_14005B768)(qword_140086010, &qword_140086010, 0i64);
  if ( !g_ObReferenceObjectByName
    || (AccessMode = 0,
        g_ObReferenceObjectByName(&ObjectName, 0x240i64, AccessState, 0i64, ObjectType, AccessMode, 0i64, &Object) < 0) )// ObReferenceObjectByName
  {
    Object = 0i64;
  }

  EAC_Free_UnicodeString(&ObjectName);

  return Object;
}
// 140020033: variable 'AccessState' is possibly undefined
// 140086010: using guessed type __int64 qword_140086010;
// 14001FF98: using guessed type _UNICODE_STRING ObjectName;

//----- (0000000140020064) ----------------------------------------------------
__int64 __fastcall sub_140020064(_UNICODE_STRING *unicode_string_1)
{
  __int64 ret; // rbx
  int v3; // edx
  unsigned __int64 i; // rdi
  LONG CompareString; // edx
  bool v6; // r14
  unsigned __int16 v7; // r8
  unsigned int v8; // edx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rdi
  char v11; // cl
  USHORT Length; // dx
  bool v13; // zf
  int v15[2]; // [rsp+30h] [rbp-29h] BYREF
  __int16 v16; // [rsp+38h] [rbp-21h]
  _BYTE v17[10]; // [rsp+3Ah] [rbp-1Fh] BYREF
  int v18[5]; // [rsp+44h] [rbp-15h] BYREF
  _UNICODE_STRING unicode_string; // [rsp+58h] [rbp-1h] BYREF
  _UNICODE_STRING Unicode_striig; // [rsp+68h] [rbp+Fh] BYREF
  __int16 String[28]; // [rsp+78h] [rbp+1Fh] BYREF
  int *string; // [rsp+C0h] [rbp+67h] BYREF
  _BYTE *v23; // [rsp+C8h] [rbp+6Fh] BYREF
  int v24; // [rsp+D0h] [rbp+77h]
  int v25; // [rsp+D8h] [rbp+7Fh]

  v18[0] = 363970220;
  v18[1] = 1999217210;
  *String = 0i64;
  v18[2] = -99958578;
  ret = 0i64;
  v18[3] = -602360981;
  string = v18;
  v3 = 1601502580;
  for ( i = 0i64; i < 0x10; i += 4i64 )
  {
    v3 = __ROL4__(24437 * v3 + 7667060, 1);
    *&String[i / 2] = string[i / 4] ^ v3;
  }
  if ( unicode_string_1 )
  {
    if ( unicode_string_1->Buffer )
    {
      if ( unicode_string_1->Length )
      {
        if ( unicode_string_1->MaximumLength )
        {
          Get_Unicode_string_Inline(&Unicode_striig, String);
          if ( Unicode_striig.Buffer )
          {
            if ( Unicode_striig.Length && Unicode_striig.MaximumLength )
            {
              v24 = -902506543;
              LODWORD(string) = 92;
              CompareString = Get_CompareUnicodeString(&Unicode_striig, &string);
              v6 = CompareString == 0;
              v7 = unicode_string_1->Length + Unicode_striig.Length;
              memset(&string, 0, 4ui64);
              if ( CompareString )
                v7 += 2;
              if ( EAC_Allocate_Unicode_string(&unicode_string, &Unicode_striig.Length, v7) )
              {
                if ( !v6 )
                {
                  v25 = 0x5B6002D0;
                  LODWORD(v23) = 92;
                  sub_14005D584(&unicode_string.Length, &v23);
                  memset(&v23, 0, 4ui64);
                }
                if ( sub_14005D620(&unicode_string, unicode_string_1) >= 0 )
                {
                  v15[0] = -883691539;
                  v16 = 14352;
                  v8 = -887033917;
                  v15[1] = -1421346037;
                  memset(v17, 0, sizeof(v17));
                  v9 = 0i64;
                  v10 = 8i64;
                  do
                  {
                    *&v17[v9 * 4] = v15[v9] ^ v8;
                    ++v9;
                    v8 = __ROL4__(
                           ((v8 ^ (v8 << 13)) >> 7) ^ v8 ^ (v8 << 13) ^ ((((v8 ^ (v8 << 13)) >> 7) ^ v8 ^ (v8 << 13)) << 17),
                           2);
                  }
                  while ( v9 < 2 );
                  string = v15;
                  v23 = v17;
                  do
                  {
                    v11 = v8;
                    v8 >>= 8;
                    v23[v10] = *(string + v10) ^ v11;
                    ++v10;
                  }
                  while ( v10 < 0xA );
                  Length = unicode_string.Length;
                  v13 = *&unicode_string.Buffer[(unicode_string.Length >> 1) - 4] == *v17;
                  memset(v17, 0, sizeof(v17));
                  if ( v13 )
                  {
                    unicode_string.Length -= 8;
                    unicode_string.Buffer[(Length - 8) >> 1] = 0;
                  }
                  ret = Get_ObReferenceObjectByName(&unicode_string);
                }
                EAC_Free_UnicodeString(&unicode_string);
              }
            }
          }
        }
      }
    }
  }

  memset(String, 0, 0x10ui64);

  return ret;
}
// 140020064: using guessed type WCHAR String[28];

//----- (0000000140020850) ----------------------------------------------------
__int64 sub_140020850()
{
  __int64 result; // rax
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 (__fastcall *v3)(__int64, _QWORD, int *, _QWORD, __int64, __int64 *); // rax
  __int64 v4; // r8
  __int64 v5; // [rsp+20h] [rbp-18h]

  if ( qword_140085950 )
    return 0xC0000001i64;

  v1 = (loc_14005B768)(qword_1400856C0, &qword_1400856C0, 0i64);
  v2 = (loc_14005B768)(qword_1400856C8, &qword_1400856C8);
  if ( !v1 || !v2 )
    return 0i64;

  v3 = (loc_14005B768)(qword_1400856C0, &qword_1400856C0);
  if ( v3 )
  {
    result = v3(1i64, 0i64, &dword_14004AA64, 0i64, v4 & v5, &qword_140085950);
    if ( result >= 0 )
      return result;
  }
  else
  {
    result = 0xC0000002i64;
  }
  qword_140085950 = 0i64;
  return result;
}
// 1400208C9: variable 'v4' is possibly undefined
// 1400208C9: variable 'v5' is possibly undefined
// 14004AA64: using guessed type int dword_14004AA64;
// 1400856C0: using guessed type __int64 qword_1400856C0;
// 1400856C8: using guessed type __int64 qword_1400856C8;
// 140085950: using guessed type __int64 qword_140085950;

//----- (00000001400208F8) ----------------------------------------------------
void sub_1400208F8()
{
  __int64 v0; // rbx
  void (__fastcall *v1)(__int64); // rax

  v0 = _InterlockedExchange64(&qword_140085950, 0i64);
  if ( v0 )
  {
    v1 = (loc_14005B768)(qword_1400856C8, &qword_1400856C8, 0i64);
    if ( v1 )
      v1(v0);
  }
}
// 1400856C8: using guessed type __int64 qword_1400856C8;
// 140085950: using guessed type __int64 qword_140085950;

//----- (0000000140020934) ----------------------------------------------------
__int64 sub_140020934(_WORD *DstBuf, __int64 Count, __int64 format, ...)
{
  unsigned int v4; // edi
  unsigned __int64 v5; // rsi
  int Value; // eax
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, format);
  if ( (Count - 1) <= 0x7FFFFFFE )
  {
    v5 = Count - 1;
    v4 = 0;
    Value = Get_vsprintf(DstBuf, Count - 1, format, va);
    if ( Value < 0 || Value > v5 )
    {
      v4 = 0x80000005;
    }
    else if ( Value != v5 )
    {
      return v4;
    }
    DstBuf[v5] = 0;
    return v4;
  }

  v4 = 0xC000000D;

  if ( Count )
    *DstBuf = 0;

  return v4;
}

//----- (0000000140020FF4) ----------------------------------------------------
__int64 sub_140020FF4()
{
  __int64 result; // rax
  __int64 v1; // rcx
  int v2[8]; // [rsp+20h] [rbp-20h] BYREF

  result = dword_140083038;
  if ( dword_140083038 == -1 )
  {
    v2[0] = 2021405580;
    v2[1] = -563060562;
    v2[2] = -185143729;
    v2[3] = -809132358;
    v2[4] = -1413039342;
    v1 = (loc_14003CB4C)(v2);
    result = 0i64;
    if ( v1 && *v1 == 72 && *(v1 + 1) == 0x818B )
      result = *(v1 + 3);
    dword_140083038 = result;
  }
  return result;
}
// 140083038: using guessed type int dword_140083038;

//----- (0000000140021060) ----------------------------------------------------
__int64 __fastcall EAC_Get_EPROCESS(PEPROCESS Process)
{
  unsigned int v1; // r8d
  int v3; // eax
  __int64 result; // rax

  v1 = dword_140083034;
  if ( dword_140083034 == -1 )
  {
    v3 = sub_140020FF4();
    v1 = v3 != 0 ? v3 + 8 : 0;
    dword_140083034 = v1;
  }
  if ( !v1 )
    return 0i64;

  if ( !Process )
    Process = PsInitialSystemProcess;
  result = *(Process + v1) - v1;

  if ( ((Process ^ result) & 0xFFFFFFFF00000000ui64) != 0 )
    return 0i64;

  return result;
}
// 140020FF4: using guessed type __int64 sub_140020FF4(void);
// 140083034: using guessed type int dword_140083034;

//----- (00000001400210C8) ----------------------------------------------------
__int64 __fastcall sub_1400210C8(unsigned __int8 *a1, __int64 a2)
{
  _BYTE *v3; // rbx
  char v4; // r14
  unsigned __int8 v5; // dl
  unsigned __int8 v6; // r13
  unsigned __int8 *v7; // r9
  char v8; // r11
  unsigned int v9; // r10d
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  char v12; // al
  char v13; // cl
  int v14; // r11d
  unsigned __int8 v15; // bp
  unsigned __int16 v16; // si
  unsigned __int8 v17; // r12
  __int16 v18; // di
  char v19; // r15
  int v20; // ebx
  int v21; // ebx
  int v22; // r10d
  unsigned __int8 v23; // r14
  char v24; // cl
  unsigned __int8 v25; // al
  unsigned __int8 v26; // r14
  unsigned __int8 v27; // r11
  int v28; // eax
  unsigned __int8 v29; // di
  __int64 v30; // rdx
  unsigned __int8 v31; // cl
  char v32; // r11
  bool v33; // sf
  char v34; // bl
  char v35; // dl
  _BYTE *v36; // r10
  _BYTE *v37; // rcx
  _BYTE *v38; // rdx
  _BYTE *v39; // rcx
  bool v40; // zf
  unsigned __int8 v41; // dl
  unsigned __int8 *v42; // r9
  char v43; // al
  char v44; // dl
  unsigned __int8 *v45; // r9
  __int16 v46; // ax
  __int64 v47; // rax
  __int16 v48; // ax
  char v49; // al
  unsigned __int8 v50; // al
  unsigned __int8 v51; // r9
  int v53; // eax
  int v54; // eax
  char v55; // [rsp+0h] [rbp-58h]
  char v56; // [rsp+60h] [rbp+8h]
  unsigned __int8 v57; // [rsp+68h] [rbp+10h]
  unsigned __int8 v58; // [rsp+70h] [rbp+18h]
  char v59; // [rsp+78h] [rbp+20h]

  v56 = a1;
  v3 = &unk_140073650;
  v4 = 0;
  v5 = 0;
  v55 = 0;
  v6 = 0;
  v7 = a1;
  v8 = 16;
  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 32) = 0;
  *(a2 + 36) = 0;
  do
  {
    v9 = *v7++;
    if ( v9 > 0x65 )
    {
      switch ( v9 )
      {
        case 102u:
          *(a2 + 4) = 102;
          v12 = 8;
          break;
        case 103u:
          *(a2 + 5) = 103;
          v12 = 16;
          break;
        case 240u:
          *(a2 + 2) = -16;
          v12 = 32;
          break;
        case 242u:
          *(a2 + 1) = -14;
          v12 = 2;
          break;
        case 243u:
          *(a2 + 1) = -13;
          v12 = 4;
          break;
        default:
          goto LABEL_17;
      }
      goto LABEL_16;
    }
    v10 = v9 - 38;
    if ( v10 > 0x3F )
      break;
    v11 = 0xC000000001010101ui64;
    if ( !_bittest64(&v11, v10) )
      break;
    *(a2 + 3) = v9;
    v12 = 64;
LABEL_16:
    v5 |= v12;
    --v8;
  }
  while ( v8 );
LABEL_17:
  v13 = 1;
  v14 = v5 << 23;
  *(a2 + 33) = v14;
  if ( v5 )
    v13 = v5;
  if ( (v9 & 0xF0) == 64 )
  {
    v14 |= 0x40000000u;
    *(a2 + 33) = v14;
    *(a2 + 7) = (v9 & 8) != 0;
    if ( (v9 & 8) != 0 )
    {
      v4 = (*v7 & 0xF8) == 0xB8;
      v55 = v4;
    }
    *(a2 + 8) = (v9 & 4) != 0;
    *(a2 + 10) = v9 & 1;
    *(a2 + 9) = (v9 & 2) != 0;
    LOBYTE(v9) = *v7++;
    if ( (v9 & 0xF0) == 64 )
    {
      v57 = v9;
      v15 = v13;
      goto LABEL_32;
    }
  }
  *(a2 + 11) = v9;
  v15 = v13;
  if ( v9 == 15 )
  {
    LOBYTE(v9) = *v7;
    v3 = &unk_14007369A;
    *(a2 + 12) = *v7++;
  }
  else if ( v9 >= 0xA0u && v9 <= 0xA3u )
  {
    v55 = ++v4;
    if ( (v13 & 0x10) != 0 )
      v15 = v13 | 8;
    else
      v15 = v13 & 0xF7;
  }
  v57 = v9;
  LOBYTE(v16) = v3[v3[v9 >> 2] + (v9 & 3)];
  if ( v16 == 0xFF )
  {
LABEL_32:
    v14 |= 0x3000u;
    *(a2 + 33) = v14;
    LOBYTE(v16) = 0;
    if ( (v9 & 0xFD) == 36 )
    {
      LOBYTE(v16) = 1;
      v17 = v9;
      LOBYTE(v18) = 0;
      goto LABEL_36;
    }
  }
  LOBYTE(v18) = 0;
  v17 = v9;
  if ( (v16 & 0x80u) != 0 )
  {
    v16 = *&v3[v16 & 0x7F];
    v18 = HIBYTE(v16);
  }
LABEL_36:
  v19 = *(a2 + 12);
  v20 = v14;
  if ( v19 && (v15 & *(&unk_140073650 + (v9 & 3) + *(&unk_140073650 + (v9 >> 2) + 316) + 316)) != 0 )
  {
    v20 = v14 | 0x3000;
    *(a2 + 33) = v14 | 0x3000;
  }
  if ( (v16 & 1) == 0 )
  {
    if ( (v15 & 0x20) != 0 )
      *(a2 + 33) = v20 | 0x9000;
    goto LABEL_132;
  }
  v21 = v20 | 1;
  *(a2 + 33) = v21;
  v22 = v21;
  v23 = *v7;
  *(a2 + 13) = *v7;
  v24 = v23 >> 6;
  v25 = v23 & 7;
  v26 = (v23 >> 3) & 7;
  v59 = v24;
  *(a2 + 14) = v24;
  v58 = v25;
  *(a2 + 16) = v25;
  *(a2 + 15) = v26;
  if ( v18 && ((v18 << v26) & 0x80u) != 0 )
  {
    v22 = v21 | 0x3000;
    *(a2 + 33) = v21 | 0x3000;
  }
  v27 = v57;
  v28 = v22;
  if ( v19 || v57 < 0xD9u || v57 > 0xDFu )
  {
    v29 = v58;
  }
  else
  {
    v29 = v58;
    v30 = (v57 + 39);
    if ( v24 == 3 )
    {
      v31 = v58;
      v32 = *(&unk_140073650 + 8 * v30 + v26 + 260);
    }
    else
    {
      v31 = v26;
      v32 = *(&unk_140073650 + v30 + 253);
    }
    v28 = v22;
    v33 = ((v32 << v31) & 0x80u) != 0;
    v27 = v57;
    if ( v33 )
    {
      v28 = v22 | 0x3000;
      *(a2 + 33) = v22 | 0x3000;
    }
  }
  v34 = v59;
  if ( (v15 & 0x20) != 0 )
  {
    if ( v59 == 3 )
    {
      *(a2 + 33) = v28 | 0x9000;
    }
    else
    {
      v35 = v27;
      if ( !v19 )
        v35 = v27 & 0xFE;
      v36 = &unk_140073828;
      if ( !v19 )
        v36 = &unk_140073816;
      v37 = &unk_140073816;
      if ( !v19 )
        v37 = &unk_1400737FE;
      while ( v37 != v36 )
      {
        if ( *v37 == v35 )
        {
          if ( ((v37[1] << v26) & 0x80u) == 0 )
            goto LABEL_68;
          break;
        }
        v37 += 2;
      }
      *(a2 + 33) |= 0x9000u;
    }
  }
LABEL_68:
  if ( !v19 )
  {
    if ( v17 != 140 )
    {
      if ( v17 != 142 )
        goto LABEL_80;
      if ( v26 == 1 )
        goto LABEL_102;
    }
    if ( v26 > 5u )
      goto LABEL_102;
    goto LABEL_103;
  }
  switch ( v17 )
  {
    case ' ':
      goto LABEL_75;
    case '!':
      goto LABEL_73;
    case '"':
LABEL_75:
      v34 = 3;
      if ( v26 <= 4u && v26 != 1 )
        goto LABEL_103;
      goto LABEL_102;
  }
  if ( v17 != 35 )
  {
LABEL_80:
    if ( v59 == 3 )
    {
      if ( v19 )
      {
        v38 = &unk_140073861;
        v39 = &unk_140073837;
      }
      else
      {
        v38 = &unk_140073837;
        v39 = &unk_140073828;
      }
      while ( *v39 != v27 )
      {
        v39 += 3;
        if ( v39 == v38 )
          goto LABEL_103;
      }
      if ( (v15 & v39[1]) == 0 || ((v39[2] << v26) & 0x80u) != 0 )
        goto LABEL_103;
LABEL_102:
      *(a2 + 33) |= 0x11000u;
      goto LABEL_103;
    }
    if ( !v19 )
      goto LABEL_103;
    if ( v17 != 80 )
    {
      if ( v17 == 197 )
        goto LABEL_102;
      if ( v17 == 214 )
      {
        v40 = (v15 & 6) == 0;
LABEL_97:
        if ( !v40 )
          goto LABEL_102;
        goto LABEL_103;
      }
      if ( v17 != 215 && v17 != 247 )
        goto LABEL_103;
    }
    v40 = (v15 & 9) == 0;
    goto LABEL_97;
  }
LABEL_73:
  v34 = 3;
  if ( (v26 - 4) <= 1u )
    goto LABEL_102;
LABEL_103:
  v41 = v7[1];
  v42 = v7 + 2;
  if ( v26 <= 1u )
  {
    if ( v27 == 0xF6 )
    {
      LOBYTE(v16) = v16 | 2;
    }
    else if ( v27 == 0xF7 )
    {
      LOBYTE(v16) = v16 | 0x10;
    }
  }
  if ( v34 )
  {
    if ( v34 == 1 )
    {
      v6 = 1;
    }
    else if ( v34 == 2 )
    {
      v6 = 2;
      if ( (v15 & 0x10) == 0 )
        v6 = 4;
    }
  }
  else if ( (v15 & 0x10) != 0 )
  {
    v6 = v29 != 6 ? 0 : 2;
  }
  else
  {
    v6 = 0;
    if ( v29 == 5 )
      v6 = 4;
  }
  if ( v34 != 3 && v29 == 4 )
  {
    *(a2 + 33) |= 2u;
    ++v42;
    *(a2 + 18) = v41 >> 6;
    v43 = (v41 >> 3) & 7;
    *(a2 + 17) = v41;
    v44 = v41 & 7;
    *(a2 + 19) = v43;
    *(a2 + 20) = v44;
    if ( v44 == 5 && (v34 & 1) == 0 )
      v6 = 4;
  }
  v45 = v42 - 1;
  switch ( v6 )
  {
    case 1u:
      *(a2 + 33) |= 0x40u;
      *(a2 + 29) = *v45;
      break;
    case 2u:
      *(a2 + 33) |= 0x80u;
      *(a2 + 29) = *v45;
      break;
    case 4u:
      *(a2 + 33) |= 0x100u;
      *(a2 + 29) = *v45;
      break;
  }
  v4 = v55;
  v7 = &v45[v6];
LABEL_132:
  if ( (v16 & 0x10) != 0 )
  {
    if ( (v16 & 0x40) != 0 )
    {
      if ( (v15 & 8) != 0 )
      {
        *(a2 + 33) |= 0x208u;
        v46 = *v7;
        LOBYTE(v7) = v7 + 2;
        *(a2 + 21) = v46;
        goto LABEL_145;
      }
LABEL_150:
      *(a2 + 33) |= 0x210u;
      v54 = *v7;
      LOBYTE(v7) = v7 + 4;
      *(a2 + 21) = v54;
      goto LABEL_145;
    }
    if ( v4 )
    {
      *(a2 + 33) |= 0x20u;
      v47 = *v7;
      v7 += 8;
      *(a2 + 21) = v47;
      goto LABEL_138;
    }
    if ( (v15 & 8) == 0 )
    {
      *(a2 + 33) |= 0x10u;
      v53 = *v7;
      v7 += 4;
      *(a2 + 21) = v53;
      goto LABEL_138;
    }
LABEL_139:
    *(a2 + 33) |= 8u;
    v48 = *v7;
    v7 += 2;
    *(a2 + 21) = v48;
  }
  else
  {
LABEL_138:
    if ( (v16 & 4) != 0 )
      goto LABEL_139;
  }
  if ( (v16 & 2) != 0 )
  {
    *(a2 + 33) |= 4u;
    v49 = *v7++;
    *(a2 + 21) = v49;
  }
  if ( (v16 & 0x40) != 0 )
    goto LABEL_150;
  if ( (v16 & 0x20) != 0 )
  {
    *(a2 + 33) |= 0x204u;
    v50 = *v7;
    LOBYTE(v7) = v7 + 1;
    *(a2 + 21) = v50;
  }
LABEL_145:
  v51 = v7 - v56;
  *a2 = v51;
  if ( v51 > 0xFu )
  {
    *(a2 + 33) |= 0x5000u;
    v51 = 15;
    *a2 = 15;
  }
  return v51;
}

//----- (0000000140021A1C) ----------------------------------------------------
void __fastcall sub_140021A1C(_PEB32 *Peb32)
{
  __int64 TlsExpansionBitmap; // rcx
  _KAPC_STATE ApcState; // [rsp+20h] [rbp-38h] BYREF

  if ( Peb32
    && *&Peb32->GdiHandleBuffer[0x21]
    && *&Peb32->TlsExpansionBitmap
    && *&Peb32->InheritedAddressSpace != 0xE9
    && Get_KeStackAttachProcess(*&Peb32->ImageBaseAddress, &ApcState) )
  {
    EAC_IsUsermodeValidAddress(*&Peb32->TlsExpansionBitmap, 0xCi64, 1);
    TlsExpansionBitmap = *&Peb32->TlsExpansionBitmap;

    if ( (*TlsExpansionBitmap != 0xB948
       || *(TlsExpansionBitmap + 2) != *&Peb32->GdiHandleBuffer[0x21]
       || *(TlsExpansionBitmap + 0xA) != 0xE1FF)
      && !sub_14003DF80() )
    {
      (loc_14004503C)(Peb32, 0xBi64, 1i64);
    }

    (loc_140054154)(*&Peb32->ImageBaseAddress, &ApcState);// KeUnstackDetachProcess
  }
}

//----- (0000000140021ADC) ----------------------------------------------------
char __fastcall sub_140021ADC(struct_a1 *eData, _UNICODE_STRING *unicode_string)
{
  char ret; // di
  __int64 Size; // rcx
  unsigned __int16 MaximumSize; // ax
  char *Allocate; // rax
  char *Buffer; // rbx

  ret = 0;
  if ( !eData )
    return 0;

  if ( !unicode_string )
    return 0;

  Size = *eData->Size;
  if ( (Size - 1) > 0x1FFu )
    return 0;

  MaximumSize = *&eData->Size[2];
  if ( !MaximumSize || MaximumSize < Size )
    return 0;

  Allocate = EAC_Allocate_Memory(Size + 2);
  Buffer = Allocate;
  if ( Allocate )
  {
    memset(Allocate, 0, *eData->Size + 2i64);
    ProbeForRead(eData->Address, *eData->Size, 1u);
    EAC_memcpy(Buffer, eData->Address, *eData->Size);
    ret = EAC_Read_String_From_Unicode_String(unicode_string, Buffer);
    Get_ExFreePool(Buffer);
  }
  return ret;
}

//----- (0000000140021BB8) ----------------------------------------------------
char __fastcall sub_140021BB8(__int64 Process, unsigned __int64 Address_1, struct_eData_2 *eData)
{
  char ret; // bl
  PEB *Peb; // rdi
  __int64 Mutant; // rdi
  struct_v9 *eData2; // rdi
  unsigned int i; // r14d
  __int64 data; // rcx
  int Address; // eax
  _KAPC_STATE ApcState; // [rsp+28h] [rbp-50h] BYREF

  ret = 0;
  Peb = Get_PsGetProcessWow64Process2(Process);
  if ( !Peb || Address_1 > 0xFFFFFFFF )
    return 0;

  if ( Get_KeStackAttachProcess(Process, &ApcState) )
  {
    ProbeForRead(Peb, 0x3Cui64, 1u);
    Mutant = HIDWORD(Peb->Mutant);
    if ( Mutant )
    {
      ProbeForRead(Mutant, 0x24ui64, 1u);
      eData2 = *(Mutant + 0xC);
      for ( i = 0; eData2; ++i )
      {
        if ( i >= 0x200 )
          break;
        ProbeForRead(eData2, 0x44ui64, 1u);

        data = *&eData2[1].data[7];
        if ( !data )
          break;

        Address = *(&eData2[1].struct_a19.Address + 2);
        if ( !Address )
          break;

        if ( data <= Address_1 && Address_1 < data + Address )
        {
          eData->data = data;
          eData->Size = *(&eData2[1].struct_a19.Address + 2);
          eData->Address = eData2[3].struct_a19.Address;
          if ( sub_140021ADC(&eData2[2].data[2], &eData->unicode_string) )
            ret = 1;

          break;
        }
        eData2 = *eData2->data;
      }
    }
    (loc_140054154)(Process, &ApcState);        // KeUnstackDetachProcess
  }
  return ret;
}
// 140021BB8: using guessed type _KAPC_STATE ApcState;

//----- (0000000140021CFC) ----------------------------------------------------
char __fastcall sub_140021CFC(__int64 Process, unsigned __int64 a2, struct_eData_3 *eData)
{
  char ret; // bl
  PEB *ProcessPeb; // rax MAPDST
  PPEB_LDR_DATA Ldr; // rdi
  struct _LIST_ENTRY *InMemoryOrderModuleList; // rdi
  unsigned int i; // esi
  unsigned __int64 Flink; // rcx
  __int64 ImageBaseAddress; // rax
  char ApcState[96]; // [rsp+28h] [rbp-60h] BYREF

  ret = 0;
  ProcessPeb = Get_PsGetProcessPeb(Process);
  if ( ProcessPeb )
  {
    if ( Get_KeStackAttachProcess(Process, ApcState) )
    {
      ProbeForRead(ProcessPeb, 0x2C8ui64, 1u);
      Ldr = ProcessPeb->Ldr;
      if ( Ldr )
      {
        ProbeForRead(Ldr, 0x40ui64, 1u);
        InMemoryOrderModuleList = Ldr->InLoadOrderModuleList.Flink;

        for ( i = 0; InMemoryOrderModuleList; ++i )
        {
          if ( i >= 0x200 )
            break;

          ProbeForRead(InMemoryOrderModuleList, 0x88ui64, 1u);
          Flink = InMemoryOrderModuleList[3].Flink;
          if ( !Flink )
            break;

          ImageBaseAddress = LODWORD(InMemoryOrderModuleList[4].Flink);
          if ( !ImageBaseAddress )
            break;

          if ( Flink <= a2 && a2 < Flink + ImageBaseAddress )
          {
            eData->Flink = Flink;
            eData->ImageBaseAddress = InMemoryOrderModuleList[4].Flink;
            eData->ProcessParameters = InMemoryOrderModuleList[8].Flink;
            ProbeForRead(InMemoryOrderModuleList[5].Flink, LOWORD(InMemoryOrderModuleList[4].Blink), 1u);
            ret = EAC_Check_Unicode_string(&eData->unicode_string, &InMemoryOrderModuleList[4].Blink);
            break;
          }
          InMemoryOrderModuleList = InMemoryOrderModuleList->Flink;
        }
      }
      (loc_140054154)(Process, ApcState);       // KeUnstackDetachProcess
    }
    LOBYTE(ProcessPeb) = ret;
  }
  return ProcessPeb;
}

//----- (0000000140021E5C) ----------------------------------------------------
char __fastcall sub_140021E5C(__int64 Process, unsigned __int64 Address, struct_eData_2 *eData)
{
  int ProcessWow64Process; // eax

  if ( !Process )
    return 0;

  if ( !Address )
    return 0;

  if ( !eData )
    return 0;

  if ( Address > MmHighestUserAddress )
    return 0;

  memset(eData, 0, sizeof(struct_eData_2));
  ProcessWow64Process = Get_PsGetProcessWow64Process(Process);
  if ( !ProcessWow64Process )
    return 0;

  if ( ProcessWow64Process == 32 )
    return sub_140021BB8(Process, Address, eData);

  return sub_140021CFC(Process, Address, eData);
}

//----- (0000000140021EE0) ----------------------------------------------------
__int64 __fastcall sub_140021EE0(__int64 eData)
{
  __int64 result; // rax

  if ( eData )
    return EAC_Free_UnicodeString(eData + 0x10);

  return result;
}

//----- (0000000140021EF8) ----------------------------------------------------
char __fastcall sub_140021EF8(unsigned int *ProcessId)
{
  char **v2; // rdi
  __int64 v4; // rcx
  unsigned int v5; // ecx
  char ret; // [rsp+20h] [rbp-48h]
  _KAPC_STATE ApcState; // [rsp+30h] [rbp-38h] BYREF
  PVOID Object; // [rsp+78h] [rbp+10h] BYREF

  ret = 0;
  v2 = 0i64;
  if ( !ProcessId )
    return 0;
  EAC_IsUsermodeValidAddress(ProcessId, 0x10i64, 1);

  if ( !*ProcessId || !*(ProcessId + 1) || !ProcessId[3] )
    return 0;

  if ( Get_PsLookupProcessByProcessId(*ProcessId, &Object) >= 0 )
  {
    if ( Get_KeStackAttachProcess(Object, &ApcState) )
    {
      LOBYTE(v4) = 1;
      v2 = (loc_140008758)(v4);
      (loc_140054154)(Object, &ApcState);       // KeUnstackDetachProcess
    }
    ObfDereferenceObject(Object);
  }
  if ( v2 )
  {
    EAC_IsUsermodeValidAddress(*(ProcessId + 1), ProcessId[3], 1);
    v5 = *(*v2 + 0xA);
    if ( v5 >= ProcessId[3] )
      v5 = ProcessId[3];
    EAC_memcpy(*(ProcessId + 1), *v2, v5);
    ret = 1;
    sub_140008BF4(v2);
  }
  return ret;
}
// 140021F74: variable 'v4' is possibly undefined
// 140021EF8: using guessed type _KAPC_STATE ApcState;

//----- (0000000140022588) ----------------------------------------------------
void __fastcall EAC_MapLockedPages_Process(__int64 a1, __int64 a2, _DWORD *a3)
{
  PMDL MDL; // rdi MAPDST
  char UnlockPages; // r12
  ULONG64 v6; // r14
  ULONG64 v7; // r15
  ULONG64 v8; // rsi
  unsigned __int64 v9; // rbx
  __int64 Process; // rax
  bool v11; // bl
  __int64 ProcessId; // rax
  __int64 *v13; // rax
  int v14; // ebx
  char *BaseAddress; // rax
  char v17[32]; // [rsp+50h] [rbp-58h] BYREF
  __int128 v18; // [rsp+70h] [rbp-38h]
  unsigned __int64 v20; // [rsp+C8h] [rbp+20h]

  MDL = 0i64;
  UnlockPages = 0;
  memset(v17, 0, sizeof(v17));
  v18 = 0i64;
  v6 = *(a2 + 0x20);
  if ( v6 )
  {
    if ( *(a2 + 0x10) == 0x1C && *(a1 + 0x70) == v6 && *(a2 + 8) == 0x1C )
    {
      EAC_IsUsermodeValidAddress(v6, 0x1Ci64, 1);
      v7 = *(v6 + 4);
      v8 = *(v6 + 0xC);
      v9 = *(v6 + 0x14);
      v20 = v9;
      *v6 = 0;
      if ( v7 )
      {
        if ( v8 && v9 )
        {
          if ( Check_Process_Architecture() == 32 )
          {
            v7 = v7;
            v8 = v8;
          }
          EAC_IsUsermodeValidAddress(v7, v9, 1);
          EAC_IsUsermodeValidAddress(v8, v9, 1);
          if ( v9 <= 0x1000 )
          {
            if ( (loc_140053930)(-1i64, v8, 0i64, v17, 48i64) )
            {
              if ( (BYTE4(v18) & 0x88) == 0 && (DWORD2(v18) & 0x1000000) == 0 )
              {
                Process = Get_PsGetCurrentProcess();
                v11 = 0;
                if ( Process )
                {
                  ProcessId = Get_PsGetProcessId(Process);
                  v13 = sub_14000D7E8(ProcessId);
                  if ( v13 )
                  {
                    v14 = *v13;
                    sub_14000D924(v13);
                    v11 = v14 == 0xE9;
                  }
                  if ( v11 )
                  {
                    MDL = IoAllocateMdl((v8 & 0xFFFFFFFFFFFFF000ui64), 0x2000u, 0, 0, 0i64);
                    if ( MDL )
                    {
                      MmProbeAndLockPages(MDL, 0, IoReadAccess);
                      UnlockPages = 1;
                      BaseAddress = ((MDL->MdlFlags & 5) != 0
                                   ? MDL->MappedSystemVa
                                   : MmMapLockedPagesSpecifyCache(MDL, 0, MmCached, 0i64, 0, 0x10u));
                      if ( BaseAddress )
                      {
                        EAC_memcpy(&BaseAddress[v8 & 4095], v7, v20);
                        *v6 = 1;
                        *a3 = *(a2 + 8);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( MDL )
  {
    if ( UnlockPages )
      MmUnlockPages(MDL);

    IoFreeMdl(MDL);
  }
}

//----- (00000001400227EC) ----------------------------------------------------
__int64 sub_1400227EC()
{
  __int64 result; // rax
  __int64 v1; // rbx
  union _LARGE_INTEGER Interval; // [rsp+30h] [rbp+8h] BYREF

  ExAcquireFastMutex(&stru_1400831E0);
  byte_140083195 = 1;
  ExReleaseFastMutex(&stru_1400831E0);
  while ( 1 )
  {
    result = sub_14000D890(0i64);
    v1 = result;
    if ( !result )
      break;
    sub_140053E00(*(result + 16), 0xEEAC0004);
    sub_14000D924(v1);
    Interval.QuadPart = -1000000i64;
    KeDelayExecutionThread(0, 0, &Interval);
  }
  return result;
}
// 14000D890: using guessed type __int64 __fastcall sub_14000D890(_QWORD);
// 140083195: using guessed type char byte_140083195;

//----- (0000000140022858) ----------------------------------------------------
__int64 __fastcall sub_140022858(__int64 a1, __int64 a2)
{
  unsigned __int64 i; // r9
  unsigned int v3; // eax

  for ( i = 0i64; i < 0x100; ++i )
  {
    v3 = (*(i + a1) | 0x20) - (*(i + a2) | 0x20);
    if ( v3 )
      break;
    if ( !*(i + a1) )
      break;
  }
  return v3 >> 31;
}

//----- (0000000140022DD0) ----------------------------------------------------
struct _KEVENT *__fastcall EAC_Allocate_KeInitializeEvent(char a1)
{
  POOL_TYPE Pool_Type; // edi
  struct _KEVENT *Event; // rax
  struct _KEVENT *Buffer; // rbx
  __m128 *Buf; // rax

  if ( KUSER_SHARED_DATA.NtMajorVersion > 6
    || KUSER_SHARED_DATA.NtMajorVersion == 6 && KUSER_SHARED_DATA.NtMinorVersion - 2 <= 1 )
  {
    Pool_Type = 512;
  }
  else
  {
    Pool_Type = NonPagedPool;
  }
  Event = ExAllocatePoolWithTag(Pool_Type, 0x50ui64, 'paMH');
  Buffer = Event;
  if ( Event )
  {
    Event[3].Header.LockNV = 0;
    LOBYTE(Event[2].Header.WaitListHead.Flink) = a1;
    HIDWORD(Event[2].Header.WaitListHead.Flink) = 4096;
    Buf = ExAllocatePoolWithTag(Pool_Type, 0x8000ui64, 'paMH');
    Buffer[2].Header.WaitListHead.Blink = Buf;
    if ( Buf )
    {
      EAC_memset(Buf, 0, 8i64 * HIDWORD(Buffer[2].Header.WaitListHead.Flink));
      Buffer->Header.WaitListHead.Flink = 0i64;
      LODWORD(Buffer->Header.WaitListHead.Blink) = 0;
      Buffer->Header.LockNV = 1;
      KeInitializeEvent(Buffer + 1, SynchronizationEvent, 0);
    }
    else
    {
      ExFreePoolWithTag(Buffer, 0x70614D48u);
      return 0i64;
    }
  }
  return Buffer;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140022EAC) ----------------------------------------------------
char __fastcall sub_140022EAC(PFAST_MUTEX FastMutex, __int64 a2, char *a3, unsigned int a4)
{
  unsigned __int64 v5; // r14
  POOL_TYPE v8; // ecx
  __int64 v9; // rsi
  _QWORD *PoolWithTag; // rax
  _QWORD *v11; // rdi
  _QWORD *Owner; // rax
  _QWORD *v13; // rdx
  _QWORD *v14; // rcx
  __int64 v15; // rax

  v5 = a4;
  if ( KUSER_SHARED_DATA.NtMajorVersion > 6
    || KUSER_SHARED_DATA.NtMajorVersion == 6 && KUSER_SHARED_DATA.NtMinorVersion - 2 <= 1 )
  {
    v8 = 0x200;
  }
  else
  {
    v8 = NonPagedPool;
  }
  if ( KeGetCurrentIrql() > 1u || !FastMutex || !LOBYTE(FastMutex[1].Count) && (!a3 || !a4) )
    return 0;

  v9 = a2 & (*(&FastMutex[1].Count + 1) - 1);
  PoolWithTag = ExAllocatePoolWithTag(v8, a4 + 16i64, 'paMH');
  v11 = PoolWithTag;
  if ( !PoolWithTag )
    return 0;

  *PoolWithTag = 0i64;
  PoolWithTag[1] = a2;

  if ( a3 && v5 )
    EAC_memcpy(PoolWithTag + 1, a3, v5);

  ExAcquireFastMutex(FastMutex);
  Owner = FastMutex[1].Owner;
  v13 = 0i64;
  v14 = Owner[v9];
  if ( v14 )
  {
    while ( 1 )
    {
      v15 = *v14;
      if ( v14[1] == a2 )
        break;
      if ( !v15 )
      {
        *v14 = v11;
        goto LABEL_25;
      }
      v13 = v14;
      v14 = *v14;
    }
    *v11 = v15;
    if ( v13 )
      *v13 = v11;
    else
      *(FastMutex[1].Owner + v9) = v11;
    ExFreePoolWithTag(v14, 0x70614D48u);
  }
  else
  {
    Owner[v9] = v11;
LABEL_25:
    ++FastMutex[1].Contention;
  }
  ExReleaseFastMutex(FastMutex);
  return 1;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140022FFC) ----------------------------------------------------
_QWORD *__fastcall sub_140022FFC(PFAST_MUTEX FastMutex, __int64 a2)
{
  _QWORD *v4; // rdi
  __int64 v5; // rbx
  _QWORD *i; // rcx

  v4 = 0i64;
  if ( KeGetCurrentIrql() > 1u || !FastMutex || LOBYTE(FastMutex[1].Count) )
    return 0i64;
  v5 = a2 & (*(&FastMutex[1].Count + 1) - 1);
  ExAcquireFastMutex(FastMutex);
  for ( i = *(FastMutex[1].Owner + v5); i; i = *i )
  {
    if ( i[1] == a2 )
    {
      v4 = i + 2;
      break;
    }
  }
  ExReleaseFastMutex(FastMutex);
  return v4;
}

//----- (000000014002307C) ----------------------------------------------------
char __fastcall sub_14002307C(PFAST_MUTEX FastMutex, __int64 a2)
{
  char v4; // di
  __int64 v5; // rbx
  _QWORD *i; // rcx

  v4 = 0;
  if ( KeGetCurrentIrql() > 1u || !FastMutex )
    return 0;
  v5 = a2 & (*(&FastMutex[1].Count + 1) - 1);
  ExAcquireFastMutex(FastMutex);
  for ( i = *(FastMutex[1].Owner + v5); i; i = *i )
  {
    if ( i[1] == a2 )
    {
      v4 = 1;
      break;
    }
  }
  ExReleaseFastMutex(FastMutex);
  return v4;
}

//----- (00000001400230F8) ----------------------------------------------------
void __fastcall sub_1400230F8(PFAST_MUTEX FastMutex, __int64 a2)
{
  __int64 v4; // rdi
  _QWORD *Owner; // r8
  _QWORD *v6; // rdx
  _QWORD *v7; // rcx
  __int64 v8; // rax

  if ( KeGetCurrentIrql() <= 1u && FastMutex )
  {
    v4 = a2 & (*(&FastMutex[1].Count + 1) - 1);
    ExAcquireFastMutex(FastMutex);
    Owner = FastMutex[1].Owner;
    v6 = 0i64;
    v7 = Owner[v4];
    if ( v7 )
    {
      while ( 1 )
      {
        v8 = *v7;
        if ( v7[1] == a2 )
          break;
        v6 = v7;
        v7 = *v7;
        if ( !v8 )
          goto LABEL_11;
      }
      if ( v6 )
        *v6 = v8;
      else
        Owner[v4] = v8;
      ExFreePoolWithTag(v7, 0x70614D48u);
      --FastMutex[1].Contention;
    }
LABEL_11:
    ExReleaseFastMutex(FastMutex);
  }
}

//----- (0000000140023184) ----------------------------------------------------
void __fastcall sub_140023184(struct _FAST_MUTEX *P)
{
  __int64 i; // rdi
  _QWORD *Owner; // rax
  _QWORD *v4; // rsi
  void *v5; // rcx

  if ( P )
  {
    if ( KeGetCurrentIrql() <= 1u )
    {
      ExAcquireFastMutex(P);
      for ( i = 0i64; i < *(&P[1].Count + 1); i = (i + 1) )
      {
        Owner = P[1].Owner;
        v4 = Owner[i];
        if ( v4 )
        {
          do
          {
            v5 = v4;
            v4 = *v4;
            --P[1].Contention;
            ExFreePoolWithTag(v5, 0x70614D48u);
          }
          while ( v4 );
          Owner = P[1].Owner;
        }
        Owner[i] = 0i64;
      }
      ExReleaseFastMutex(P);
    }
    ExFreePoolWithTag(P[1].Owner, 0x70614D48u);
    ExFreePoolWithTag(P, 0x70614D48u);
  }
}

//----- (000000014002322C) ----------------------------------------------------
char __fastcall sub_14002322C(unsigned int a1)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  bool v5; // zf
  int v6; // ecx
  bool v7; // zf
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx

  if ( a1 > 0xC2 )
  {
    if ( a1 > 0x213 )
    {
      v15 = a1 - 562;
      if ( !v15 )
        return 1;
      v16 = v15 - 19;
      if ( !v16 )
        return 1;
      v17 = v16 - 20;
      if ( !v17 )
        return 1;
      v18 = v17 - 7;
      if ( !v18 )
        return 1;
      v7 = v18 == 2;
    }
    else
    {
      if ( a1 == 531 )
        return 1;
      v11 = a1 - 215;
      if ( !v11 )
        return 1;
      v12 = v11 - 18;
      if ( !v12 )
        return 1;
      v13 = v12 - 4;
      if ( !v13 )
        return 1;
      v14 = v13 - 249;
      if ( !v14 )
        return 1;
      v7 = v14 == 3;
    }
    goto LABEL_28;
  }
  if ( a1 != 194 )
  {
    if ( a1 > 0x70 )
    {
      v8 = a1 - 140;
      if ( !v8 )
        return 1;
      v9 = v8 - 21;
      if ( !v9 )
        return 1;
      v10 = v9 - 14;
      if ( !v10 )
        return 1;
      v6 = v10 - 3;
      v5 = v6 == 0;
    }
    else
    {
      if ( a1 == 112 )
        return 1;
      v1 = a1 - 1;
      if ( !v1 )
        return 1;
      v2 = v1 - 1;
      if ( !v2 )
        return 1;
      v3 = v2 - 2;
      if ( !v3 )
        return 1;
      v4 = v3 - 1;
      if ( !v4 )
        return 1;
      v6 = v4 - 31;
      v5 = v6 == 0;
    }
    if ( !v5 )
    {
      v7 = v6 == 1;
LABEL_28:
      if ( !v7 )
        return 0;
    }
  }
  return 1;
}

//----- (00000001400269F0) ----------------------------------------------------
__int64 __fastcall sub_1400269F0(__int64 a1, unsigned int a2)
{
  __int64 v4; // rax

  v4 = (loc_14005B768)(a1, sub_1400269F0, 0i64);
  if ( a1 && v4 && a2 && !KeGetCurrentIrql() && a2 >= 0x1464 )
    return (loc_1400263B0)(v4);
  else
    return 0i64;
}

//----- (00000001400289D4) ----------------------------------------------------
char __fastcall sub_1400289D4(unsigned int a1, __int64 a2, __m128 *a3)
{
  unsigned __int64 v3; // rsi
  unsigned __int64 v5; // r8
  unsigned int v6; // edx
  int v7; // ecx
  char v8; // cl
  int v9; // edx
  __int128 *v10; // rdi
  unsigned __int64 v11; // rcx
  __int64 v12; // r14
  unsigned int v13; // edx
  unsigned __int64 v14; // rdi
  char v15; // cl
  __m128 v16; // xmm1
  __m128 v17; // xmm0
  __m128 v18; // xmm1
  __m128 v19; // xmm0
  __m128 v20; // xmm1
  __m128 v21; // xmm0
  __m128 *v22; // rbx
  __int64 v23; // rax
  __m128 v24; // xmm0
  __m128 v25; // xmm1
  int v26; // edi
  __int32 v27; // eax
  __int128 v28; // xmm1
  unsigned int v29; // edi
  unsigned __int64 v30; // rdx
  char v31; // cl
  int v32; // eax
  __int128 v33; // xmm1
  __int16 v34; // ax
  int v35; // edi
  __int128 v36; // xmm1
  unsigned int v37; // edx
  unsigned __int64 v38; // r8
  char v39; // cl
  int v40; // eax
  unsigned int v41; // edx
  unsigned __int64 v42; // rdi
  int v43; // ecx
  char v44; // cl
  __m128 v45; // xmm1
  int v46; // eax
  __m128 v47; // xmm0
  __m128 v48; // xmm1
  __m128 v49; // xmm0
  __m128 v50; // xmm1
  unsigned int v51; // edi
  unsigned __int64 v52; // rdx
  char v53; // cl
  int v54; // eax
  __int128 v55; // xmm1
  unsigned int v56; // edx
  unsigned __int64 v57; // rdi
  int v58; // ecx
  char v59; // cl
  __m128 v60; // xmm1
  __int64 v61; // rax
  __m128 v62; // xmm0
  __m128 v63; // xmm1
  __m128 v64; // xmm0
  __m128 v65; // xmm1
  __m128 v66; // xmm0
  char result; // al
  unsigned __int32 v68; // edx
  unsigned __int64 v69; // r8
  char v70; // cl
  __int16 v71; // ax
  __int64 v72; // xmm1_8
  unsigned int v73; // edx
  unsigned __int64 v74; // r8
  int v75; // ecx
  char v76; // cl
  int v77; // eax
  unsigned int v78; // edx
  unsigned __int64 v79; // rdi
  char v80; // cl
  __m128 v81; // xmm1
  __m128 v82; // xmm0
  __m128 v83; // xmm1
  __m128 v84; // xmm0
  __m128 v85; // xmm1
  __m128 v86; // xmm0
  __m128 *v87; // rbx
  __int64 v88; // rax
  __m128 v89; // xmm0
  __m128 v90; // xmm1
  __m128 v91; // xmm0
  int v92; // ecx
  __int64 v93; // r8
  unsigned int v94; // edx
  __m128 v95; // xmm1
  __m128 v96; // xmm0
  __m128 v97; // xmm1
  __m128 v98; // xmm0
  __m128 v99; // xmm1
  __m128 v100; // xmm0
  __m128 v101; // xmm1
  int v102; // eax
  int v103; // ecx
  int v104; // eax
  unsigned int v105; // edx
  unsigned __int64 v106; // xmm1_8
  unsigned int v107; // edx
  unsigned __int64 v108; // rdi
  char v109; // cl
  __m128 v110; // xmm1
  int v111; // eax
  __m128 v112; // xmm0
  __m128 v113; // xmm1
  __m128 v114; // xmm0
  __m128 v115; // xmm1
  __m128 v116; // xmm0
  unsigned int v117; // edx
  __int128 v118; // xmm1
  __int64 v119; // xmm0_8
  unsigned __int32 v120; // edx
  int v121; // ecx
  unsigned __int64 i; // r8
  char v123; // cl
  __m128 v124; // xmm1
  __m128 v125; // xmm0
  __m128 v126; // xmm1
  __m128 v127; // xmm0
  __m128 v128; // xmm1
  __m128 v129; // xmm0
  __m128 v130; // xmm1
  __int16 v131; // ax
  __m128 v132; // [rsp+28h] [rbp-D8h] BYREF
  int v133; // [rsp+38h] [rbp-C8h]
  int v134; // [rsp+3Ch] [rbp-C4h]
  int v135; // [rsp+40h] [rbp-C0h]
  int v136; // [rsp+44h] [rbp-BCh]
  int v137; // [rsp+48h] [rbp-B8h]
  int v138; // [rsp+4Ch] [rbp-B4h]
  __m128 v139; // [rsp+50h] [rbp-B0h] BYREF
  __int128 v140; // [rsp+60h] [rbp-A0h]
  __int64 v141; // [rsp+70h] [rbp-90h]
  int v142[5]; // [rsp+78h] [rbp-88h]
  __int16 v143; // [rsp+8Ch] [rbp-74h]
  int v144[5]; // [rsp+8Eh] [rbp-72h]
  __int16 v145; // [rsp+A2h] [rbp-5Eh]
  int v146[5]; // [rsp+A4h] [rbp-5Ch]
  __int16 v147; // [rsp+B8h] [rbp-48h]
  int v148[6]; // [rsp+BAh] [rbp-46h]
  __int16 v149; // [rsp+D2h] [rbp-2Eh]
  int v150[9]; // [rsp+D4h] [rbp-2Ch]
  __int16 v151; // [rsp+F8h] [rbp-8h]
  int v152[9]; // [rsp+FAh] [rbp-6h]
  __int16 v153; // [rsp+11Eh] [rbp+1Eh]
  int v154[25]; // [rsp+120h] [rbp+20h]
  __int16 v155; // [rsp+184h] [rbp+84h]
  int v156[31]; // [rsp+186h] [rbp+86h]
  __int16 v157; // [rsp+202h] [rbp+102h]
  int v158[32]; // [rsp+204h] [rbp+104h]
  __int16 v159; // [rsp+284h] [rbp+184h]
  int v160[34]; // [rsp+286h] [rbp+186h]
  __int16 v161; // [rsp+30Eh] [rbp+20Eh]
  int v162[47]; // [rsp+310h] [rbp+210h]
  __int16 v163; // [rsp+3CCh] [rbp+2CCh]
  int v164[50]; // [rsp+3CEh] [rbp+2CEh]
  __int16 v165; // [rsp+496h] [rbp+396h]
  int v166[38]; // [rsp+498h] [rbp+398h]
  __m128 v167; // [rsp+530h] [rbp+430h] BYREF
  int v168; // [rsp+540h] [rbp+440h]
  __int16 v169; // [rsp+544h] [rbp+444h]
  __m128 v170; // [rsp+548h] [rbp+448h] BYREF
  int v171; // [rsp+558h] [rbp+458h]
  __int16 v172; // [rsp+55Ch] [rbp+45Ch]
  __m128 v173; // [rsp+560h] [rbp+460h] BYREF
  int v174; // [rsp+570h] [rbp+470h]
  __int16 v175; // [rsp+574h] [rbp+474h]
  __m128 v176; // [rsp+578h] [rbp+478h] BYREF
  __int64 v177; // [rsp+588h] [rbp+488h]
  __int16 v178; // [rsp+590h] [rbp+490h]
  __m128 v179; // [rsp+598h] [rbp+498h] BYREF
  __int128 v180; // [rsp+5A8h] [rbp+4A8h]
  int v181; // [rsp+5B8h] [rbp+4B8h]
  __int16 v182; // [rsp+5BCh] [rbp+4BCh]
  __m128 v183; // [rsp+5C0h] [rbp+4C0h] BYREF
  __int128 v184; // [rsp+5D0h] [rbp+4D0h]
  int v185; // [rsp+5E0h] [rbp+4E0h]
  __int16 v186; // [rsp+5E4h] [rbp+4E4h]
  __m128 v187[6]; // [rsp+5F0h] [rbp+4F0h] BYREF
  int v188; // [rsp+650h] [rbp+550h]
  __int16 v189; // [rsp+654h] [rbp+554h]
  __m128 v190[7]; // [rsp+660h] [rbp+560h] BYREF
  unsigned __int64 v191; // [rsp+6D0h] [rbp+5D0h]
  int v192; // [rsp+6D8h] [rbp+5D8h]
  __int16 v193; // [rsp+6DCh] [rbp+5DCh]
  __m128 v194[8]; // [rsp+6E0h] [rbp+5E0h] BYREF
  __int16 v195; // [rsp+760h] [rbp+660h]
  __m128 v196[8]; // [rsp+770h] [rbp+670h] BYREF
  __int64 v197; // [rsp+7F0h] [rbp+6F0h]
  __int16 v198; // [rsp+7F8h] [rbp+6F8h]
  __m128 v199[9]; // [rsp+800h] [rbp+700h] BYREF
  int v200; // [rsp+890h] [rbp+790h]
  __m128 v201[11]; // [rsp+8A0h] [rbp+7A0h] BYREF
  __int64 v202; // [rsp+950h] [rbp+850h]
  int v203; // [rsp+958h] [rbp+858h]
  __int16 v204; // [rsp+95Ch] [rbp+85Ch]
  __m128 v205[12]; // [rsp+960h] [rbp+860h] BYREF
  __int64 v206; // [rsp+A20h] [rbp+920h]
  __int16 v207; // [rsp+A28h] [rbp+928h]

  v3 = 0i64;
  if ( !a3 )
    return 0;
  memset(a3, 0, 0x200ui64);
  if ( a1 > 0xB )
  {
    switch ( a1 )
    {
      case 0xCu:
        v158[0] = -582806691;
        v12 = 130i64;
        v158[1] = -1060240818;
        v158[2] = 1115111616;
        v158[3] = -927841943;
        v158[4] = 1825802243;
        v158[5] = 1426859577;
        v158[6] = 1737715986;
        v158[7] = 1881188751;
        v158[8] = 300223991;
        v158[9] = 224349267;
        v158[10] = 1921184570;
        v158[11] = -343545682;
        v158[12] = 955112630;
        v158[13] = 2002549787;
        v158[14] = -294210059;
        v158[15] = 332201913;
        v158[16] = 905407977;
        v158[17] = 1128212181;
        v158[18] = -528463389;
        v158[19] = 530680025;
        v158[20] = 875176415;
        v158[21] = -785056512;
        v158[22] = 1730862886;
        v158[23] = -494275911;
        v158[24] = -715532210;
        v158[25] = 1677157700;
        v158[26] = 563603355;
        v158[27] = -554872546;
        v158[28] = 2134869141;
        v158[29] = -518763921;
        v158[30] = 1866659014;
        v158[31] = -929788979;
        v159 = -259;
        EAC_memset(v194, 0, 0x82ui64);
        v120 = -586083583;
        do
        {
          v121 = v158[v3] ^ v120;
          v120 = _byteswap_ulong(214013 * v120 + 2531011);
          v194[0].m128_i32[v3++] = v121;
        }
        while ( v3 < 32 );
        for ( i = 128i64; i < 0x82; ++i )
        {
          v123 = v120;
          v120 >>= 8;
          v194[0].m128_i8[i] = *(v158 + i) ^ v123;
        }
        v124 = v194[1];
        *a3 = v194[0];
        v125 = v194[2];
        a3[1] = v124;
        v126 = v194[3];
        a3[2] = v125;
        v127 = v194[4];
        a3[3] = v126;
        v128 = v194[5];
        a3[4] = v127;
        v129 = v194[6];
        a3[5] = v128;
        v130 = v194[7];
        v131 = v195;
        a3[6] = v129;
        a3[7] = v130;
        a3[8].m128_i16[0] = v131;
        v10 = v194;
        goto LABEL_49;
      case 0xDu:
        v141 = 0i64;
        v132.m128_u64[0] = 0x1ED433011D36919Ci64;
        v139 = 0i64;
        v117 = -186507281;
        v140 = 0i64;
        v132.m128_u64[1] = 0x434803D7F5BCE310i64;
        v133 = -24379906;
        v134 = 1883380045;
        v135 = 300611215;
        v136 = -618901496;
        v137 = -1806461629;
        v138 = 1093920727;
        do
        {
          v117 = ~(((v117 ^ (v117 >> 7)) << 9) ^ v117 ^ (v117 >> 7) ^ ((((v117 ^ (v117 >> 7)) << 9) ^ v117 ^ (v117 >> 7)) >> 13));
          v139.m128_i32[v3] = v132.m128_i32[v3] ^ v117;
          ++v3;
        }
        while ( v3 < 10 );
        v10 = &v139;
        v11 = 40i64;
        v118 = v140;
        *a3 = v139;
        v119 = v141;
        a3[1] = v118;
        a3[2].m128_u64[0] = v119;
        goto LABEL_50;
      case 0x10u:
        v156[0] = 1051779745;
        v12 = 126i64;
        v156[1] = -816261546;
        v156[2] = -160868420;
        v156[3] = -618212145;
        v156[4] = -1954991340;
        v156[5] = 624429006;
        v156[6] = -1288393818;
        v156[7] = 2037256418;
        v156[8] = 881829560;
        v156[9] = 1896194432;
        v156[10] = 466631379;
        v156[11] = 57670956;
        v156[12] = 365702463;
        v156[13] = -928483969;
        v156[14] = 140539084;
        v156[15] = -828904615;
        v156[16] = -1935362354;
        v156[17] = 1695502613;
        v156[18] = 2048444873;
        v156[19] = -535811694;
        v156[20] = -1605160119;
        v156[21] = 1226573492;
        v156[22] = 1247783333;
        v156[23] = 807668127;
        v156[24] = -1858891042;
        v156[25] = 1016489313;
        v156[26] = -602242032;
        v156[27] = 352246511;
        v156[28] = -746338968;
        v156[29] = -195478512;
        v156[30] = 1465436682;
        v157 = -5013;
        EAC_memset(v190, 0, 0x7Eui64);
        v107 = 1055056637;
        v108 = 124i64;
        do
        {
          v190[0].m128_i32[v3] = v156[v3] ^ v107;
          ++v3;
          v107 = -2531012 - 214013 * v107;
        }
        while ( v3 < 31 );
        do
        {
          v109 = v107;
          v107 >>= 8;
          v190[0].m128_i8[v108] = *(v156 + v108) ^ v109;
          ++v108;
        }
        while ( v108 < 0x7E );
        v10 = v190;
        v110 = v190[1];
        v111 = v192;
        *a3 = v190[0];
        v112 = v190[2];
        a3[1] = v110;
        v113 = v190[3];
        a3[2] = v112;
        v114 = v190[4];
        a3[3] = v113;
        v115 = v190[5];
        a3[4] = v114;
        v116 = v190[6];
        a3[5] = v115;
        v115.m128_u64[0] = v191;
        a3[6] = v116;
        a3[7].m128_u64[0] = v115.m128_u64[0];
        a3[7].m128_i32[2] = v111;
        a3[7].m128_i16[6] = v193;
        goto LABEL_49;
      case 0x11u:
        *&v140 = 0i64;
        v132.m128_u64[0] = 0x39584524234BA1E7i64;
        v139 = 0i64;
        v105 = 1498942519;
        v132.m128_u64[1] = 0xC56B60E82134635Dui64;
        v93 = 24i64;
        v133 = 600010947;
        v134 = -252534292;
        do
        {
          v105 = __ROR4__(
                   ((v105 ^ (v105 >> 7)) << 9) ^ v105 ^ (v105 >> 7) ^ ((((v105 ^ (v105 >> 7)) << 9) ^ v105 ^ (v105 >> 7)) >> 13),
                   2);
          v139.m128_i32[v3] = v132.m128_i32[v3] ^ v105;
          ++v3;
        }
        while ( v3 < 6 );
        break;
      case 0x12u:
        v133 = 0;
        v139.m128_u64[0] = 0xEC137703329B9A6i64;
        v132 = 0i64;
        v103 = 945955219;
        v139.m128_u64[1] = 0x79D8D97FA3A4CAEFi64;
        v93 = 20i64;
        LODWORD(v140) = 600244282;
        do
        {
          v103 = -2531011 - 214013 * v103;
          v132.m128_i32[v3] = v139.m128_i32[v3] ^ v103;
          ++v3;
        }
        while ( v3 < 5 );
        v104 = v133;
        v10 = &v132;
        *a3 = v132;
        a3[1].m128_i32[0] = v104;
        goto LABEL_84;
      case 0x13u:
        v12 = 148i64;
        v166[0] = 1118460028;
        v166[1] = -1757271973;
        v166[2] = 1886025579;
        v166[3] = 272421307;
        v166[4] = 432152066;
        v166[5] = 1209824812;
        v166[6] = 840302918;
        v166[7] = 1083314669;
        v166[8] = 1462333247;
        v166[9] = 477491507;
        v166[10] = -1958665763;
        v166[11] = -1174971460;
        v166[12] = 237241238;
        v166[13] = 921075198;
        v166[14] = -1221482030;
        v166[15] = -643074614;
        v166[16] = 647928980;
        v166[17] = 196879966;
        v166[18] = -691937503;
        v166[19] = 343240239;
        v166[20] = 775896949;
        v166[21] = -1500151960;
        v166[22] = 1582988972;
        v166[23] = -487211383;
        v166[24] = -1935585245;
        v166[25] = 112832860;
        v166[26] = -1867049080;
        v166[27] = 1856109784;
        v166[28] = -1904685250;
        v166[29] = 1397085949;
        v166[30] = 1172807429;
        v166[31] = -911973086;
        v166[32] = 763654855;
        v166[33] = -1346011846;
        v166[34] = 1181398898;
        v166[35] = -401699334;
        v166[36] = 2007749166;
        EAC_memset(v199, 0, 0x94ui64);
        v94 = -424331393;
        do
        {
          v94 = __ROR4__(
                  ((v94 ^ (v94 >> 7)) << 9) ^ v94 ^ (v94 >> 7) ^ ((((v94 ^ (v94 >> 7)) << 9) ^ v94 ^ (v94 >> 7)) >> 13),
                  3);
          v199[0].m128_i32[v3] = v166[v3] ^ v94;
          ++v3;
        }
        while ( v3 < 37 );
        v95 = v199[1];
        *a3 = v199[0];
        v96 = v199[2];
        a3[1] = v95;
        v97 = v199[3];
        a3[2] = v96;
        v98 = v199[4];
        a3[3] = v97;
        v99 = v199[5];
        a3[4] = v98;
        v100 = v199[6];
        a3[5] = v99;
        v101 = v199[8];
        a3[6] = v100;
        v102 = v200;
        a3[7] = v199[7];
        a3[8] = v101;
        a3[9].m128_i32[0] = v102;
        v10 = v199;
        goto LABEL_49;
      case 0x14u:
        *&v140 = 0i64;
        v132.m128_u64[0] = 0x52A1E0108548515Ei64;
        v139 = 0i64;
        v92 = -590913893;
        v132.m128_u64[1] = 0x6F1DB00E13D7B609i64;
        v93 = 24i64;
        v133 = -2107767287;
        v134 = 1424900311;
        do
        {
          v92 = ~(214013 * v92 + 2531011);
          v139.m128_i32[v3] = v132.m128_i32[v3] ^ v92;
          ++v3;
        }
        while ( v3 < 6 );
        break;
      case 0x15u:
        v164[0] = -1757858658;
        v12 = 202i64;
        v164[1] = -664630652;
        v164[2] = 726451218;
        v164[3] = -2115252117;
        v164[4] = 1440707906;
        v164[5] = 1553922749;
        v164[6] = 79746622;
        v164[7] = 2058061901;
        v164[8] = -1556633580;
        v164[9] = -1925792804;
        v164[10] = 1638547857;
        v164[11] = -1372355104;
        v164[12] = -1222315738;
        v164[13] = 1197528063;
        v164[14] = -414123275;
        v164[15] = 501988351;
        v164[16] = 1251072134;
        v164[17] = -1037645881;
        v164[18] = -243635452;
        v164[19] = -417587091;
        v164[20] = 1607809771;
        v164[21] = 1049237546;
        v164[22] = 2051388426;
        v164[23] = 1368333400;
        v164[24] = -919164863;
        v164[25] = -1891537207;
        v164[26] = 1823850647;
        v164[27] = 1840363540;
        v164[28] = -161120087;
        v164[29] = 687348693;
        v164[30] = 684177432;
        v164[31] = -2124161373;
        v164[32] = 147034308;
        v164[33] = -2139324703;
        v164[34] = 947463096;
        v164[35] = -183995167;
        v164[36] = -1422910905;
        v164[37] = 1176434563;
        v164[38] = -1891132585;
        v164[39] = -1716827895;
        v164[40] = -191325193;
        v164[41] = -875597404;
        v164[42] = -1244481424;
        v164[43] = 1728113336;
        v164[44] = -16257834;
        v164[45] = -56511562;
        v164[46] = -1538757373;
        v164[47] = 1107545936;
        v164[48] = 1139504655;
        v164[49] = -1382415425;
        v165 = 29988;
        EAC_memset(v205, 0, 0xCAui64);
        v78 = -1754581822;
        v79 = 200i64;
        do
        {
          v205[0].m128_i32[v3] = v164[v3] ^ v78;
          ++v3;
          v78 = __ROL4__(
                  ((v78 ^ (v78 >> 7)) << 9) ^ v78 ^ (v78 >> 7) ^ ((((v78 ^ (v78 >> 7)) << 9) ^ v78 ^ (v78 >> 7)) >> 13),
                  4);
        }
        while ( v3 < 50 );
        do
        {
          v80 = v78;
          v78 >>= 8;
          v205[0].m128_i8[v79] = *(v164 + v79) ^ v80;
          ++v79;
        }
        while ( v79 < 0xCA );
        v81 = v205[1];
        *a3 = v205[0];
        v82 = v205[2];
        a3[1] = v81;
        v83 = v205[3];
        a3[2] = v82;
        v84 = v205[4];
        a3[3] = v83;
        v85 = v205[5];
        a3[4] = v84;
        v86 = v205[6];
        a3[5] = v85;
        a3[6] = v86;
        v87 = a3 + 8;
        v10 = v205;
        v87[-1] = v205[7];
        v88 = v206;
        v89 = v205[9];
        *v87 = v205[8];
        v90 = v205[10];
        v87[1] = v89;
        v91 = v205[11];
        v87[2] = v90;
        v87[3] = v91;
        v87[4].m128_u64[0] = v88;
        v87[4].m128_i16[4] = v207;
LABEL_49:
        v11 = v12;
        goto LABEL_50;
      case 0x16u:
        v146[0] = 1724999216;
        v147 = -19195;
        v146[1] = -840403289;
        v174 = 0;
        v73 = 1721984628;
        v175 = 0;
        v74 = 20i64;
        v146[2] = 653649111;
        v146[3] = -1498582754;
        v146[4] = 999122200;
        v173 = 0i64;
        do
        {
          v75 = v146[v3] ^ v73;
          v73 = __ROL4__(214013 * v73 + 2531011, 1);
          v173.m128_i32[v3++] = v75;
        }
        while ( v3 < 5 );
        do
        {
          v76 = v73;
          v73 >>= 8;
          v173.m128_i8[v74] = *(v146 + v74) ^ v76;
          ++v74;
        }
        while ( v74 < 0x16 );
        v77 = v174;
        v10 = &v173;
        *a3 = v173;
        a3[1].m128_i32[0] = v77;
        a3[1].m128_i16[2] = v175;
        goto LABEL_17;
      default:
        return 0;
    }
    v10 = &v139;
    v106 = v140;
    *a3 = v139;
    a3[1].m128_u64[0] = v106;
LABEL_84:
    v11 = v93;
    goto LABEL_50;
  }
  switch ( a1 )
  {
    case 0xBu:
      v148[0] = 445281327;
      v149 = 29849;
      v148[1] = -392721699;
      v177 = 0i64;
      v68 = 451900540;
      v178 = 0;
      v69 = 24i64;
      v148[2] = -1160657450;
      v148[3] = -1696156316;
      v148[4] = 1355056315;
      v148[5] = 2096731706;
      v176 = 0i64;
      do
      {
        v176.m128_i32[v3] = v148[v3] ^ v68;
        ++v3;
        v68 = _byteswap_ulong(((v68 ^ (v68 >> 7)) << 9) ^ v68 ^ (v68 >> 7) ^ ((((v68 ^ (v68 >> 7)) << 9) ^ v68 ^ (v68 >> 7)) >> 13));
      }
      while ( v3 < 6 );
      do
      {
        v70 = v68;
        v68 >>= 8;
        v176.m128_i8[v69] = *(v148 + v69) ^ v70;
        ++v69;
      }
      while ( v69 < 0x1A );
      v10 = &v176;
      v71 = v178;
      v72 = v177;
      v11 = 26i64;
      *a3 = v176;
      a3[1].m128_u64[0] = v72;
      a3[1].m128_i16[4] = v71;
      goto LABEL_50;
    case 1u:
      v160[0] = 1455435407;
      v12 = 138i64;
      v160[1] = -1346570901;
      v160[2] = -1668322490;
      v160[3] = -1532585322;
      v160[4] = -1593988462;
      v160[5] = 589854875;
      v160[6] = -1873969820;
      v160[7] = 1828776835;
      v160[8] = 1363478758;
      v160[9] = 288397645;
      v160[10] = -1441215444;
      v160[11] = 547532055;
      v160[12] = 985358279;
      v160[13] = -681697901;
      v160[14] = 946680133;
      v160[15] = 696772372;
      v160[16] = -2129770384;
      v160[17] = 1911115584;
      v160[18] = 96732157;
      v160[19] = 1431970414;
      v160[20] = 467327534;
      v160[21] = -1741753174;
      v160[22] = -1171252472;
      v160[23] = 2013750654;
      v160[24] = -1151226484;
      v160[25] = -158836894;
      v160[26] = -291188538;
      v160[27] = 238696678;
      v160[28] = 702208662;
      v160[29] = 1211186792;
      v160[30] = -635307016;
      v160[31] = -959142665;
      v160[32] = -1162741273;
      v160[33] = -1583222495;
      v161 = -3089;
      EAC_memset(v196, 0, 0x8Aui64);
      v56 = 1452420819;
      v57 = 136i64;
      do
      {
        v58 = v160[v3] ^ v56;
        v56 = ~(31917 * v56 + 11285082);
        v196[0].m128_i32[v3++] = v58;
      }
      while ( v3 < 34 );
      do
      {
        v59 = v56;
        v56 >>= 8;
        v196[0].m128_i8[v57] = *(v160 + v57) ^ v59;
        ++v57;
      }
      while ( v57 < 0x8A );
      v60 = v196[1];
      v61 = v197;
      *a3 = v196[0];
      v62 = v196[2];
      a3[1] = v60;
      v63 = v196[3];
      a3[2] = v62;
      v64 = v196[4];
      a3[3] = v63;
      v65 = v196[5];
      a3[4] = v64;
      v66 = v196[6];
      a3[5] = v65;
      a3[6] = v66;
      a3[7] = v196[7];
      a3[8].m128_u64[0] = v61;
      a3[8].m128_i16[4] = v198;
      v10 = v196;
      goto LABEL_49;
    case 2u:
      v152[0] = 1381829717;
      v153 = -17026;
      v152[1] = 1143827487;
      v185 = 0;
      v51 = 1379011606;
      v186 = 0;
      v52 = 36i64;
      v152[2] = -489664222;
      v152[3] = -2116066868;
      v152[4] = 2094696734;
      v152[5] = -797483436;
      v152[6] = -994015071;
      v152[7] = 1184166478;
      v152[8] = 803010187;
      v183 = 0i64;
      v184 = 0i64;
      do
      {
        v183.m128_i32[v3] = v152[v3] ^ v51;
        ++v3;
        v51 = __ROL4__(
                ((v51 ^ (v51 << 13)) >> 7) ^ v51 ^ (v51 << 13) ^ ((((v51 ^ (v51 << 13)) >> 7) ^ v51 ^ (v51 << 13)) << 17),
                3);
      }
      while ( v3 < 9 );
      do
      {
        v53 = v51;
        v51 >>= 8;
        v183.m128_i8[v52] = *(v152 + v52) ^ v53;
        ++v52;
      }
      while ( v52 < 0x26 );
      v54 = v185;
      v10 = &v183;
      v55 = v184;
      *a3 = v183;
      a3[1] = v55;
      a3[2].m128_i32[0] = v54;
      v34 = v186;
      goto LABEL_29;
    case 3u:
      v154[0] = 183998677;
      v12 = 102i64;
      v154[1] = 264606136;
      v154[2] = -1810292228;
      v154[3] = 2063791204;
      v154[4] = -585140386;
      v154[5] = 195102522;
      v154[6] = 2116179482;
      v154[7] = -968233296;
      v154[8] = 717619377;
      v154[9] = 817327022;
      v154[10] = -1174698188;
      v154[11] = -469292745;
      v154[12] = 852570200;
      v154[13] = -1710824367;
      v154[14] = 372722428;
      v154[15] = 2112894142;
      v154[16] = 1165275643;
      v154[17] = 149342201;
      v154[18] = -849153288;
      v154[19] = 217967656;
      v154[20] = 152967572;
      v154[21] = 1350362338;
      v154[22] = 801564719;
      v154[23] = -1643132735;
      v154[24] = 1680881905;
      v155 = 20422;
      EAC_memset(v187, 0, 0x66ui64);
      v41 = 178624649;
      v42 = 100i64;
      do
      {
        v43 = v154[v3] ^ v41;
        v41 = __ROL4__(38467 * v41 + 4388674, 4);
        v187[0].m128_i32[v3++] = v43;
      }
      while ( v3 < 25 );
      do
      {
        v44 = v41;
        v41 >>= 8;
        v187[0].m128_i8[v42] = *(v154 + v42) ^ v44;
        ++v42;
      }
      while ( v42 < 0x66 );
      v10 = v187;
      v45 = v187[1];
      v46 = v188;
      *a3 = v187[0];
      v47 = v187[2];
      a3[1] = v45;
      v48 = v187[3];
      a3[2] = v47;
      v49 = v187[4];
      a3[3] = v48;
      v50 = v187[5];
      a3[4] = v49;
      a3[5] = v50;
      a3[6].m128_i32[0] = v46;
      a3[6].m128_i16[2] = v189;
      goto LABEL_49;
    case 4u:
      v144[0] = 155979192;
      v145 = 270;
      v144[1] = -1296001454;
      v171 = 0;
      v37 = 151326202;
      v172 = 0;
      v38 = 20i64;
      v144[2] = -749967544;
      v144[3] = -1456003737;
      v144[4] = -427028385;
      v170 = 0i64;
      do
      {
        v170.m128_i32[v3] = v144[v3] ^ v37;
        ++v3;
        v37 = __ROL4__(
                ((v37 ^ (v37 << 13)) >> 7) ^ v37 ^ (v37 << 13) ^ ((((v37 ^ (v37 << 13)) >> 7) ^ v37 ^ (v37 << 13)) << 17),
                4);
      }
      while ( v3 < 5 );
      do
      {
        v39 = v37;
        v37 >>= 8;
        v170.m128_i8[v38] = *(v144 + v38) ^ v39;
        ++v38;
      }
      while ( v38 < 0x16 );
      v40 = v171;
      v10 = &v170;
      *a3 = v170;
      a3[1].m128_i32[0] = v40;
      a3[1].m128_i16[2] = v172;
      goto LABEL_17;
    case 5u:
      v132.m128_u64[0] = 0x6A27DE6B74FAAECAi64;
      v139 = 0i64;
      v132.m128_u64[1] = 0x6EF90A93EC6533CFi64;
      v35 = -772234038;
      v140 = 0i64;
      v11 = 32i64;
      v133 = -150991934;
      v134 = 955912910;
      v135 = -1101475749;
      v136 = 555552268;
      do
      {
        v35 = __ROL4__(53753 * v35 + 16295114, 1);
        v139.m128_i32[v3] = v132.m128_i32[v3] ^ v35;
        ++v3;
      }
      while ( v3 < 8 );
      v10 = &v139;
      v36 = v140;
      *a3 = v139;
      a3[1] = v36;
      goto LABEL_50;
    case 6u:
      v150[0] = -453517414;
      v151 = 28609;
      v150[1] = -521211975;
      v181 = 0;
      v29 = -460398647;
      v182 = 0;
      v30 = 36i64;
      v150[2] = -1834903794;
      v150[3] = -1766503626;
      v150[4] = 1515496125;
      v150[5] = -74069300;
      v150[6] = 244397602;
      v150[7] = -836062234;
      v150[8] = 712997289;
      v179 = 0i64;
      v180 = 0i64;
      do
      {
        v179.m128_i32[v3] = v150[v3] ^ v29;
        ++v3;
        v29 = -(((v29 ^ (v29 << 13)) >> 7) ^ v29 ^ (v29 << 13) ^ ((((v29 ^ (v29 << 13)) >> 7) ^ v29 ^ (v29 << 13)) << 17));
      }
      while ( v3 < 9 );
      do
      {
        v31 = v29;
        v29 >>= 8;
        v179.m128_i8[v30] = *(v150 + v30) ^ v31;
        ++v30;
      }
      while ( v30 < 0x26 );
      v32 = v181;
      v10 = &v179;
      v33 = v180;
      *a3 = v179;
      a3[1] = v33;
      a3[2].m128_i32[0] = v32;
      v34 = v182;
LABEL_29:
      a3[2].m128_i16[2] = v34;
      v11 = 38i64;
      goto LABEL_50;
    case 8u:
      LODWORD(v141) = 0;
      v132.m128_u64[0] = 0x7EDAA5D609B5A97Ci64;
      v139 = 0i64;
      v26 = 630037682;
      v140 = 0i64;
      v132.m128_u64[1] = 0xAFC850A1C146EC01ui64;
      v133 = -309083660;
      v134 = 2019338737;
      v135 = -1685486611;
      v136 = -391082660;
      v137 = -771781001;
      do
      {
        v26 = __ROR4__(9613 * v26 + 9280690, 2);
        v139.m128_i32[v3] = v132.m128_i32[v3] ^ v26;
        ++v3;
      }
      while ( v3 < 9 );
      v27 = v141;
      v10 = &v139;
      v28 = v140;
      v11 = 36i64;
      *a3 = v139;
      a3[1] = v28;
      a3[2].m128_i32[0] = v27;
      goto LABEL_50;
    case 9u:
      v162[0] = 536304382;
      v12 = 190i64;
      v162[1] = -735863716;
      v162[2] = -229996889;
      v162[3] = -1212559877;
      v162[4] = 28605713;
      v162[5] = 690537380;
      v162[6] = -533950930;
      v162[7] = 370939538;
      v162[8] = 1411251350;
      v162[9] = 2039325702;
      v162[10] = -1199787616;
      v162[11] = -1745592714;
      v162[12] = 500097960;
      v162[13] = -1019046278;
      v162[14] = 1010396452;
      v162[15] = -1404132213;
      v162[16] = -1187356060;
      v162[17] = 1284923835;
      v162[18] = 1284307350;
      v162[19] = 1061211636;
      v162[20] = 1539272023;
      v162[21] = 228068435;
      v162[22] = 864310578;
      v162[23] = -650407266;
      v162[24] = -1780687208;
      v162[25] = 1616385241;
      v162[26] = -288188220;
      v162[27] = -1211714903;
      v162[28] = -592567843;
      v162[29] = -543323335;
      v162[30] = -511433276;
      v162[31] = 1986563388;
      v162[32] = -513328700;
      v162[33] = -37526527;
      v162[34] = -1746998518;
      v162[35] = 1081600095;
      v162[36] = 298073224;
      v162[37] = -390772553;
      v162[38] = -1100890329;
      v162[39] = -486410918;
      v162[40] = 1565028293;
      v162[41] = -2139889677;
      v162[42] = 1097904911;
      v162[43] = -238950557;
      v162[44] = -1728383367;
      v162[45] = -1326119629;
      v162[46] = -1368148647;
      v163 = 24628;
      EAC_memset(v201, 0, 0xBEui64);
      v13 = 530930338;
      v14 = 188i64;
      do
      {
        v201[0].m128_i32[v3] = v162[v3] ^ v13;
        ++v3;
        v13 = ~(((v13 ^ (v13 >> 7)) << 9) ^ v13 ^ (v13 >> 7) ^ ((((v13 ^ (v13 >> 7)) << 9) ^ v13 ^ (v13 >> 7)) >> 13));
      }
      while ( v3 < 47 );
      do
      {
        v15 = v13;
        v13 >>= 8;
        v201[0].m128_i8[v14] = *(v162 + v14) ^ v15;
        ++v14;
      }
      while ( v14 < 0xBE );
      v16 = v201[1];
      *a3 = v201[0];
      v17 = v201[2];
      a3[1] = v16;
      v18 = v201[3];
      a3[2] = v17;
      v19 = v201[4];
      a3[3] = v18;
      v20 = v201[5];
      a3[4] = v19;
      v21 = v201[6];
      a3[5] = v20;
      a3[6] = v21;
      v22 = a3 + 8;
      v10 = v201;
      v22[-1] = v201[7];
      v23 = v202;
      v24 = v201[9];
      *v22 = v201[8];
      v25 = v201[10];
      v22[1] = v24;
      v22[2] = v25;
      v22[3].m128_u64[0] = v23;
      v22[3].m128_i32[2] = v203;
      v22[3].m128_i16[6] = v204;
      goto LABEL_49;
    case 0xAu:
      v142[0] = -208215069;
      v143 = -22325;
      v5 = 20i64;
      v142[1] = -1450406521;
      v168 = 0;
      v169 = 0;
      v6 = -202185814;
      v142[2] = -326926598;
      v142[3] = -12685846;
      v142[4] = -1046690966;
      v167 = 0i64;
      do
      {
        v7 = v142[v3] ^ v6;
        v6 = __ROR4__(214013 * v6 + 2531011, 1);
        v167.m128_i32[v3++] = v7;
      }
      while ( v3 < 5 );
      do
      {
        v8 = v6;
        v6 >>= 8;
        v167.m128_i8[v5] = *(v142 + v5) ^ v8;
        ++v5;
      }
      while ( v5 < 0x16 );
      v9 = v168;
      v10 = &v167;
      *a3 = v167;
      a3[1].m128_i32[0] = v9;
      a3[1].m128_i16[2] = v169;
LABEL_17:
      v11 = 22i64;
LABEL_50:
      result = 1;
      memset(v10, 0, v11);
      return result;
  }
  return 0;
}
// 1400289D4: using guessed type __m128 var_240[9];

//----- (000000014002AAEC) ----------------------------------------------------
char __fastcall sub_14002AAEC(_UNICODE_STRING *unicode_string)
{
  unsigned int v2; // ebx
  __int64 v4; // rax
  __int64 v5; // rax
  __int128 *v6; // r8
  __int16 *v7; // rdx
  __int128 v8; // xmm0
  __int64 v9; // rax
  wchar_t *v10; // rcx
  __int128 v11; // [rsp+20h] [rbp-E0h] BYREF
  int v12; // [rsp+30h] [rbp-D0h]
  int v13[6]; // [rsp+38h] [rbp-C8h] BYREF
  __m128 v14[4]; // [rsp+50h] [rbp-B0h] BYREF
  int v15; // [rsp+98h] [rbp-68h]
  char v16[32]; // [rsp+A0h] [rbp-60h] BYREF
  __m128 String[8]; // [rsp+C0h] [rbp-40h] BYREF

  EAC_memset(String, 0, 0x80ui64);
  v2 = 0;

  if ( !unicode_string )
    return 0;

  v13[0] = 1732584193;
  v13[1] = -271733879;
  v13[2] = -1732584194;
  v13[3] = 271733878;
  v13[4] = -1009589776;
  EAC_memset(v14, 0, 0x48ui64);
  v15 = 0;
  v4 = sub_140010C68(v13, 0xFFFFF78000000274ui64, 0x40ui64);
  v5 = sub_140010B2C(v4, v16);
  v6 = &v11;
  v7 = &String[0].m128_i16[1];
  v8 = *v5;
  v12 = *(v5 + 16);
  v11 = v8;
  do
  {
    v9 = *v6;
    ++v2;
    v6 = (v6 + 1);
    v10 = off_14007CD60[v9];
    *(v7 - 1) = *v10;
    *v7 = v10[1];
    v7 += 2;
  }
  while ( v2 < 0x14 );
  return EAC_Read_String_From_Unicode_String(unicode_string, String);
}
// 14007CD60: using guessed type wchar_t *off_14007CD60[256];
// 14002AAEC: using guessed type __m128 var_F0[4];
// 14002AAEC: using guessed type char var_A0[32];

//----- (000000014002B838) ----------------------------------------------------
bool __fastcall Get_ZwDeleteFile(struct _UNICODE_STRING *unicode_string)
{
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+20h] [rbp-38h] BYREF

  if ( !unicode_string
    || !unicode_string->Buffer
    || !unicode_string->Length
    || !unicode_string->MaximumLength
    || KeGetCurrentIrql()
    || Get_KeAreAllApcsDisabled() )
  {
    return 0;
  }
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = unicode_string;
  return ZwDeleteFile(&ObjectAttributes) >= 0;
}

//----- (000000014002B8B0) ----------------------------------------------------
bool __fastcall Get_ZwQueryFullAttributesFile(struct _UNICODE_STRING *string)
{
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+20h] [rbp-78h] BYREF
  struct _FILE_NETWORK_OPEN_INFORMATION FileInformation; // [rsp+50h] [rbp-48h] BYREF

  if ( !string
    || !string->Buffer
    || !string->Length
    || !string->MaximumLength
    || KeGetCurrentIrql()
    || Get_KeAreAllApcsDisabled() )
  {
    return 0;
  }

  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.ObjectName = string;
  return ZwQueryFullAttributesFile(&ObjectAttributes, &FileInformation) >= 0;// ZwQueryFullAttributesFile
}

//----- (000000014002B938) ----------------------------------------------------
char __fastcall EAC_Copy_Unicode_from_Unicode(UNICODE_STRING *unicode_string, UNICODE_STRING *unicode_string2)
{
  PWSTR v4; // r9
  unsigned int Length; // ecx
  WCHAR *Buffer; // rax
  unsigned int v7; // r11d
  unsigned int v8; // edx
  WCHAR v9; // cx
  WCHAR string; // cx
  int MaximumLength; // ecx
  char result; // al

  if ( !unicode_string )
    return 0;

  if ( !unicode_string2 )
    return 0;

  v4 = unicode_string->Buffer;
  if ( !v4 )
    return 0;

  Length = unicode_string->Length;
  if ( Length < 2 )
    return 0;

  Buffer = v4;
  v7 = Length >> 1;
  v8 = 0;
  if ( Length >> 1 )
  {
    do
    {
      v9 = v4[v8];
      if ( !v9 )
        break;
      if ( v9 == 92 )
      {
        Buffer = (&v4[v8 + 1] & -(v8 < v7 - 1));
      }
      else if ( v9 == 0x3A )
      {
        Buffer = 0i64;
      }
      ++v8;
    }
    while ( v8 < v7 );
    if ( !Buffer )
      return 0;
  }

  string = *Buffer;
  if ( !*Buffer || string == 0x5C || string == 0x3A )
    return 0;

  unicode_string2->Buffer = Buffer;
  MaximumLength = 2 * (unicode_string->Length >> 1) - Buffer;
  result = 1;
  LOWORD(MaximumLength) = 2 * ((LODWORD(unicode_string->Buffer) + MaximumLength) >> 1);
  unicode_string2->Length = MaximumLength;
  unicode_string2->MaximumLength = MaximumLength;
  return result;
}

//----- (000000014002BA08) ----------------------------------------------------
char __fastcall ReadFile(HANDLE FileHandle, __int64 *Buffer, ULONG *Size)
{
  char ret; // bl
  ULONG Length; // esi MAPDST
  void *ReadBuffer; // rax MAPDST
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-48h] BYREF
  char FileInformation[8]; // [rsp+60h] [rbp-38h] BYREF

  ret = 0;
  if ( !FileHandle )
    return 0;

  if ( !Buffer )
    return 0;

  if ( !Size )
    return 0;
  *Buffer = 0i64;

  *Size = 0;
  if ( KeGetCurrentIrql() || Get_KeAreAllApcsDisabled() )
    return 0;

  if ( ZwQueryInformationFile(FileHandle, &IoStatusBlock, FileInformation, 0x18u, FileStandardInformation) >= 0 )
  {
    if ( Length )
    {
      ReadBuffer = EAC_Allocate_Memory(Length);
      if ( ReadBuffer )
      {
        if ( ZwReadFile(FileHandle, 0i64, 0i64, 0i64, &IoStatusBlock, ReadBuffer, Length, 0i64, 0i64) < 0 )
        {
          Get_ExFreePool(ReadBuffer);
        }
        else
        {
          *Buffer = ReadBuffer;
          ret = 1;
          *Size = Length;
        }
      }
    }
  }
  return ret;
}
// 14002BA08: using guessed type char FileInformation[8];

//----- (000000014002BB0C) ----------------------------------------------------
char __fastcall EAC_ReadFile(struct _UNICODE_STRING *unicode_string, __int64 *Buffer, ULONG *Size)
{
  char File; // bl
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+60h] [rbp-48h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+70h] [rbp-38h] BYREF
  void *FileHandle; // [rsp+B0h] [rbp+8h] BYREF

  File = 0;
  if ( !unicode_string )
    return 0;

  if ( !unicode_string->Buffer )
    return 0;

  if ( !unicode_string->Length )
    return 0;

  if ( !unicode_string->MaximumLength )
    return 0;

  if ( !Buffer )
    return 0;

  if ( !Size )
    return 0;

  *Buffer = 0i64;
  *Size = 0;

  if ( KeGetCurrentIrql() || Get_KeAreAllApcsDisabled() )
    return 0;

  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = unicode_string;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwCreateFile(&FileHandle, 0x120089u, &ObjectAttributes, &IoStatusBlock, 0i64, 0x80u, 7u, 1u, 0x20u, 0i64, 0) >= 0 )
  {
    File = ReadFile(FileHandle, Buffer, Size);
    ZwClose(FileHandle);
  }
  return File;
}

//----- (000000014002BC44) ----------------------------------------------------
char __fastcall sub_14002BC44(__int64 a1, __int64 *Buffer, ULONG *Size)
{
  char Handle; // bl
  __int64 v6; // rax
  int v8; // [rsp+20h] [rbp-28h] BYREF
  __int64 v9; // [rsp+28h] [rbp-20h]
  _UNICODE_STRING string; // [rsp+30h] [rbp-18h] BYREF

  Handle = 0;
  v9 = a1;
  if ( a1 )
  {
    v6 = -1i64;
    do
      ++v6;
    while ( *(a1 + v6) );
    LOWORD(v8) = v6;
    HIWORD(v8) = v6 + 1;
  }
  else
  {
    v8 = 0;
  }
  if ( Get_RtlMultiByteToUnicodeN(&string.Length, &v8) >= 0 )
  {
    Handle = EAC_ReadFile(&string, Buffer, Size);
    EAC_Free_UnicodeString(&string);
  }
  return Handle;
}
// 14002BC44: using guessed type struct _UNICODE_STRING string;

//----- (000000014002BCC8) ----------------------------------------------------
bool __fastcall EAC_Write_File(struct _UNICODE_STRING *unicode_string, __int64 Unknown, void *Buffer)
{
  bool Status; // bl
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+60h] [rbp-48h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+70h] [rbp-38h] BYREF
  void *FileHandle; // [rsp+B0h] [rbp+8h] BYREF

  Status = 0;
  if ( !unicode_string
    || !unicode_string->Buffer
    || !unicode_string->Length
    || !unicode_string->MaximumLength
    || !Buffer
    || KeGetCurrentIrql()
    || Get_KeAreAllApcsDisabled() )
  {
    return 0;
  }
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = unicode_string;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwCreateFile(&FileHandle, 0x40000000u, &ObjectAttributes, &IoStatusBlock, 0i64, 0x80u, 0, 5u, 0x20u, 0i64, 0) >= 0 )
  {
    Status = ZwWriteFile(FileHandle, 0i64, 0i64, 0i64, &IoStatusBlock, Buffer, 0x5FE8u, 0i64, 0i64) >= 0;
    ZwClose(FileHandle);
  }
  return Status;
}

//----- (000000014002BE08) ----------------------------------------------------
int EAC_Get_Reg_Key()
{
  int result; // eax
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-48h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+30h] [rbp-38h] BYREF
  void *KeyHandle; // [rsp+70h] [rbp+8h] BYREF

  RtlInitUnicodeString(&DestinationString, L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat");
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  result = ZwOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes);
  if ( result >= 0 )
  {
    ZwFlushKey(KeyHandle);
    return ZwClose(KeyHandle);
  }
  return result;
}

//----- (000000014002C050) ----------------------------------------------------
char __fastcall EAC_Set_Reg_Info(_QWORD *ValueData)
{
  __int64 CurrentProcess; // rax
  __int64 v3; // rdi
  __int64 (__fastcall *v4)(__int64); // rax
  struct _KPROCESS *v5; // rax
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // r15
  ULONG64 v8; // rcx
  __int64 v9; // rdx
  ULONG64 v10; // rbx
  unsigned __int64 i; // rcx
  __int64 v12; // rsi
  ULONG64 v13; // rdi
  unsigned __int64 v14; // rax
  __int64 v15; // rax
  unsigned int v16; // eax
  ULONG64 v18; // [rsp+30h] [rbp-88h]
  __int64 v19; // [rsp+38h] [rbp-80h] BYREF
  __int64 v20; // [rsp+40h] [rbp-78h] BYREF
  __int64 v21; // [rsp+48h] [rbp-70h] BYREF
  __int64 v22; // [rsp+50h] [rbp-68h] BYREF
  __int64 v23; // [rsp+58h] [rbp-60h] BYREF
  __int64 v24; // [rsp+60h] [rbp-58h] BYREF
  __int64 v25; // [rsp+68h] [rbp-50h] BYREF
  __int64 v26[9]; // [rsp+70h] [rbp-48h] BYREF
  int v27; // [rsp+C0h] [rbp+8h] BYREF
  int v28; // [rsp+C8h] [rbp+10h] BYREF
  int v29; // [rsp+D0h] [rbp+18h] BYREF
  __int64 v30; // [rsp+D8h] [rbp+20h] BYREF

  LOBYTE(CurrentProcess) = 0;
  HIDWORD(v30) = 0;

  v19 = 0i64;
  v20 = 0i64;
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  if ( ValueData )
  {
    CurrentProcess = Get_PsGetCurrentProcess();
    if ( CurrentProcess == ValueData[1] )
    {
      v3 = Get_PsGetCurrentProcess();
      v4 = (loc_14005B768)(qword_140085A58, &qword_140085A58, 0i64);
      LODWORD(CurrentProcess) = v4 ? v4(v3) : -1073741822;
      v28 = CurrentProcess;
      if ( CurrentProcess || *(ValueData + 0x87) )
      {
        v30 = *&KUSER_SHARED_DATA.SystemTime.LowPart;
        v5 = IoGetCurrentProcess();
        v26[0] = PsGetProcessCreateTimeQuadPart(v5);
        v29 = sub_14003EE08(ValueData[6]);
        v27 = *(ValueData + 4);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameState",
          4u,
          ValueData + 0x21C,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashGameID",
          4u,
          ValueData,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashPID",
          4u,
          &v27,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashCreateTime",
          0xBu,
          v26,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitTime",
          0xBu,
          &v30,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitStatus",
          4u,
          &v28,
          4u);
        LOBYTE(CurrentProcess) = RtlWriteRegistryValue(
                                   0,
                                   L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                                   L"ErrRpt_GameCrashInfo01",
                                   4u,
                                   &v29,
                                   4u);
        v6 = ValueData[23];
        v7 = v6 + ValueData[24];
        v8 = ValueData[44];
        if ( v8 )
        {
          LOBYTE(CurrentProcess) = EAC_IsUsermodeValidAddress(v8, 60i64, 1);
          v9 = ValueData[44];
          v10 = 0i64;
          v18 = 0i64;
          if ( v9 )
          {
            for ( i = 0i64; ; ++i )
            {
              v26[1] = i;
              if ( i >= 8 )
                break;
              LOBYTE(CurrentProcess) = *(v9 + 4 * i + 28) ^ 0x90;
              *(&v18 + i) = CurrentProcess;
              v10 = v18;
            }
          }
          if ( v10 )
          {
            LOBYTE(CurrentProcess) = EAC_IsUsermodeValidAddress(v10, 40i64, 1);
            v12 = *(v10 + 24);
            v13 = *(v10 + 32);
            if ( v12 )
            {
              LOBYTE(CurrentProcess) = EAC_IsUsermodeValidAddress(*(v10 + 24), 64i64, 1);
              if ( *v12 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo02",
                  4u,
                  (v12 + 12),
                  4u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo03",
                  0xBu,
                  (v12 + 16),
                  8u);
                v14 = *(v12 + 16);
                if ( v14 <= v6 || v14 > v7 )
                  v15 = 0i64;
                else
                  v15 = v14 - v6;
                v19 = v15;
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo04",
                  0xBu,
                  &v19,
                  8u);
                if ( *(v12 + 28) )
                  v20 = *(v12 + 32);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo05",
                  0xBu,
                  &v20,
                  8u);
                if ( *(v12 + 28) >= 2u )
                  v21 = *(v12 + 40);
                LOBYTE(CurrentProcess) = RtlWriteRegistryValue(
                                           0,
                                           L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                                           L"ErrRpt_GameCrashInfo06",
                                           0xBu,
                                           &v21,
                                           8u);
              }
            }
            if ( v13 )
            {
              LOBYTE(CurrentProcess) = EAC_IsUsermodeValidAddress(v13, 52i64, 1);
              if ( *v13 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo07",
                  4u,
                  (v13 + 12),
                  4u);
                v16 = *(v13 + 16);
                if ( v16 )
                {
                  v22 = *(v13 + 20);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 2 )
                {
                  v23 = *(v13 + 28);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 3 )
                {
                  v24 = *(v13 + 36);
                  v16 = *(v13 + 16);
                }
                if ( v16 >= 4 )
                  v25 = *(v13 + 44);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo08",
                  0xBu,
                  &v22,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo09",
                  0xBu,
                  &v23,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo10",
                  0xBu,
                  &v24,
                  8u);
                LOBYTE(CurrentProcess) = RtlWriteRegistryValue(
                                           0,
                                           L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                                           L"ErrRpt_GameCrashInfo11",
                                           0xBu,
                                           &v25,
                                           8u);
              }
            }
          }
        }
      }
    }
  }
  return CurrentProcess;
}
// 140085A58: using guessed type __int64 qword_140085A58;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014002C510) ----------------------------------------------------
NTSTATUS EAC_Delete_Reg_Value()
{
  return RtlDeleteRegistryValue(0, L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat", L"ErrRpt_ServiceState");
}
// 140061490: using guessed type wchar_t aErrrptServices[20];

//----- (000000014002C528) ----------------------------------------------------
__int64 sub_14002C528(_BYTE *a1, __int64 a2, __int64 a3, ...)
{
  unsigned int v4; // ebx
  unsigned __int64 v5; // rdi
  int v6; // eax
  va_list va; // [rsp+58h] [rbp+20h] BYREF

  va_start(va, a3);
  if ( (a2 - 1) <= 0x7FFFFFFE )
  {
    v5 = a2 - 1;
    v4 = 0;
    v6 = sub_14002C590(a1, a2 - 1, a3, va);
    if ( v6 < 0 || v6 > v5 )
    {
      a1[v5] = 0;
      return -2147483643;
    }
    else if ( v6 == v5 )
    {
      a1[v5] = 0;
    }
  }
  else
  {
    v4 = -1073741811;
    if ( a2 )
      *a1 = 0;
  }
  return v4;
}

//----- (000000014002C590) ----------------------------------------------------
__int64 __fastcall sub_14002C590(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall *v4)(__int64, __int64, __int64, __int64); // rax
  __int64 result; // rax
  int v10[8]; // [rsp+20h] [rbp-20h] BYREF

  v4 = qword_140086540;
  if ( qword_140086540
    || (v10[0] = 738478543,
        v10[1] = 97261477,
        v10[2] = 723676378,
        v10[3] = 788681693,
        v10[4] = -2081095845,
        v4 = (loc_14003CB4C)(v10),
        (qword_140086540 = v4) != 0) )
  {
    result = v4(a1, a2, a3, a4);
  }
  else
  {
    result = 0xFFFFFFFFi64;
  }
  if ( result < 0 )
    return 0xFFFFFFFFi64;
  return result;
}
// 140086540: using guessed type __int64 qword_140086540;

//----- (000000014002D218) ----------------------------------------------------
__int64 Get_PsGetCurrentProcess()
{
  __int64 (*f_PsGetCurrentProcess)(void); // rax

  f_PsGetCurrentProcess = (loc_14005B768)(qword_140085A28, &qword_140085A28, 0i64);
  return f_PsGetCurrentProcess();               // PsGetCurrentProcess
}
// 140085A28: using guessed type __int64 qword_140085A28;

//----- (000000014002D23C) ----------------------------------------------------
__int64 sub_14002D23C()
{
  __int64 (*v0)(void); // rax

  v0 = (loc_14005B768)(qword_140085A30, &qword_140085A30, 0i64);
  return v0();
}
// 140085A30: using guessed type __int64 qword_140085A30;

//----- (000000014002D260) ----------------------------------------------------
__int64 __fastcall sub_14002D260(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // rax

  v2 = (loc_14005B768)(qword_140085A58, &qword_140085A58, 0i64);
  if ( v2 )
    return v2(a1);
  else
    return 3221225474i64;
}
// 140085A58: using guessed type __int64 qword_140085A58;

//----- (000000014002D29C) ----------------------------------------------------
__int64 __fastcall Get_PsGetProcessId(__int64 Process)
{
  __int64 (__fastcall *g_PsGetProcessId)(__int64); // r8
  __int64 result; // rax

  g_PsGetProcessId = (loc_14005B768)(qword_140085A60, &qword_140085A60, 0i64);
  result = 0i64;

  if ( g_PsGetProcessId )
    return g_PsGetProcessId(Process);           // PsGetProcessId

  return result;
}
// 140085A60: using guessed type __int64 qword_140085A60;

//----- (000000014002D2D4) ----------------------------------------------------
__int64 __fastcall Get_PsGetProcessImageFileName(__int64 Process)
{
  __int64 (__fastcall *g_PsGetProcessImageFileName)(__int64); // r8
  __int64 result; // rax

  g_PsGetProcessImageFileName = (loc_14005B768)(qword_140085A68, &qword_140085A68, 0i64);
  result = 0i64;

  if ( g_PsGetProcessImageFileName )
    return g_PsGetProcessImageFileName(Process);// PsGetProcessImageFileName

  return result;
}
// 140085A68: using guessed type __int64 qword_140085A68;

//----- (000000014002D30C) ----------------------------------------------------
__int64 __fastcall Get_PsLookupProcessByProcessId(__int64 ProcessId, __int64 Process)
{
  __int64 (__fastcall *g_PsLookupProcessByProcessId)(__int64, __int64); // rax

  g_PsLookupProcessByProcessId = (loc_14005B768)(qword_140085AA8, &qword_140085AA8, 0i64);
  if ( g_PsLookupProcessByProcessId )
    return g_PsLookupProcessByProcessId(ProcessId, Process);// PsLookupProcessByProcessId
  else
    return 0xC0000002i64;
}
// 140085AA8: using guessed type __int64 qword_140085AA8;

//----- (000000014002D354) ----------------------------------------------------
__int64 __fastcall sub_14002D354(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (loc_14005B768)(qword_140085AB0, &qword_140085AB0, 0i64);
  result = 0i64;
  if ( v2 )

    return v2(a1);

  return result;
}
// 140085AB0: using guessed type __int64 qword_140085AB0;

//----- (000000014002D38C) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14002D38C(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (loc_14005B768)(qword_140085AB8, &qword_140085AB8, 0i64);
  if ( result )
    return result(a1);
  return result;
}
// 140085AB8: using guessed type __int64 qword_140085AB8;

//----- (000000014002D3BC) ----------------------------------------------------
NTSTATUS __fastcall Get_PsLookupThreadByThreadId(__int64 ThreadId, __int64 Thread)
{
  __int64 (__fastcall *g_PsLookupThreadByThreadId)(__int64, __int64); // rax

  g_PsLookupThreadByThreadId = (loc_14005B768)(qword_140085AE8, &qword_140085AE8, 0i64);
  if ( g_PsLookupThreadByThreadId )
    return g_PsLookupThreadByThreadId(ThreadId, Thread);// PsLookupThreadByThreadId
  else
    return 0xC0000002;
}
// 140085AE8: using guessed type __int64 qword_140085AE8;

//----- (000000014002D404) ----------------------------------------------------
__int64 __fastcall sub_14002D404(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (loc_14005B768)(qword_140085B00, &qword_140085B00, 0i64);
  result = 0i64;
  if ( v2 )
    return v2(a1);
  return result;
}
// 140085B00: using guessed type __int64 qword_140085B00;

//----- (000000014002D43C) ----------------------------------------------------
bool __fastcall Get_PsIsSystemThread(__int64 Thread)
{
  __int64 (__fastcall *g_PsIsSystemThread)(__int64); // r8
  bool result; // al

  g_PsIsSystemThread = (loc_14005B768)(qword_140085B10, &qword_140085B10, 0i64);
  result = 0;

  if ( g_PsIsSystemThread )
    return g_PsIsSystemThread(Thread);          // PsIsSystemThread

  return result;
}
// 140085B10: using guessed type __int64 qword_140085B10;

//----- (000000014002D628) ----------------------------------------------------
bool __fastcall sub_14002D628(unsigned __int64 a1)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rax
  bool v4; // si
  __int64 Memory; // rax
  __int64 v6; // rdi
  unsigned __int64 v7; // r11
  unsigned __int64 v8; // r8
  int v9; // eax
  int v10; // r9d
  _BYTE *v11; // rdx
  char v12; // cl
  unsigned int v13; // r9d
  unsigned __int64 v14; // rcx

  v2 = *(a1 + 32);
  if ( v2 )
    v3 = *(a1 + 24) / v2;
  else
    v3 = 0i64;
  *(a1 + 16) = v3;
  v4 = v3 > 0xF;
  Memory = EAC_Allocate_Memory(0x8208ui64);
  v6 = Memory;
  if ( Memory )
  {
    EAC_memset((Memory + 8), 0, 0x8200ui64);
    *v6 = 0i64;
    v7 = 0i64;
    *(v6 + 8) = -973052107;
    *(v6 + 12) = 1055613585;
    *(v6 + 16) = 1388400106;
    v8 = 24i64;
    *(v6 + 24) = -1586581109;
    *(v6 + 28) = 1264216793;
    v9 = -265666853 * (a1 >> 2);
    v10 = v9 ^ 0x53ED73B7;
    *(v6 + 20) = v9 ^ 0xBFF28701;
    do
    {
      v11 = (v7 + a1);
      ++v8;
      v12 = v7++ & 3;
      v13 = __ROR4__(1185459975 * v10 + 338961835, 3);
      v11[v6 + 8 - a1 + 24] = *v11 ^ (v13 >> (8 * v12));
      v10 = *v11 ^ v13;
    }
    while ( v7 < 0x28 );
    v14 = (v8 + 255) & 0xFFFFFFFFFFFFFF00ui64;
    while ( v8 < v14 )
    {
      v10 *= -265666853;
      *(v8 + v6 + 8) = BYTE1(v10);
      ++v8;
    }
    *(v6 + 24) ^= v10;
    *(v6 + 28) ^= v7;
    *v6 = v8;
    (loc_140016B54)(2112707037i64, v6 + 8);
    Get_ExFreePool(v6);
  }
  return v4;
}

//----- (000000014002D798) ----------------------------------------------------
bool sub_14002D798()
{
  unsigned __int8 CurrentIrql; // r10
  __int64 v1; // r11
  __int64 v2; // r9
  __int64 v3; // rdi
  unsigned __int64 v4; // r8
  __int64 v5; // kr00_8
  unsigned __int64 v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rax
  __int128 v11; // [rsp+20h] [rbp-30h] BYREF
  __int128 v12; // [rsp+30h] [rbp-20h]
  __int64 v13; // [rsp+40h] [rbp-10h]

  v11 = 0i64;
  v13 = 0i64;
  v12 = 0i64;
  CurrentIrql = KeGetCurrentIrql();
  __writecr8(0xFui64);
  v1 = *(&v12 + 1);
  v2 = 100i64;
  v3 = 100i64;
  do
  {
    v4 = __rdtsc();
    v5 = __cpuid(1, 0);
    *&v11 = __PAIR64__(EBX(v5), EAX(v5));
    *(&v11 + 1) = __PAIR64__(EDX(v5), ECX(v5));
    v6 = __rdtsc();
    v1 += ((HIDWORD(v6) << 32) | v6) - v4;
    --v3;
  }
  while ( v3 );
  v7 = v13;
  *(&v12 + 1) = v1;
  do
  {
    v8 = __rdtsc();
    v9 = __rdtsc();
    v7 += ((HIDWORD(v9) << 32) | v9) - v8;
    --v2;
  }
  while ( v2 );
  v13 = v7;
  __writecr8(CurrentIrql);
  return sub_14002D628(&v11);
}

//----- (000000014002D8FC) ----------------------------------------------------
__int64 sub_14002D8FC()
{
  __int64 v0; // rax
  __int64 v1; // r8
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 result; // rax
  int v5; // [rsp+20h] [rbp-20h] BYREF
  int v6; // [rsp+24h] [rbp-1Ch]
  int v7; // [rsp+28h] [rbp-18h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]

  v5 = 0x6B5B94D1;
  v6 = 0x9A79FFA5;
  v7 = 0x14C87BFB;
  v8 = 0x12CF7895;
  v9 = 0x894F3202;
  qword_1400832B0 = (loc_14003CB4C)(&v5);
  v5 = 0x60665ED4;
  v6 = 0x8F6317BF;
  v7 = 0x2FCA1659;
  v8 = 0x26E0BD53;
  v9 = 0xE891B7CF;
  qword_1400832A8 = (loc_14003CB4C)(&v5);
  v5 = 0xCB2F7245;
  v6 = 0xC39D7FBB;
  v7 = 0xE3C8E809;
  v8 = 0x3B800577;
  v9 = 0x864FC5DE;
  v0 = (loc_14003CB4C)(&v5);
  LOBYTE(v1) = 1;
  qword_140085B30 = (loc_14005B768)(v0, &qword_140085B30, v1);
  v5 = 0x83487E6B;
  v6 = 0x9DA9D8F6;
  v7 = 0x919EE1F1;
  v8 = 0x855A7572;
  v9 = 0x12C1A7F1;
  v2 = (loc_14003CB4C)(&v5);
  LOBYTE(v3) = 1;
  result = (loc_14005B768)(v2, &qword_140085B38, v3);
  qword_140085B38 = result;
  return result;
}
// 14002D9A4: variable 'v1' is possibly undefined
// 14002D9E9: variable 'v3' is possibly undefined
// 1400832A8: using guessed type __int64 qword_1400832A8;
// 1400832B0: using guessed type __int64 qword_1400832B0;
// 140085B30: using guessed type __int64 qword_140085B30;
// 140085B38: using guessed type __int64 qword_140085B38;

//----- (000000014002EEA0) ----------------------------------------------------
char __fastcall sub_14002EEA0(__int64 ProcessId)
{
  char *v1; // r14
  int v2; // ebx
  unsigned __int32 v4; // edx
  unsigned __int64 v5; // rdi
  char v6; // si
  __int64 User_Module; // r15
  char v8; // dl
  unsigned __int64 v9; // rdi
  unsigned __int32 v10; // edx
  unsigned __int64 v11; // r8
  int v12; // ecx
  unsigned __int64 i; // r8
  char v14; // cl
  unsigned int v15; // edx
  unsigned __int64 v16; // r8
  char v17; // cl
  ULONG64 v18; // rax
  char result; // al
  int v20; // [rsp+20h] [rbp-59h] BYREF
  char v21; // [rsp+24h] [rbp-55h]
  int v22; // [rsp+25h] [rbp-54h]
  int v23[5]; // [rsp+30h] [rbp-49h]
  _BYTE v24[19]; // [rsp+44h] [rbp-35h] BYREF
  _BYTE v25[19]; // [rsp+57h] [rbp-22h] BYREF
  __m128i si128; // [rsp+6Ah] [rbp-Fh]
  __int16 v27; // [rsp+7Ah] [rbp+1h]
  char v28; // [rsp+7Ch] [rbp+3h]
  __m128i v29; // [rsp+7Dh] [rbp+4h]
  __int16 v30; // [rsp+8Dh] [rbp+14h]
  char v31; // [rsp+8Fh] [rbp+16h]
  __int128 v32[2]; // [rsp+90h] [rbp+17h] BYREF

  v20 = -9830294;
  v21 = -24;
  v1 = 0i64;
  v23[0] = 56325197;
  v2 = 0;
  v23[1] = 187590156;
  v23[2] = -1537849126;
  v4 = -1104798343;
  v23[3] = -1489405341;
  v5 = 0i64;
  v23[4] = 867263238;
  memset(v32, 0, 20);
  do
  {
    v4 = _byteswap_ulong(((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13) ^ ((((v4 ^ (v4 << 13)) >> 7) ^ v4 ^ (v4 << 13)) << 17));
    *(v32 + v5 * 4) = v23[v5] ^ v4;
    ++v5;
  }
  while ( v5 < 5 );
  v6 = 1;
  User_Module = EAC_Get_User_Module(v32);
  v8 = 1;
  if ( User_Module )
  {
    v9 = 16i64;
    v27 = 28330;
    v10 = 210400868;
    v11 = 0i64;
    si128 = _mm_load_si128(xmmword_14007E4B0);
    v28 = 114;
    memset(v25, 0, sizeof(v25));
    do
    {
      v12 = si128.m128i_i32[v11] ^ v10;
      v10 = _byteswap_ulong(55835 * v10 + 1799973);
      *&v25[v11 * 4] = v12;
      ++v11;
    }
    while ( v11 < 4 );
    for ( i = 16i64; i < 0x13; ++i )
    {
      v14 = v10;
      v10 >>= 8;
      v25[i] = si128.m128i_i8[i] ^ v14;
    }
    v1 = sub_14001DA84(User_Module, v25);
    v8 = 3;
    if ( v1 )
    {
      v15 = 1725126853;
      v16 = 0i64;
      v29 = _mm_load_si128(&xmmword_14007E630);
      v30 = 19925;
      v31 = 60;
      memset(v24, 0, sizeof(v24));
      do
      {
        *&v24[v16 * 4] = v29.m128i_i32[v16] ^ v15;
        ++v16;
        v15 = ~(((v15 ^ (v15 << 13)) >> 7) ^ v15 ^ (v15 << 13) ^ ((((v15 ^ (v15 << 13)) >> 7) ^ v15 ^ (v15 << 13)) << 17));
      }
      while ( v16 < 4 );
      do
      {
        v17 = v15;
        v15 >>= 8;
        v24[v9] = v29.m128i_i8[v9] ^ v17;
        ++v9;
      }
      while ( v9 < 0x13 );
      v18 = sub_14001DA84(User_Module, v24);
      v2 = v18;
      v8 = 7;
      if ( v18 )
        goto LABEL_14;
    }
  }
  v6 = 0;
  if ( (v8 & 4) != 0 )
LABEL_14:
    memset(v24, 0, sizeof(v24));
  if ( (v8 & 2) != 0 )
    memset(v25, 0, sizeof(v25));
  result = 0;
  memset(v32, 0, 0x14ui64);
  if ( v6 )
  {
    v22 = v2 - v1 - 9;
    return sub_140012CC0(ProcessId, v1, &v20, 9u);
  }
  return result;
}
// 14007E4B0: using guessed type __m128i xmmword_14007E4B0[2];
// 14007E630: using guessed type __int128 xmmword_14007E630;

//----- (000000014002F14C) ----------------------------------------------------
void __fastcall sub_14002F14C(__int64 ThreadId)
{
  PVOID Object; // [rsp+30h] [rbp+8h] BYREF

  if ( ThreadId )
  {
    if ( Get_PsLookupThreadByThreadId(ThreadId, &Object) >= 0 )
    {
      sub_1400366DC(Object);
      ObfDereferenceObject(Object);
    }
  }
}

//----- (000000014002F180) ----------------------------------------------------
char sub_14002F180()
{
  _OWORD *v0; // rsi
  unsigned __int32 v1; // edx
  unsigned __int64 v2; // rdi
  __int64 v3; // rdi
  char v4; // bl
  char v5; // al
  unsigned int v6; // edx
  unsigned __int64 v7; // r8
  char result; // al
  __int64 CurrentProcess; // rax
  __int64 ProcessId; // rax
  int v11[5]; // [rsp+20h] [rbp-50h] BYREF
  __m128i si128; // [rsp+34h] [rbp-3Ch] BYREF
  int v13; // [rsp+44h] [rbp-2Ch]
  _BYTE v14[20]; // [rsp+48h] [rbp-28h] BYREF
  _BYTE v15[20]; // [rsp+5Ch] [rbp-14h] BYREF
  int v16; // [rsp+90h] [rbp+20h] BYREF
  int v17; // [rsp+94h] [rbp+24h]
  __m128i *p_si128; // [rsp+98h] [rbp+28h]
  _BYTE *v19; // [rsp+A0h] [rbp+30h]

  v16 = 218296;
  v17 = 1098432;
  v0 = 0i64;
  v11[0] = 1301652446;
  v1 = -2087307036;
  v11[1] = 703468119;
  v2 = 0i64;
  v11[2] = -262709448;
  v11[3] = -47009527;
  v11[4] = -1561219378;
  memset(v15, 0, sizeof(v15));
  p_si128 = v11;
  v19 = v15;
  do
  {
    v1 = _byteswap_ulong(1103515245 * v1 + 12345);
    *&v19[v2 * 4] = p_si128->m128i_i32[v2] ^ v1;
    ++v2;
  }
  while ( v2 < 5 );
  v3 = EAC_Get_User_Module(v15);
  v4 = 1;
  v5 = 1;
  if ( v3 )
  {
    v6 = 1394150432;
    si128 = _mm_load_si128(xmmword_14007E570);
    v13 = 443457419;
    v7 = 0i64;
    memset(v14, 0, sizeof(v14));
    p_si128 = &si128;
    v19 = v14;
    do
    {
      v6 = ~(((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13) ^ (32 * (((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13))));
      *&v19[v7 * 4] = p_si128->m128i_i32[v7] ^ v6;
      ++v7;
    }
    while ( v7 < 5 );
    v0 = sub_14001DA84(v3, v14);
    v5 = 3;
    if ( v0 )
      goto LABEL_8;
  }
  v4 = 0;
  if ( (v5 & 2) != 0 )
LABEL_8:
    memset(v14, 0, sizeof(v14));
  result = 0;
  memset(v15, 0, sizeof(v15));
  if ( v4 )
  {
    CurrentProcess = Get_PsGetCurrentProcess();
    ProcessId = Get_PsGetProcessId(CurrentProcess);
    return sub_140012CC0(ProcessId, v0, &v16, 8u);
  }
  return result;
}
// 14007E570: using guessed type __m128i xmmword_14007E570[11];

//----- (000000014002F304) ----------------------------------------------------
char sub_14002F304()
{
  char v0; // bl
  unsigned __int64 v1; // rdi
  char v2; // si
  unsigned int v3; // edx
  unsigned __int64 i; // r8
  char v5; // cl
  void *v6; // rax
  unsigned int v7; // edx
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // rdi
  char v10; // cl
  int v12[4]; // [rsp+20h] [rbp-59h]
  __int16 v13; // [rsp+30h] [rbp-49h]
  int v14[8]; // [rsp+32h] [rbp-47h]
  __int16 v15; // [rsp+52h] [rbp-27h]
  _BYTE v16[18]; // [rsp+58h] [rbp-21h] BYREF
  _BYTE v17[34]; // [rsp+70h] [rbp-9h] BYREF
  _UNICODE_STRING unicode_string; // [rsp+98h] [rbp+1Fh] BYREF
  _UNICODE_STRING v19[2]; // [rsp+A8h] [rbp+2Fh] BYREF

  v0 = 0;
  v12[0] = -1562178331;
  v12[1] = -1025192317;
  v13 = -23946;
  v12[2] = 195522965;
  v1 = 16i64;
  v12[3] = -478187679;
  memset(v16, 0, sizeof(v16));
  v2 = 0;
  v3 = -1567683442;
  for ( i = 0i64; i < 4; ++i )
  {
    *&v16[i * 4] = v12[i] ^ v3;
    v3 = -2531011 - 214013 * v3;
  }
  do
  {
    v5 = v3;
    v3 >>= 8;
    v16[v1] = *(v12 + v1) ^ v5;
    ++v1;
  }
  while ( v1 < 0x12 );
  Get_Unicode_string_Inline(&unicode_string, v16);
  v6 = sub_140020064(&unicode_string);
  if ( v6 )
  {
    ObfDereferenceObject(v6);
  }
  else
  {
    v14[0] = 1267467664;
    v15 = 19041;
    v14[1] = -624144018;
    v7 = 1271399884;
    v14[2] = 2087235088;
    v14[3] = -822729119;
    v8 = 0i64;
    v14[4] = 950368901;
    v9 = 32i64;
    v14[5] = 446655039;
    v14[6] = -1092116968;
    v14[7] = -1689846668;
    memset(v17, 0, sizeof(v17));
    do
    {
      *&v17[v8 * 4] = v14[v8] ^ v7;
      ++v8;
      v7 = ~(((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13) ^ (32 * (((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13))));
    }
    while ( v8 < 8 );
    do
    {
      v10 = v7;
      v7 >>= 8;
      v17[v9] = *(v14 + v9) ^ v10;
      ++v9;
    }
    while ( v9 < 0x22 );
    Get_Unicode_string_Inline(v19, v17);
    v2 = 1;
    if ( !Get_ZwQueryFullAttributesFile(v19) )
      goto LABEL_11;
  }
  v0 = 1;
  if ( (v2 & 1) != 0 )
LABEL_11:
    memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  return v0;
}

//----- (000000014002F508) ----------------------------------------------------
_DWORD *__fastcall sub_14002F508(unsigned __int64 a1, _DWORD *a2)
{
  __int64 v2; // r8
  int v4; // r9d
  _QWORD *i; // r10
  unsigned __int64 v6; // rcx

  v2 = 0i64;
  if ( a1 )
  {
    if ( a2 )
    {
      v4 = 0;
      if ( *a2 )
      {
        for ( i = a2 + 4; ; i += 3 )
        {
          v6 = *(i - 1);
          if ( a1 >= v6 && a1 <= *i + v6 )
            break;
          if ( ++v4 >= *a2 )
            return v2;
        }
        return &a2[4 * v4 + 2 + 2 * v4];
      }
    }
  }
  return v2;
}

//----- (000000014002F564) ----------------------------------------------------
char __fastcall sub_14002F564(_OWORD *a1, char *a2, __int64 a3)
{
  unsigned int *v6; // rdi
  unsigned __int16 i; // si
  unsigned int v8; // eax

  v6 = (*(a3 + 20) + a3 + 24);
  if ( !a1 || !a2 )
    return 0;
  EAC_IsUsermodeValidAddress(a1, 4096i64, 1);
  EAC_memcpy(a1, a2, 0x1000ui64);
  for ( i = 0; i < *(a3 + 6); ++i )
  {
    v8 = v6[4];
    if ( v8 )
    {
      EAC_IsUsermodeValidAddress(a1 + v6[3], v8, 1);
      EAC_memcpy((a1 + v6[3]), &a2[v6[5]], v6[4]);
    }
    v6 += 10;
  }
  return 1;
}

//----- (000000014002F64C) ----------------------------------------------------
void __fastcall sub_14002F64C(__int64 a1, __int64 a2)
{
  unsigned __int16 v4; // si
  _DWORD *v5; // rbx
  unsigned int v6; // r8d
  unsigned int v7; // r10d
  unsigned int v8; // [rsp+48h] [rbp+10h] BYREF

  v4 = 0;
  if ( *(a2 + 6) )
  {
    v5 = (a2 + *(a2 + 20) + 60i64);
    do
    {
      v6 = *(v5 - 5);
      if ( !v6 )
      {
        if ( (*v5 & 0x40) != 0 )
        {
          v6 = *(a2 + 32);
        }
        else if ( (*v5 & 0x80u) != 0 )
        {
          v6 = *(a2 + 36);
        }
      }
      v7 = dword_140073E58[4 * ((*v5 >> 29) & 1) + 2 * ((*v5 >> 30) & 1) + (*v5 >> 31)];
      v8 = v7;
      if ( (*v5 & 0x4000000) != 0 )
      {
        v7 |= 0x200u;
        v8 = v7;
      }
      if ( v6 )
        Get_ZwProtectVirtualMemory_2(a1 + *(v5 - 6), v6, v7, &v8);
      ++v4;
      v5 += 10;
    }
    while ( v4 < *(a2 + 6) );
  }
}
// 140073E58: using guessed type _DWORD dword_140073E58[8];

//----- (000000014002F730) ----------------------------------------------------
ULONG64 __fastcall sub_14002F730(char *a1)
{
  __int64 ret; // rbx
  unsigned __int64 v2; // rsi
  __int64 v3; // r14
  __int64 v4; // rax
  _BYTE *i; // rcx
  unsigned int v6; // edx
  _BYTE *v8; // r14
  unsigned int v9; // edx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdi
  int v12; // ecx
  char v13; // cl
  __int64 *v14; // rax
  __int64 User_Module; // rax
  int v16[2]; // [rsp+20h] [rbp-E0h]
  __int16 v17; // [rsp+28h] [rbp-D8h]
  __int64 v18[2]; // [rsp+2Ah] [rbp-D6h] BYREF
  _OWORD v19[16]; // [rsp+40h] [rbp-C0h] BYREF
  __int16 ModuleName[256]; // [rsp+140h] [rbp+40h] BYREF

  ret = 0i64;
  if ( !a1 )
    return 0i64;

  v2 = -1i64;
  v3 = -1i64;
  do
    ++v3;
  while ( a1[v3] );
  if ( (v3 - 1) > 0xFE )
    return 0i64;

  EAC_memcpy(v19, a1, v3);
  *(v19 + v3) = 0;
  v4 = 0i64;
  if ( !v3 )
    return 0i64;

  for ( i = v19; ; ++i )
  {
    v6 = v4 + 1;
    if ( *i == 46 )
      break;

    v4 = v6;
    if ( v6 >= v3 )
      return 0i64;
  }
  *(v19 + v4) = 0;
  v8 = v19 + v6;
  if ( !v8 )
    return 0i64;

  sub_14005D8D4(ModuleName, 0x100i64, v19);
  v16[0] = -1052994125;
  v17 = -11299;
  v9 = -1051159139;
  v16[1] = 455624065;
  v18[0] = 0i64;
  v10 = 0i64;
  LOWORD(v18[1]) = 0;
  v11 = 8i64;
  do
  {
    v12 = v16[v10] ^ v9;
    v9 = ~(1103515245 * v9 + 12345);
    *(v18 + v10 * 4) = v12;
    ++v10;
  }
  while ( v10 < 2 );
  do
  {
    v13 = v9;
    v9 >>= 8;
    *(v18 + v11) = *(v16 + v11) ^ v13;
    ++v11;
  }
  while ( v11 < 0xA );
  do
    ++v2;
  while ( ModuleName[v2] );
  if ( v2 <= 0xFF )
  {
    if ( v2 < 0xFF )
    {
      v14 = v18;
      do
      {
        if ( !*v14 )
          break;
        ModuleName[v2] = *v14;
        v14 = (v14 + 2);
        ++v2;
      }
      while ( v2 < 0xFF );
    }
    ModuleName[v2] = 0;
  }

  memset(v18, 0, 0xAui64);
  User_Module = EAC_Get_User_Module(ModuleName);
  if ( User_Module )
    return sub_14001DA84(User_Module, v8);

  return ret;
}
// 14002F730: using guessed type __int16 ModuleName[256];

//----- (000000014002F904) ----------------------------------------------------
char __fastcall sub_14002F904(_IMAGE_NT_HEADERS *Nt_Headers, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // r15
  ULONG64 AddressBase; // rax MAPDST
  _IMAGE_NT_HEADERS *NtHeaders; // rdi
  __int64 Size; // r14
  unsigned int *BaseAddress; // rbx
  unsigned int Address; // eax
  _DWORD *v11; // rax
  unsigned __int64 v12; // r13
  __int64 v13; // rax
  __int64 v14; // rcx
  unsigned int *v15; // rcx
  __int64 v16; // r15
  int *v17; // r14
  unsigned int *v18; // r15
  int v19; // eax
  unsigned int v20; // eax
  _DWORD *v21; // rax
  unsigned int v22; // eax
  unsigned __int64 v24; // [rsp+20h] [rbp-258h]
  char ModuleName[568]; // [rsp+40h] [rbp-238h] BYREF
  unsigned int OldProtection; // [rsp+298h] [rbp+20h] BYREF

  v3 = a3;
  LOBYTE(AddressBase) = a2;
  if ( Nt_Headers )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        sub_14005D8D4(ModuleName, 256i64, a3);
        AddressBase = EAC_Get_User_Module(ModuleName);
        if ( AddressBase )
        {
          LOBYTE(AddressBase) = 0x4D;
          if ( LOWORD(Nt_Headers->Signature) == 0x5A4D )
          {
            NtHeaders = (Nt_Headers + Nt_Headers->OptionalHeader.FileAlignment);
            if ( NtHeaders->Signature == 0x4550 )
            {
              Size = NtHeaders->OptionalHeader.DataDirectory[1].Size;
              if ( Size )
              {
                AddressBase = sub_14001D56C(
                                NtHeaders->OptionalHeader.DataDirectory[1].VirtualAddress,
                                (Nt_Headers + Nt_Headers->OptionalHeader.FileAlignment),
                                Nt_Headers);
                BaseAddress = AddressBase;

                if ( AddressBase != NtHeaders )
                {
                  Get_ZwProtectVirtualMemory_2(AddressBase, Size, 0x40u, &OldProtection);
                  while ( 1 )
                  {
                    Address = BaseAddress[3];
                    if ( !Address )
                      break;
                    v11 = sub_14001D56C(Address, NtHeaders, Nt_Headers);
                    if ( !v11 )
                      break;

                    if ( sub_14005D784(v11, v3, 0x20ui64) )
                    {
                      v12 = 0i64;
                      v24 = 0i64;
                      v13 = *(AddressBase + 0x3C);
                      v14 = *(v13 + AddressBase + 124);
                      if ( v14 )
                      {
                        v12 = AddressBase + *(v13 + AddressBase + 0x78);
                        v24 = v14 + v12;
                      }
                      v15 = BaseAddress;
                      if ( !BaseAddress[1] )
                        v15 = BaseAddress + 4;
                      v16 = BaseAddress[4];
                      v17 = sub_14001D56C(*v15, NtHeaders, Nt_Headers);
                      v18 = (a2 + v16);
LABEL_19:
                      v19 = *v17;
                      if ( !*v17 )
                      {
                        BaseAddress += 5;
                        v3 = a3;
                        continue;
                      }
                      if ( v19 < 0 )
                      {
                        v20 = sub_14001DA84(AddressBase, v19);
                        goto LABEL_25;
                      }
                      v21 = sub_14001D56C(v19, NtHeaders, Nt_Headers);
                      v22 = sub_14001DA84(AddressBase, v21 + 2);
                      *v18 = v22;
                      if ( v22 >= v12 && v22 < v24 )
                      {
                        v20 = sub_14002F730(v22);
LABEL_25:
                        *v18 = v20;
                      }
                      ++v17;
                      ++v18;
                      goto LABEL_19;
                    }
                    BaseAddress += 5;
                  }
                  LOBYTE(AddressBase) = Get_ZwProtectVirtualMemory_2(
                                          BaseAddress,
                                          NtHeaders->OptionalHeader.DataDirectory[1].Size,
                                          OldProtection,
                                          &OldProtection);
                }
              }
            }
          }
        }
      }
    }
  }
  return AddressBase;
}

//----- (000000014002FB18) ----------------------------------------------------
char __fastcall sub_14002FB18(_IMAGE_NT_HEADERS *Nt_Headers, __int64 a2, _BYTE *a3)
{
  _BYTE *v3; // r15
  __int64 User_Module; // rax
  ULONG64 v6; // r12
  ULONG FileAlignment; // edi
  __int64 Size; // r14
  unsigned int *BaseAddress; // rbx
  unsigned int v10; // eax
  _DWORD *v11; // rax
  ULONG64 v12; // r13
  __int64 v13; // rax
  __int64 v14; // rcx
  unsigned int *v15; // rcx
  __int64 v16; // r14
  unsigned __int64 *v17; // r15
  _QWORD *v18; // r14
  unsigned __int64 v19; // rcx
  ULONG64 v20; // rax
  _DWORD *v21; // rax
  char *v22; // rax
  unsigned __int64 v24; // [rsp+20h] [rbp-258h]
  char ModuleName[568]; // [rsp+40h] [rbp-238h] BYREF
  unsigned int OldProtection; // [rsp+298h] [rbp+20h] BYREF

  v3 = a3;
  LOBYTE(User_Module) = a2;
  if ( Nt_Headers )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        sub_14005D8D4(ModuleName, 0x100i64, a3);
        User_Module = EAC_Get_User_Module(ModuleName);
        v6 = User_Module;
        if ( User_Module )
        {
          LOBYTE(User_Module) = 0x4D;
          if ( LOWORD(Nt_Headers->Signature) == 0x5A4D )
          {
            *&FileAlignment = Nt_Headers + Nt_Headers->OptionalHeader.FileAlignment;
            if ( **&FileAlignment == 0x4550 )
            {
              Size = *(*&FileAlignment + 0x94i64);
              if ( Size )
              {
                User_Module = sub_14001D56C(
                                *(*&FileAlignment + 0x90i64),
                                (Nt_Headers + Nt_Headers->OptionalHeader.FileAlignment),
                                Nt_Headers);

                BaseAddress = User_Module;
                if ( User_Module != *&FileAlignment )
                {
                  Get_ZwProtectVirtualMemory_2(User_Module, Size, 0x40u, &OldProtection);
                  while ( 1 )
                  {
                    v10 = BaseAddress[3];
                    if ( !v10 )
                      break;
                    v11 = sub_14001D56C(v10, *&FileAlignment, Nt_Headers);
                    if ( !v11 )
                      break;

                    if ( sub_14005D784(v11, v3, 0x20ui64) )
                    {
                      v12 = 0i64;
                      v24 = 0i64;
                      v13 = *(v6 + 60);
                      v14 = *(v13 + v6 + 140);
                      if ( v14 )
                      {
                        v12 = v6 + *(v13 + v6 + 136);
                        v24 = v14 + v12;
                      }
                      v15 = BaseAddress;
                      if ( !BaseAddress[1] )
                        v15 = BaseAddress + 4;
                      v16 = BaseAddress[4];
                      v17 = sub_14001D56C(*v15, *&FileAlignment, Nt_Headers);
                      v18 = (a2 + v16);
LABEL_19:
                      v19 = *v17;
                      if ( !*v17 )
                      {
                        BaseAddress += 5;
                        v3 = a3;
                        continue;
                      }
                      if ( (*v17 & 0x8000000000000000ui64) != 0i64 )
                      {
                        v20 = sub_14001DA84(v6, v19);
                        goto LABEL_25;
                      }
                      v21 = sub_14001D56C(v19, *&FileAlignment, Nt_Headers);
                      v22 = sub_14001DA84(v6, v21 + 2);
                      *v18 = v22;
                      if ( v22 >= v12 && v22 < v24 )
                      {
                        v20 = sub_14002F730(v22);
LABEL_25:
                        *v18 = v20;
                      }
                      ++v17;
                      ++v18;
                      goto LABEL_19;
                    }
                    BaseAddress += 5;
                  }
                  LOBYTE(User_Module) = Get_ZwProtectVirtualMemory_2(
                                          BaseAddress,
                                          *(*&FileAlignment + 148i64),
                                          OldProtection,
                                          &OldProtection);
                }
              }
            }
          }
        }
      }
    }
  }
  return User_Module;
}

//----- (000000014002FD30) ----------------------------------------------------
void __fastcall sub_14002FD30(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rbp
  unsigned int v9; // r15d
  _DWORD *v10; // r14
  unsigned int *v11; // r12
  __int64 v12; // rdi
  _DWORD *v13; // rax
  unsigned int v14; // r9d
  int v15; // edx

  if ( a1 && a2 && a3 && a4 )
  {
    if ( a3 == 32 )
    {
      v6 = *(a4 + 52);
      v7 = 160i64;
    }
    else
    {
      if ( a3 != 64 )
        return;
      v6 = *(a4 + 48);
      v7 = 176i64;
    }
    v8 = a1 - v6;
    if ( a1 != v6 && *(a4 + v7 + 4) )
    {
      v9 = 0;
      v10 = sub_14001D56C(*(a4 + v7), a4, a2);
      do
      {
        v11 = v10 + 1;
        v12 = v10[1];
        if ( !v12 )
          break;
        v13 = sub_14001D56C(*v10, a4, a2);
        v14 = 0;
        v10 += 2;
        if ( ((v12 - 8) & 0xFFFFFFFFFFFFFFFEui64) != 0 )
        {
          do
          {
            v15 = *v10 >> 12;
            if ( v15 == 3 )
            {
              *(v13 + (*v10 & 0xFFF)) += v8;
            }
            else if ( v15 == 10 )
            {
              *(v13 + (*v10 & 0xFFF)) += v8;
            }
            v12 = *v11;
            ++v14;
            v10 = (v10 + 2);
          }
          while ( v14 < (v12 - 8) >> 1 );
        }
        v9 += v12;
      }
      while ( v9 < *(a4 + v7 + 4) );
    }
  }
}
// 14002FDC9: conditional instruction was optimized away because edi.4!=0

//----- (000000014002FE68) ----------------------------------------------------
bool __fastcall EAC_MapImage(
        char *BaseAddress_1,
        unsigned __int64 Lenght,
        _QWORD *a3,
        _QWORD *SizeOfImage,
        _QWORD *a5,
        DWORD *VirtualAddress,
        DWORD *Directory_BaseReloc_Size)
{
  char *Buffer; // r14
  _IMAGE_NT_HEADERS *NtHeadersOut_2; // rcx
  WORD Machine; // ax
  int v10; // r13d
  DWORD SizeOfImage_1_1; // r12d
  char *Memory; // rax
  unsigned int Seed; // edi
  DWORD Size; // ebx
  __int64 v15; // r8
  __int64 Allocate; // rax MAPDST
  ULONG64 BaseAddress; // rdi
  _OWORD *v19; // rdi
  __int64 v20; // rbx
  DWORD v22; // [rsp+20h] [rbp-78h]
  char OldProtection[4]; // [rsp+24h] [rbp-74h] BYREF
  _IMAGE_NT_HEADERS *NtHeadersOut; // [rsp+28h] [rbp-70h] BYREF
  char *v25; // [rsp+30h] [rbp-68h]
  unsigned int v26; // [rsp+38h] [rbp-60h]
  unsigned int v27; // [rsp+3Ch] [rbp-5Ch]
  _OWORD *v28; // [rsp+40h] [rbp-58h]
  __int64 AddressOut; // [rsp+48h] [rbp-50h] BYREF
  __int64 SizeOfImage_2; // [rsp+50h] [rbp-48h]
  unsigned int Size_2; // [rsp+A0h] [rbp+8h]

  Buffer = 0i64;
  v25 = 0i64;
  if ( !BaseAddress_1 || !Lenght || !a3 || !SizeOfImage || !a5 )
    return 0;

  *a3 = 0i64;
  *SizeOfImage = 0i64;
  *a5 = 0i64;
  if ( VirtualAddress )
    *VirtualAddress = 0;
  if ( Directory_BaseReloc_Size )
    *Directory_BaseReloc_Size = 0;

  if ( GetModuleInfo(BaseAddress_1, Lenght, &AddressOut, &NtHeadersOut) )
  {
    NtHeadersOut_2 = NtHeadersOut;
    Machine = NtHeadersOut->FileHeader.Machine;
    if ( Machine == 0x14C )
    {
      v10 = 32;
      SizeOfImage_1_1 = NtHeadersOut->OptionalHeader.SizeOfImage;
      v22 = SizeOfImage_1_1;
LABEL_18:
      SizeOfImage_2 = SizeOfImage_1_1;
      Memory = EAC_Allocate_Memory(SizeOfImage_1_1);
      Buffer = Memory;
      v25 = Memory;
      if ( Memory )
      {
        EAC_memcpy(Memory, BaseAddress_1, Lenght);
        Seed = EAC_Generate_Seed(4, 16) << 12;
        LODWORD(NtHeadersOut) = Seed;
        v26 = Seed;
        Size_2 = EAC_Generate_Seed(4, 16) << 12;
        v27 = Size_2;
        Size = SizeOfImage_1_1 + Size_2 + Seed;
        Allocate = EAC_Allocate_ProcessVirtualMemory(Size, Size, v15, 4);
        v28 = Allocate;
        if ( Allocate )
        {
          if ( Get_ZwProtectVirtualMemory_2(Allocate, Size, 0x40u, OldProtection) )
          {
            EAC_IsUsermodeValidAddress(Allocate, Seed, 1);
            sub_14003EEB0(Allocate, Seed);
            if ( Get_ZwProtectVirtualMemory_2(Allocate, Seed, 0x20u, OldProtection) )
            {
              BaseAddress = Allocate + v22 + Seed;
              EAC_IsUsermodeValidAddress(BaseAddress, Size_2, 1);
              sub_14003EEB0(BaseAddress, Size_2);
              if ( Get_ZwProtectVirtualMemory_2(BaseAddress, Size_2, 2u, OldProtection) )
              {
                v19 = (Allocate + NtHeadersOut);
                v28 = v19;
                v20 = &Buffer[*(AddressOut + 0x3C)];
                NtHeadersOut = v20;
                sub_14002FD30(v19, Buffer, v10, v20);
                if ( v10 == 64 )
                  *(v20 + 48) = v19;
                else
                  *(v20 + 52) = v19;
                if ( sub_14002F564(v19, Buffer, v20) )
                {
                  sub_14002F64C(v19, v20);
                  *a3 = v19;
                  *SizeOfImage = SizeOfImage_2;
                  *a5 = v19 + *(v20 + 40);
                }
              }
            }
          }
        }
      }
      goto LABEL_28;
    }
    if ( Machine == 0x8664 )
    {
      v10 = 0x40;
      SizeOfImage_1_1 = NtHeadersOut->OptionalHeader.SizeOfImage;
      v22 = SizeOfImage_1_1;

      if ( VirtualAddress )
        *VirtualAddress = NtHeadersOut->OptionalHeader.DataDirectory[5].VirtualAddress;

      if ( Directory_BaseReloc_Size )
        *Directory_BaseReloc_Size = NtHeadersOut_2->OptionalHeader.DataDirectory[5].Size;

      goto LABEL_18;
    }
  }
LABEL_28:
  if ( Buffer )
    Get_ExFreePool(Buffer);
  return *a5 != 0i64;
}
// 14002FFE0: variable 'v15' is possibly undefined
// 14002F64C: using guessed type __int64 __fastcall sub_14002F64C(_QWORD, _QWORD);
// 14003EEB0: using guessed type __int64 __fastcall sub_14003EEB0(_QWORD, _QWORD);

//----- (0000000140030140) ----------------------------------------------------
void __fastcall sub_140030140(ULONG64 BaseModule)
{
  int v2; // eax
  __int64 v3; // rcx
  char *v4; // rsi
  __int64 v5; // rax
  ULONG64 v6; // rbx
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  if ( BaseModule )
  {
    EAC_IsUsermodeValidAddress(BaseModule, 4096i64, 1);
    if ( GetModuleInfo(BaseModule, 0x1000ui64, 0i64, &v7) )
    {
      v2 = Check_Module_Architecture(BaseModule);
      if ( v2 == 32 )
      {
        v3 = 120i64;
      }
      else
      {
        if ( v2 != 64 )
          return;
        v3 = 136i64;
      }
      v4 = (v3 + v7);
      if ( *(v3 + v7 + 4) )
      {
        v5 = *v4;
        if ( v5 )
        {
          v6 = BaseModule + v5;
          sub_14001D338((BaseModule + v5), 40i64);
          *v6 = 0i64;
          *(v6 + 16) = 0i64;
          *(v6 + 32) = 0i64;
          sub_14001D338(v4, 8i64);
          *v4 = 0i64;
        }
      }
    }
  }
}

//----- (00000001400301F8) ----------------------------------------------------
char __fastcall sub_1400301F8(_BYTE *a1, unsigned int a2, int a3, __int64 a4, __int64 a5)
{
  int v6; // eax

  v6 = sub_14003D35C(qword_1400832A0, 1, 1, a1, a2, a3);
  *a5 = v6;
  if ( !v6 )
    return 0;
  *(a5 + 8) = a1;
  return 1;
}
// 1400832A0: using guessed type __int64 qword_1400832A0;

//----- (000000014003023C) ----------------------------------------------------
char __fastcall sub_14003023C(const char *a1, unsigned int a2, __int64 a3)
{
  unsigned __int64 v4; // rbx
  const char *v5; // rdi
  _DWORD *v6; // rax
  const char *v7; // rax
  unsigned int v8; // r10d
  __int16 v9; // cx
  __int64 v10; // rdx
  unsigned __int64 v11; // r8
  _DWORD *v12; // rax
  int v13; // eax
  unsigned int v14; // r10d
  int v15; // r11d
  int v16; // eax

  v4 = a1;
  if ( a2 < 0x80 )
    return 0;
  _mm_prefetch(a1, 1);
  v5 = &a1[a2];
  if ( a1 >= v5 - 32 )
    return 0;
  while ( 1 )
  {
    if ( *v4 == 0xA1A0A0D474E5089i64 )
    {
      v6 = (v4 + 128);
      if ( *(v4 + 8) == 0x524448490D000000i64 )
      {
        while ( v6 < v5 - 2 )
        {
          if ( *v6 == 1145980233 )
          {
            v7 = (v6 + 2);
            v8 = v7 - v4;
            goto LABEL_25;
          }
          ++v6;
        }
        goto LABEL_27;
      }
    }
    if ( *v4 == 0x10000 && !*(v4 + 5) && *(v4 + 6) == *(v4 + 7) && !*(v4 + 8) && !*(v4 + 11) && !*(v4 + 13) )
    {
      v9 = *(v4 + 4);
      if ( (v9 - 1) <= 5u )
      {
        v10 = *(v4 + 4);
        v11 = 16 * v10 + v4 + 6;
        if ( v11 > v4 && v11 <= v5 )
        {
          v8 = 0;
          if ( v9 )
          {
            v12 = (v4 + 14);
            do
            {
              v8 += *v12;
              v12 += 4;
              --v10;
            }
            while ( v10 );
          }
          v7 = (v4 + v8);
          if ( v7 > v4 && v7 <= v5 )
            break;
        }
      }
    }
LABEL_27:
    v4 += 8i64;
    if ( v4 >= (v5 - 32) )
      return 0;
  }
LABEL_25:
  if ( !v7 )
    goto LABEL_27;
  v13 = EAC_CRC32(v4, v8, 0);
  v16 = sub_14003D35C(qword_1400832A0, 1, v15, v4, v14, v13);
  *a3 = v16;
  if ( !v16 )
    goto LABEL_27;
  *(a3 + 8) = v4;
  return 1;
}
// 14003039C: variable 'v15' is possibly undefined
// 14003039C: variable 'v14' is possibly undefined
// 1400832A0: using guessed type __int64 qword_1400832A0;

//----- (00000001400303DC) ----------------------------------------------------
char __fastcall sub_1400303DC(__int64 a1, _DWORD *a2, __int128 **a3)
{
  char v3; // bl
  char v7; // di
  __int128 *v8; // rax
  unsigned int v9; // edx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdi
  int v12; // ecx
  char v13; // cl
  __int64 v14; // rax
  char v15; // dl
  __int64 v16; // rdi
  unsigned __int64 v17; // r12
  __int128 v18; // xmm0
  int v19; // eax
  __int64 v20; // rax
  __int64 v21; // rax
  int v23; // [rsp+20h] [rbp-89h] BYREF
  __int128 *v24; // [rsp+28h] [rbp-81h]
  _BYTE v25[18]; // [rsp+30h] [rbp-79h] BYREF
  __m128i si128; // [rsp+42h] [rbp-67h]
  __int16 v27; // [rsp+52h] [rbp-57h]
  int v28[6]; // [rsp+58h] [rbp-51h] BYREF
  __m128 v29[4]; // [rsp+70h] [rbp-39h] BYREF
  int v30; // [rsp+B8h] [rbp+Fh]
  char v31[32]; // [rsp+C0h] [rbp+17h] BYREF

  v3 = 0;
  v7 = 0;
  if ( a1 && a3 )
  {
    v23 = 0;
    v24 = 0i64;
    if ( qword_1400832A0 )
    {
      if ( *(a1 + 12) && sub_14003023C(*a1, *(a1 + 8), &v23) || sub_140060074(*a1, *(a1 + 8), sub_1400301F8, &v23) )
      {
        *a2 = v23;
        v8 = v24;
      }
      else
      {
        if ( !*(a1 + 12) )
          goto LABEL_13;
        v9 = -1353298710;
        si128 = _mm_load_si128(&xmmword_14007E640);
        v27 = -30451;
        v10 = 0i64;
        memset(v25, 0, sizeof(v25));
        v11 = 16i64;
        do
        {
          v12 = si128.m128i_i32[v10] ^ v9;
          v9 = __ROR4__(214013 * v9 + 2531011, 2);
          *&v25[v10 * 4] = v12;
          ++v10;
        }
        while ( v10 < 4 );
        do
        {
          v13 = v9;
          v9 >>= 8;
          v25[v11] = si128.m128i_i8[v11] ^ v13;
          ++v11;
        }
        while ( v11 < 0x12 );
        v7 = 1;
        v14 = (loc_1400327F4)(*a1, *(a1 + 8), v25, 17i64);
        v15 = 1;
        if ( !v14 )
LABEL_13:
          v15 = 0;
        if ( (v7 & 1) != 0 )
          memset(v25, 0, sizeof(v25));
        if ( !v15 )
          return v3;
        v16 = *a1;
        v17 = *(a1 + 8);
        if ( *a1 )
        {
          v28[0] = 1732584193;
          v28[1] = -271733879;
          v28[2] = -1732584194;
          v28[3] = 271733878;
          v28[4] = -1009589776;
          EAC_memset(v29, 0, 0x48ui64);
          v30 = 0;
          v20 = sub_140010C68(v28, v16, v17);
          v21 = sub_140010B2C(v20, v31);
          v18 = *v21;
          v19 = *(v21 + 16);
        }
        else
        {
          v18 = 0i64;
          v19 = 0;
        }
        dword_140086970 = v19;
        v8 = &xmmword_140086960;
        xmmword_140086960 = v18;
        *a2 = 115800791;
      }
      *a3 = v8;
      return 1;
    }
    return v3;
  }
  return 0;
}
// 14007E640: using guessed type __int128 xmmword_14007E640;
// 1400832A0: using guessed type __int64 qword_1400832A0;
// 140086960: using guessed type __int128 xmmword_140086960;
// 140086970: using guessed type int dword_140086970;
// 1400303DC: using guessed type __m128 var_90[4];
// 1400303DC: using guessed type char var_40[32];

//----- (00000001400309E8) ----------------------------------------------------
bool __fastcall sub_1400309E8(__int64 a1)
{
  __int64 ProcessId; // rdi
  __int64 *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rbx
  __int64 v8; // [rsp+38h] [rbp+10h] BYREF

  v8 = 0i64;
  ProcessId = Get_PsGetProcessId(a1);
  ExAcquireFastMutex(&stru_140085C78);
  v3 = sub_140022FFC(qword_140085C70);
  if ( v3 )
  {
    v6 = *v3;
  }
  else
  {
    v4 = sub_140053088(a1);
    if ( v4 && v4 == g_EAC_ProcessIg )
    {
      v5 = v8;
      if ( dword_140083230 == 2 )
        v5 = 1i64;
      v8 = v5;
    }
    sub_140022EAC(qword_140085C70, ProcessId, &v8, 8u);
    v6 = v8;
  }
  ExReleaseFastMutex(&stru_140085C78);
  return v6 != 0;
}
// 140083230: using guessed type int dword_140083230;
// 140083238: using guessed type __int64 g_EAC_ProcessIg;

//----- (0000000140030A98) ----------------------------------------------------
__int64 __fastcall sub_140030A98(__int64 Process, _DWORD *a2, int a3, unsigned int a4)
{
  char v5; // bl
  char v8; // r14
  unsigned __int32 v9; // edx
  unsigned __int64 v10; // rdi
  char v11; // dl
  int v12; // ecx
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  unsigned int v16; // ecx
  bool v17; // zf
  unsigned int v18; // edx
  unsigned __int64 v19; // rdi
  unsigned __int64 i; // rdi
  char v21; // cl
  char v22; // dl
  unsigned int v23; // edx
  unsigned __int64 v24; // rdi
  int v25; // ecx
  unsigned __int64 j; // rdi
  char v27; // cl
  char v28; // dl
  int v29; // ecx
  int v30; // edx
  int v31; // edi
  int v32; // ecx
  int v33; // edx
  int v34; // edx
  unsigned __int64 v35; // rdi
  int v37[2]; // [rsp+38h] [rbp-49h]
  __int16 v38; // [rsp+40h] [rbp-41h]
  char v39; // [rsp+42h] [rbp-3Fh]
  int v40[3]; // [rsp+43h] [rbp-3Eh]
  char v41; // [rsp+4Fh] [rbp-32h]
  int v42[3]; // [rsp+50h] [rbp-31h]
  __int16 v43; // [rsp+5Ch] [rbp-25h]
  char v44; // [rsp+5Eh] [rbp-23h]
  int v45[3]; // [rsp+5Fh] [rbp-22h]
  _BYTE v46[11]; // [rsp+6Bh] [rbp-16h] BYREF
  _BYTE v47[13]; // [rsp+76h] [rbp-Bh] BYREF
  _BYTE v48[15]; // [rsp+83h] [rbp+2h] BYREF
  _BYTE v49[12]; // [rsp+92h] [rbp+11h] BYREF
  char v50[24]; // [rsp+A0h] [rbp+1Fh] BYREF

  v5 = 0;
  if ( !EAC_GetProcessImageFileName(Process, v50) )
    return a4;

  v8 = 1;
  if ( !a2 || *a2 != 82 && *a2 != 280 && *a2 != 281 && *a2 != 283 && *a2 != 383 && *a2 != 490 )
    goto LABEL_13;
  v45[0] = -1065994954;
  memset(v49, 0, sizeof(v49));
  v9 = 407948980;
  v10 = 0i64;
  v45[1] = -1476711870;
  v45[2] = -245862254;
  do
  {
    v9 = _byteswap_ulong(6225 * v9 + 5295796);
    *&v49[v10 * 4] = v45[v10] ^ v9;
    ++v10;
  }
  while ( v10 < 3 );
  v5 = 1;
  if ( sub_14005D784(v50, v49) )
  {
    v11 = 1;
  }
  else
  {
LABEL_13:
    v11 = 0;
    if ( (v5 & 1) == 0 )
      goto LABEL_26;
  }
  v5 &= ~1u;
  memset(v49, 0, sizeof(v49));
  if ( v11 )
  {
    v12 = a4 | 2;
    if ( (a3 & 2) == 0 )
      v12 = a4;
    v13 = v12 | 8;
    if ( (a3 & 8) == 0 )
      v13 = v12;
    v14 = v13 | 0x10;
    if ( (a3 & 0x10) == 0 )
      v14 = v13;
    v15 = v14 | 0x20;
    if ( (a3 & 0x20) == 0 )
      v15 = v14;
    v16 = v15 | 0x200;
    if ( (a3 & 0x200) == 0 )
      v16 = v15;
    a4 = v16 | 0x400;
    v17 = (a3 & 0x400) == 0;
LABEL_64:
    if ( v17 )
      return v16;
    return a4;
  }
  if ( *a2 != 20 )
    goto LABEL_33;
LABEL_26:
  v37[0] = 1877804542;
  memset(v46, 0, sizeof(v46));
  v5 |= 2u;
  v18 = 1067864747;
  v19 = 0i64;
  v37[1] = -954710973;
  v38 = -16981;
  v39 = 34;
  do
  {
    *&v46[v19 * 4] = v37[v19] ^ v18;
    ++v19;
    v18 = ~(((v18 ^ (v18 << 13)) >> 7) ^ v18 ^ (v18 << 13) ^ ((((v18 ^ (v18 << 13)) >> 7) ^ v18 ^ (v18 << 13)) << 17));
  }
  while ( v19 < 2 );
  for ( i = 8i64; i < 0xB; ++i )
  {
    v21 = v18;
    v18 >>= 8;
    v46[i] = *(v37 + i) ^ v21;
  }
  if ( sub_14005D784(v50, v46) )
    v22 = 1;
  else
LABEL_33:
    v22 = 0;
  if ( (v5 & 2) != 0 )
  {
    v5 &= ~2u;
    memset(v46, 0, sizeof(v46));
  }
  if ( v22 )
  {
    v16 = a4 | 0x400;
    if ( (a3 & 0x400) == 0 )
      v16 = a4;
    a4 = v16 | 0x10;
    v17 = (a3 & 0x10) == 0;
    goto LABEL_64;
  }
  if ( *a2 != 330 )
    goto LABEL_47;
  v42[0] = 1489887905;
  memset(v48, 0, sizeof(v48));
  v5 |= 4u;
  v23 = 1069515766;
  v24 = 0i64;
  v42[1] = -1802321559;
  v42[2] = 743400761;
  v43 = 4527;
  v44 = 104;
  do
  {
    v25 = v42[v24] ^ v23;
    v23 = ~(1103515245 * v23 + 12345);
    *&v48[v24 * 4] = v25;
    ++v24;
  }
  while ( v24 < 3 );
  for ( j = 12i64; j < 0xF; ++j )
  {
    v27 = v23;
    v23 >>= 8;
    v48[j] = *(v42 + j) ^ v27;
  }
  if ( sub_14005D784(v50, v48) )
    v28 = 1;
  else
LABEL_47:
    v28 = 0;
  if ( (v5 & 4) != 0 )
  {
    v5 &= ~4u;
    memset(v48, 0, sizeof(v48));
  }
  if ( v28 )
  {
    v29 = a4 | 0x40;
    if ( (a3 & 0x40) == 0 )
      v29 = a4;
    v30 = v29 | 0x400;
    if ( (a3 & 0x400) == 0 )
      v30 = v29;
    v31 = v30 | 0x1000;
    if ( (a3 & 0x1000) == 0 )
      v31 = v30;
    v32 = v31 | 0x800;
    if ( (a3 & 0x800) == 0 )
      v32 = v31;
    v33 = v32 | 1;
    if ( (a3 & 1) == 0 )
      v33 = v32;
    v16 = v33 | 0x10;
    if ( (a3 & 0x10) == 0 )
      v16 = v33;
    a4 = v16 | 0x100000;
    v17 = (a3 & 0x100000) == 0;
    goto LABEL_64;
  }
  if ( KUSER_SHARED_DATA.NtMajorVersion < 0xA )
    goto LABEL_72;
  if ( (a3 & 0x400) == 0 )
    goto LABEL_72;
  v40[0] = -1227592197;
  memset(v47, 0, sizeof(v47));
  v5 |= 8u;
  v34 = -977989991;
  v35 = 0i64;
  v40[1] = 795006281;
  v40[2] = -254551766;
  v41 = -26;
  do
  {
    *&v47[v35 * 4] = v40[v35] ^ v34;
    ++v35;
    v34 = __ROR4__(
            ((v34 ^ (v34 << 13)) >> 17) ^ v34 ^ (v34 << 13) ^ (32 * (((v34 ^ (v34 << 13)) >> 17) ^ v34 ^ (v34 << 13))),
            3);
  }
  while ( v35 < 3 );
  v47[12] = v41 ^ v34;
  if ( !sub_14005D784(v50, v47) )
LABEL_72:
    v8 = 0;
  if ( (v5 & 8) != 0 )
    memset(v47, 0, sizeof(v47));
  if ( v8 )
    a4 |= 0x400u;
  return a4;
}
// 14005D784: using guessed type __int64 __fastcall sub_14005D784(_QWORD, _QWORD);
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140030F4C) ----------------------------------------------------
__int64 __fastcall sub_140030F4C(__int64 a1, __int64 **a2)
{
  __int64 ProcessId; // rax
  __int64 v5; // r8
  __int64 v7; // rax
  __int64 *v8; // rax

  ProcessId = Get_PsGetProcessId(a1);
  v5 = g_EAC_ProcessIg;
  *a2 = 0i64;
  if ( v5 && ProcessId == v5 )
    return 1i64;
  if ( EAC_Is_Equal_ProcessId(ProcessId) )
    return 2i64;
  v7 = Get_PsGetProcessId(a1);
  v8 = sub_14000D7E8(v7);
  *a2 = v8;
  return v8 != 0i64 ? 3 : 0;
}
// 140083238: using guessed type __int64 qword_140083238;

//----- (0000000140031AEC) ----------------------------------------------------
bool __fastcall sub_140031AEC(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rcx
  __int64 v5; // [rsp+40h] [rbp+18h] BYREF
  __int64 v6; // [rsp+48h] [rbp+20h] BYREF

  v2 = *a1;
  v6 = 0i64;
  v5 = 0i64;
  sub_140052A50(v2, &v6);
  sub_140052A50(*a2, &v5);
  return v6 > v5;
}

//----- (0000000140031B30) ----------------------------------------------------
signed __int64 __fastcall sub_140031B30(char *a1, __int64 a2, unsigned int a3)
{
  char *v4; // rbx
  unsigned __int64 v7; // rsi
  char *v8; // rdx
  char *v9; // rdx
  char *v10; // rbx
  unsigned __int64 v11; // rsi
  char *v12; // rdx
  char *v13; // rsi
  unsigned __int64 v14; // rbx
  char *v15; // rbx

  v4 = a1;
  if ( a3 < 8 )
    return 0i64;
  if ( a1 && a2 )
  {
    v7 = 0i64;
    v8 = (a2 + 8);
    if ( v8 )
    {
      do
      {
        if ( !v8[v7] )
          break;
        ++v7;
      }
      while ( v7 < 0xFF );
    }
    EAC_memcpy(a1, v8, v7);
    v9 = (a2 + 320);
    v10 = &v4[v7];
    v11 = 0i64;
    v10[1] = *(a2 + 264);
    *(v10 + 2) = *(a2 + 268);
    *(v10 + 6) = *(a2 + 272);
    *(v10 + 10) = *(a2 + 276);
    v10[14] = *a2;
    v10[15] = *(a2 + 1);
    if ( a2 != -320 )
    {
      do
      {
        if ( !v9[v11] )
          break;
        ++v11;
      }
      while ( v11 < 0xFF );
    }
    EAC_memcpy(v10 + 1, v9, v11);
    v12 = (a2 + 576);
    v13 = &v10[v11 + 17];
    v14 = 0i64;
    if ( a2 != -576 )
    {
      do
      {
        if ( !v12[v14] )
          break;
        ++v14;
      }
      while ( v14 < 0xFF );
    }
    EAC_memcpy(v13, v12, v14);
    v15 = &v13[v14];
    v15[1] = *(a2 + 265);
    *(v15 + 2) = *(a2 + 288);
    *(v15 + 10) = *(a2 + 296);
    *(v15 + 18) = *(a2 + 304);
    *(v15 + 26) = *(a2 + 312);
    *(v15 + 30) = *(a2 + 316);
    v4 = v15 + 34;
  }
  return v4 - a1;
}

//----- (0000000140031C84) ----------------------------------------------------
__int64 __fastcall sub_140031C84(__int64 a1, char a2)
{
  __int64 result; // rax
  unsigned int *v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // eax
  __int64 v7; // rcx
  unsigned int v8; // r10d
  unsigned int v9; // r9d
  __int64 v10; // r15
  unsigned int v11; // ebx
  __int64 v12; // r12
  unsigned int *v13; // r13
  unsigned int *v14; // r14
  __int64 v15; // rbp
  __int64 v16; // r15
  unsigned int v17; // edx
  __int64 v18; // rax
  unsigned int v19; // ebx
  unsigned int *v20; // r14
  unsigned int v21; // edi
  int v22; // ebp
  int v23; // ecx
  unsigned int *v24; // r15
  __int64 v25; // r12
  __int64 v26; // rdx

  result = word_14008327C;
  if ( word_14008327C )
  {
    v3 = qword_140083280;
    v4 = 832 * word_14008327C;
    if ( qword_140083280 )
    {
      if ( v4 >= 8 )
      {
        v5 = v4 >> 2;
        v6 = 0x34 / v5;
        v7 = v5 - 1;
        v8 = v6 + 6;
        if ( a2 )
        {
          v9 = *(qword_140083280 + 4 * v7);
          v10 = qword_140083280 + 4;
          v11 = 0;
          do
          {
            v11 -= 1640531527;
            v12 = 0i64;
            v13 = v10;
            v14 = v3;
            v15 = (v11 >> 2) & 3;
            v16 = v7;
            do
            {
              v17 = *v13++;
              v18 = v15 ^ v12++ & 3;
              *v14 += ((v11 ^ v17) + (*(&unk_140083278 + v18 + 4) ^ v9)) ^ (((16 * v9) ^ (v17 >> 3))
                                                                          + ((v9 >> 5) ^ (4 * v17)));
              v9 = *v14++;
              --v16;
            }
            while ( v16 );
            v10 = (v3 + 1);
            result = 16 * v9;
            v3[v7] += ((v11 ^ *v3) + (*(&unk_140083278 + (v15 ^ 3) + 4) ^ v9)) ^ ((result ^ (*v3 >> 3))
                                                                                + ((v9 >> 5) ^ (4 * *v3)));
            v9 = v3[v7];
            --v8;
          }
          while ( v8 );
        }
        else
        {
          v19 = *qword_140083280;
          v20 = (qword_140083280 + 4 * v7);
          v21 = -1640531527 * v8;
          v22 = v7;
          do
          {
            v23 = v22;
            v24 = v20;
            v25 = (v21 >> 2) & 3;
            do
            {
              v26 = v25 ^ v23-- & 3;
              *v24 -= ((v21 ^ v19) + (*(&unk_140083278 + v26 + 4) ^ v3[v23])) ^ (((16 * v3[v23]) ^ (v19 >> 3))
                                                                               + ((v3[v23] >> 5) ^ (4 * v19)));
              v19 = *v24--;
            }
            while ( v23 );
            result = 16 * *v20;
            *v3 -= ((v21 ^ v19) + (*(&unk_140083278 + v25 + 4) ^ *v20)) ^ ((result ^ (v19 >> 3))
                                                                         + ((*v20 >> 5) ^ (4 * v19)));
            v19 = *v3;
            v21 += 1640531527;
          }
          while ( v21 );
        }
      }
    }
  }
  return result;
}
// 14008327C: using guessed type __int16 word_14008327C;
// 140083280: using guessed type __int64 qword_140083280;

//----- (00000001400326C0) ----------------------------------------------------
// from @Swiftik
char EAC_CheckHyperVisor()
{
  char v1; // [rsp+50h] [rbp+8h] BYREF

  EAC_vmreadwrapper(0i64, &v1);
  return 1;
}

//----- (0000000140032740) ----------------------------------------------------
// from @Swiftik
char __fastcall EAC_GetMappedFilename(__int64 ProcessHandle, __int64 BaseAddress, _UNICODE_STRING *unicode_string)
{
  char ret; // bl
  __int64 Memory; // rax
  unsigned __int16 *Buffer; // rdi

  ret = 0;
  if ( ProcessHandle )
  {
    if ( BaseAddress )
    {
      if ( unicode_string )
      {
        Memory = EAC_Allocate_Memory(0x212ui64);
        Buffer = Memory;
        if ( Memory )
        {
          *Memory = 0x2000000;
          *(Memory + 8) = Memory + 0x10;
          if ( (loc_140053930)(ProcessHandle, BaseAddress, 2i64, Memory, 0x210i64) )
          {
            *(*(Buffer + 1) + 2 * (*Buffer >> 1)) = 0;
            ret = EAC_Read_String_From_Unicode_String(unicode_string, *(Buffer + 1));
          }
          Get_ExFreePool(Buffer);
        }
      }
    }
  }
  return ret;
}

//----- (0000000140032954) ----------------------------------------------------
unsigned __int64 __fastcall sub_140032954(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        _DWORD *a6)
{
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  __int64 v10; // rdx
  unsigned int v11; // r8d
  char v12; // cl
  char v13; // al
  char v14; // cl
  char v15; // dl
  char v16; // al
  __int16 *v17; // rdx
  char v18; // cl
  unsigned int v19; // ecx
  __int16 v20; // ax
  __int64 v22; // [rsp+20h] [rbp-18h] BYREF
  unsigned int v23; // [rsp+28h] [rbp-10h]
  int v24; // [rsp+2Ch] [rbp-Ch]

  v6 = a4 + 20;
  v7 = a4;
  if ( a4 + 20 <= a5 - 6 && sub_140060018(a1) )
  {
    if ( a2 )
    {
      v23 = 0;
      v22 = a2;
      v24 = 64;
      sub_140060138(a1, v10, &v22);
      v11 = v23;
      if ( v23 )
      {
        *v7 = *a1;
        *(v7 + 12) = *(a1 + 36);
        *(v7 + 8) = *(a1 + 24);
        v12 = *v7 & 0xFE | ((*(a1 + 8) == *a1) + 2);
        *v7 = v12;
        v13 = v12 & 0xFB | (*(a1 + 32) != 4096 ? 0 : 4);
        *v7 = v13;
        v14 = v13 & 0xF7 | (*(a1 + 32) != 0x10000 ? 0 : 8);
        *v7 = v14;
        v15 = v14 & 0xEF | (*(a1 + 32) != 0x2000 ? 0 : 0x10);
        *v7 = v15;
        v16 = v15 & 0xDF | (*(a1 + 40) != 0x1000000 ? 0 : 0x20);
        v17 = (a2 + 8);
        *v7 = v16;
        v18 = v16 & 0xBF | (*(a1 + 40) != 0x40000 ? 0 : 0x40);
        *v7 = v18;
        *v7 = v18 & 0x7F | (*(a1 + 40) != 0x20000 ? 0 : 0x80);
        v19 = 0;
        do
        {
          if ( v6 > a5 - 6 )
            break;
          ++v19;
          *v6 = *(v17 + 1);
          v20 = *v17;
          v17 += 8;
          *(v6 + 4) = v20;
          v6 += 6i64;
        }
        while ( v19 < v11 );
        *(v7 + 16) = v19;
        v7 = v6;
        if ( a6 )
          ++*a6;
      }
    }
  }
  return v7;
}
// 1400329BC: variable 'v10' is possibly undefined

//----- (0000000140032ADC) ----------------------------------------------------
__m128 *__fastcall sub_140032ADC(__int64 a1, unsigned int *a2)
{
  __m128 *result; // rax
  int v5; // edx
  __int64 v6; // rcx
  __int64 v7; // r14
  struct _FAST_MUTEX *v8; // rcx
  __int64 v9; // rsi
  char *v10; // rbx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  void *retaddr; // [rsp+38h] [rbp+0h] BYREF
  int v14; // [rsp+48h] [rbp+10h] BYREF
  char *v15; // [rsp+50h] [rbp+18h] BYREF

  result = &retaddr;
  if ( a2[10] < 0x20 )
  {
    result = sub_1400303DC(a1, &v14, &v15);
    if ( result )
    {
      v5 = v14;
      if ( v14 != 1866186003 || (result = *a2, (*(*a2 + 26i64) & 0x200) == 0) )
      {
        v6 = a2[10];
        v7 = 3 * (v6 + 2);
        a2[10] = v6 + 1;
        a2[2 * v7 + 4] = 0;
        a2[2 * v7] = v5;
        if ( v5 == 115800791 )
        {
          v8 = qword_140083228;
          LODWORD(v9) = 20;
          *(*a2 + 26i64) |= 0x100u;
          sub_140022EAC(v8, *(*a2 + 544i64), 0i64, 0);
          v10 = v15;
        }
        else
        {
          v9 = *(a1 + 8);
          v11 = *a1;
          v12 = *a1 + v9;
          if ( v9 < 0x8000 || (LODWORD(v9) = 0x8000, v10 = v15 - 0x4000, (v15 - 0x4000) < v11) || v10 > v12 )
          {
            v10 = v11;
          }
          else if ( (v10 + 0x8000) > v12 )
          {
            v10 = (v12 - 0x8000);
          }
        }
        result = EAC_Allocate_Memory(v9);
        *&a2[2 * v7 + 2] = result;
        if ( result )
        {
          a2[2 * v7 + 4] = v9;
          return EAC_memcpy(result, v10, v9);
        }
      }
    }
  }
  return result;
}
// 1400303DC: using guessed type __int64 __fastcall sub_1400303DC(_QWORD, _QWORD, _QWORD);

//----- (0000000140032D90) ----------------------------------------------------
void **__fastcall sub_140032D90(unsigned int *a1, __int64 a2, char a3)
{
  void **result; // rax
  char v4; // r14
  __int64 v7; // rdi
  unsigned __int64 v8; // r15
  __int64 v9; // r12
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r8
  __int128 v14; // [rsp+50h] [rbp-78h] BYREF
  __int64 v15[3]; // [rsp+60h] [rbp-68h] BYREF
  unsigned __int64 v16; // [rsp+78h] [rbp-50h]
  void *retaddr; // [rsp+C8h] [rbp+0h] BYREF
  unsigned int v19; // [rsp+E8h] [rbp+20h] BYREF

  result = &retaddr;
  v4 = a3;
  v7 = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v19 = 0;
  v14 = 0i64;
  if ( !a1 )
    return result;
  if ( !a3 )
    goto LABEL_8;
  if ( *(*a1 + 10i64) >= 0x8000u )
  {
LABEL_7:
    v4 = a3;
LABEL_8:
    v11 = a2;
    while ( 1 )
    {
      v15[0] = v11;
      if ( !(loc_140053930)(-1i64, v11, 0i64, v15, 48i64) )
        break;
      v12 = v15[0];
      if ( !v15[0] || a2 && v15[1] != a2 )
        break;
      if ( a1[10] == 32 )
        break;
      if ( Get_MmGetPhysicalAddress(v15[0]) )
      {
        EAC_IsUsermodeValidAddress(v15[0], v16, 1);
        BYTE12(v14) = 1;
        if ( v4 )
        {
          if ( v16 > 0x1000 )
            v8 = sub_140032954(v15, v7, v13, v8, v9, &v19);
        }
        *&v14 = v15[0];
        DWORD2(v14) = v16;
        sub_140032ADC(&v14, a1);
      }
      v11 = v16 + v15[0];
      v4 = a3;
    }
    LOBYTE(v12) = v4;
    result = (loc_140032C04)(v12, v19, v10, v8, a1);
    goto LABEL_21;
  }
  result = EAC_Allocate_Memory(0x400ui64);
  v7 = result;
  if ( result )
  {
    result = EAC_Allocate_Memory(0x8000ui64);
    v10 = result;
    if ( result )
    {
      v8 = result + 2;
      v9 = result + (0x8000 - *(*a1 + 10i64));
      goto LABEL_7;
    }
  }
LABEL_21:
  if ( v10 )
    result = Get_ExFreePool(v10);
  if ( v7 )
    return Get_ExFreePool(v7);
  return result;
}
// 140032F00: variable 'v13' is possibly undefined
// 140032F7E: variable 'v12' is possibly undefined

//----- (0000000140032FB0) ----------------------------------------------------
void __fastcall sub_140032FB0(ULONG64 *a1)
{
  __int64 v2; // r14
  __int64 v3; // r15
  ULONG64 v4; // rbx
  unsigned __int16 i; // di
  __int64 v6; // r9
  __int64 v7; // r8
  int v8; // eax
  char v9; // dl
  char v10; // al
  __int128 v11; // [rsp+30h] [rbp-38h] BYREF
  __int64 v12; // [rsp+70h] [rbp+8h] BYREF

  if ( a1 )
  {
    v11 = 0i64;
    v2 = a1[1];
    if ( v2 )
    {
      EAC_IsUsermodeValidAddress(a1[1], 4096i64, 1);
      if ( GetModuleInfo(v2, 0x1000ui64, 0i64, &v12) )
      {
        v3 = v12;
        v4 = *(v12 + 20) + v12 + 24;
        for ( i = 0; i < *(v3 + 6) && *(a1 + 10) != 32; ++i )
        {
          EAC_IsUsermodeValidAddress(v4, 40i64, 1);
          v6 = *(v4 + 12);
          if ( v6 )
          {
            v7 = *(v4 + 8);
            if ( v7 )
            {
              if ( (*(v4 + 36) & 0x2000000) == 0 )
              {
                v8 = *v4;
                if ( (*v4 != 1818587694 || *(v4 + 4) != 25455) && v8 != 1936487470 )
                {
                  if ( v8 != 1920168494 || (v9 = 1, *(v4 + 4) != 99) )
                    v9 = 0;
                  BYTE12(v11) = v9;
                  v10 = v9;
                  if ( (*(*a1 + 26) & 0x60) != 0 )
                    v10 = 1;
                  BYTE12(v11) = v10;
                  *&v11 = v2 + v6;
                  DWORD2(v11) = v7;
                  EAC_IsUsermodeValidAddress(v2 + v6, v7, 1);
                  sub_140032ADC(&v11, a1);
                }
              }
            }
          }
          v4 += 40i64;
        }
      }
    }
  }
}

//----- (000000014003363C) ----------------------------------------------------
char __fastcall sub_14003363C(ULONG64 a1)
{
  char v2; // bl
  __int64 v4; // r14
  ULONG64 v5; // rdi
  unsigned __int16 i; // si
  __int64 v7; // [rsp+50h] [rbp+8h] BYREF

  v2 = 0;
  if ( !a1 )
    return 0;
  EAC_IsUsermodeValidAddress(a1, 4096i64, 1);
  if ( GetModuleInfo(a1, 0x1000ui64, 0i64, &v7) )
  {
    v4 = v7;
    v5 = *(v7 + 20) + v7 + 24;
    for ( i = 0; i < *(v4 + 6); ++i )
    {
      EAC_IsUsermodeValidAddress(v5, 40i64, 1);
      if ( *(v5 + 1) == 812674422 )
        return 1;
      v5 += 40i64;
    }
  }
  return v2;
}

//----- (000000014003398C) ----------------------------------------------------
char __fastcall sub_14003398C(__int64 a1)
{
  char v1; // si
  unsigned __int64 v3; // r8
  unsigned int v4; // edx
  unsigned __int64 v5; // r9
  char v6; // cl
  char v7; // bl
  int v8; // edx
  unsigned __int64 v9; // r8
  unsigned int v10; // edx
  unsigned __int64 v11; // r8
  unsigned __int64 i; // r8
  char v13; // cl
  unsigned int v14; // edx
  unsigned __int64 v15; // r8
  unsigned __int64 j; // r8
  char v17; // cl
  int v18; // edx
  unsigned __int64 v19; // r8
  int v21[5]; // [rsp+20h] [rbp-E0h]
  __int16 v22; // [rsp+34h] [rbp-CCh]
  int v23[5]; // [rsp+36h] [rbp-CAh]
  __int16 v24; // [rsp+4Ah] [rbp-B6h]
  int v25[7]; // [rsp+4Ch] [rbp-B4h]
  __int16 v26; // [rsp+68h] [rbp-98h]
  int v27[5]; // [rsp+6Ah] [rbp-96h]
  int v28[5]; // [rsp+7Eh] [rbp-82h]
  _BYTE v29[22]; // [rsp+92h] [rbp-6Eh] BYREF
  _BYTE v30[22]; // [rsp+A8h] [rbp-58h] BYREF
  _BYTE v31[30]; // [rsp+BEh] [rbp-42h] BYREF
  _BYTE v32[20]; // [rsp+DCh] [rbp-24h] BYREF
  __int128 v33[4]; // [rsp+F0h] [rbp-10h] BYREF

  v1 = 0;
  if ( a1 && *(a1 + 8) && *a1 && *(a1 + 2) )
  {
    v25[0] = -1845853434;
    v3 = 28i64;
    v25[1] = -1106086580;
    v25[2] = -1030666837;
    v4 = -1851096230;
    v25[3] = 2016355153;
    v5 = 0i64;
    v25[4] = -1368463752;
    v25[5] = 2076776171;
    v25[6] = 1032298283;
    v26 = 16;
    memset(v31, 0, sizeof(v31));
    do
    {
      *&v31[v5 * 4] = v25[v5] ^ v4;
      ++v5;
      v4 = __ROR4__(
             ((v4 ^ (v4 << 13)) >> 17) ^ v4 ^ (v4 << 13) ^ (32 * (((v4 ^ (v4 << 13)) >> 17) ^ v4 ^ (v4 << 13))),
             2);
    }
    while ( v5 < 7 );
    do
    {
      v6 = v4;
      v4 >>= 8;
      v31[v3] = *(v25 + v3) ^ v6;
      ++v3;
    }
    while ( v3 < 0x1E );
    v7 = 1;
    if ( !sub_14005D25C(a1, v31) )
    {
      v27[0] = 1693683595;
      v27[1] = -525660341;
      v27[2] = -1055565341;
      v8 = -1797153205;
      v27[3] = 1872478687;
      v9 = 0i64;
      v27[4] = -1242087509;
      memset(v33, 0, 20);
      do
      {
        v8 = ~(1103515245 * v8 + 12345);
        *(v33 + v9 * 4) = v27[v9] ^ v8;
        ++v9;
      }
      while ( v9 < 5 );
      v7 = 3;
      if ( !sub_14005D25C(a1, v33) )
      {
        v21[0] = -1948140462;
        v22 = 10453;
        v21[1] = -1386502142;
        v10 = -1951220722;
        v11 = 0i64;
        v21[2] = 1578077376;
        v21[3] = 2014163304;
        v21[4] = 917980055;
        memset(v30, 0, sizeof(v30));
        do
        {
          *&v30[v11 * 4] = v21[v11] ^ v10;
          ++v11;
          v10 = __ROR4__(
                  ((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13) ^ (32
                                                                   * (((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13))),
                  1);
        }
        while ( v11 < 5 );
        for ( i = 20i64; i < 0x16; ++i )
        {
          v13 = v10;
          v10 >>= 8;
          v30[i] = *(v21 + i) ^ v13;
        }
        v7 = 7;
        if ( !sub_14005D25C(a1, v30) )
        {
          v23[0] = 718788636;
          v24 = -26897;
          v23[1] = -360760066;
          v14 = 713349184;
          v15 = 0i64;
          v23[2] = -2036209637;
          v23[3] = -897466564;
          v23[4] = 2079503628;
          memset(v29, 0, sizeof(v29));
          do
          {
            *&v29[v15 * 4] = v23[v15] ^ v14;
            ++v15;
            v14 = -12345 - 1103515245 * v14;
          }
          while ( v15 < 5 );
          for ( j = 20i64; j < 0x16; ++j )
          {
            v17 = v14;
            v14 >>= 8;
            v29[j] = *(v23 + j) ^ v17;
          }
          v7 = 15;
          if ( !sub_14005D25C(a1, v29) )
          {
            v28[0] = -1188681644;
            v28[1] = 665060200;
            v28[2] = 787457325;
            v18 = 275292351;
            v28[3] = -237355104;
            v19 = 0i64;
            v28[4] = -1034767427;
            memset(v32, 0, sizeof(v32));
            do
            {
              v18 = __ROL4__(
                      ((v18 ^ (v18 << 13)) >> 17) ^ v18 ^ (v18 << 13) ^ (32
                                                                       * (((v18 ^ (v18 << 13)) >> 17) ^ v18 ^ (v18 << 13))),
                      4);
              *&v32[v19 * 4] = v28[v19] ^ v18;
              ++v19;
            }
            while ( v19 < 5 );
            v7 = 31;
            if ( !sub_14005D25C(a1, v32) )
              goto LABEL_26;
          }
        }
      }
    }
    v1 = 1;
    if ( (v7 & 0x10) != 0 )
    {
LABEL_26:
      v7 &= ~0x10u;
      memset(v32, 0, sizeof(v32));
    }
    if ( (v7 & 8) != 0 )
    {
      v7 &= ~8u;
      memset(v29, 0, sizeof(v29));
    }
    if ( (v7 & 4) != 0 )
      memset(v30, 0, sizeof(v30));
    if ( (v7 & 2) != 0 )
      memset(v33, 0, 0x14ui64);
    memset(v31, 0, sizeof(v31));
  }
  return v1;
}

//----- (0000000140033DF8) ----------------------------------------------------
char __fastcall sub_140033DF8(__int64 a1)
{
  char v1; // bl
  unsigned __int64 v3; // r8
  unsigned int v4; // edx
  unsigned __int64 v5; // r9
  int v6; // ecx
  char v7; // cl
  char v8; // si
  unsigned __int64 v9; // r8
  unsigned int v10; // edx
  unsigned __int64 v11; // r9
  char v12; // cl
  int v13; // edx
  unsigned __int64 v14; // r8
  int v16[7]; // [rsp+20h] [rbp-E0h]
  __int16 v17; // [rsp+3Ch] [rbp-C4h]
  int v18[10]; // [rsp+3Eh] [rbp-C2h]
  __int16 v19; // [rsp+66h] [rbp-9Ah]
  int v20[12]; // [rsp+68h] [rbp-98h]
  _BYTE v21[30]; // [rsp+98h] [rbp-68h] BYREF
  _BYTE v22[42]; // [rsp+B6h] [rbp-4Ah] BYREF
  __int128 v23[4]; // [rsp+E0h] [rbp-20h] BYREF

  v1 = 0;
  if ( a1 && *(a1 + 8) && *a1 && *(a1 + 2) )
  {
    v16[0] = -1535698197;
    v17 = -18565;
    v3 = 28i64;
    v16[1] = 1962977671;
    v4 = -1541399881;
    v5 = 0i64;
    v16[2] = -43872265;
    v16[3] = 272416983;
    v16[4] = -776352145;
    v16[5] = 1912668872;
    v16[6] = 1656007604;
    memset(v21, 0, sizeof(v21));
    do
    {
      v6 = v16[v5] ^ v4;
      v4 = __ROL4__(1140671485 * v4 + 12820163, 4);
      *&v21[v5 * 4] = v6;
      ++v5;
    }
    while ( v5 < 7 );
    do
    {
      v7 = v4;
      v4 >>= 8;
      v21[v3] = *(v16 + v3) ^ v7;
      ++v3;
    }
    while ( v3 < 0x1E );
    v8 = 1;
    if ( !sub_14005D25C(a1, v21) )
    {
      v18[0] = 1305990831;
      v19 = 25253;
      v9 = 40i64;
      v18[1] = -452625657;
      v10 = 1301731059;
      v18[2] = -1767500828;
      v18[3] = 755002858;
      v11 = 0i64;
      v18[4] = -1472384723;
      v18[5] = 1530583435;
      v18[6] = -857132793;
      v18[7] = -113236097;
      v18[8] = 1067002841;
      v18[9] = -1349610066;
      memset(v22, 0, sizeof(v22));
      do
      {
        *&v22[v11 * 4] = v18[v11] ^ v10;
        ++v11;
        v10 = __ROL4__(
                ((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13) ^ (32 * (((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13))),
                4);
      }
      while ( v11 < 10 );
      do
      {
        v12 = v10;
        v10 >>= 8;
        v22[v9] = *(v18 + v9) ^ v12;
        ++v9;
      }
      while ( v9 < 0x2A );
      v8 = 3;
      if ( !sub_14005D25C(a1, v22) )
      {
        v20[0] = 2076069858;
        v20[1] = 1017595009;
        memset(v23, 0, 48);
        v20[2] = 366369338;
        v13 = -2036315408;
        v20[3] = 1004839069;
        v14 = 0i64;
        v20[4] = 428520541;
        v20[5] = 335845559;
        v20[6] = 2078263014;
        v20[7] = -625548119;
        v20[8] = -1902741259;
        v20[9] = -1489430541;
        v20[10] = -760195564;
        v20[11] = 402782135;
        do
        {
          v13 = __ROR4__(1140671485 * v13 + 12820163, 3);
          *(v23 + v14 * 4) = v20[v14] ^ v13;
          ++v14;
        }
        while ( v14 < 12 );
        v8 = 7;
        if ( !sub_14005D25C(a1, v23) )
          goto LABEL_17;
      }
    }
    v1 = 1;
    if ( (v8 & 4) != 0 )
LABEL_17:
      memset(v23, 0, 0x30ui64);
    if ( (v8 & 2) != 0 )
      memset(v22, 0, sizeof(v22));
    memset(v21, 0, sizeof(v21));
  }
  return v1;
}

//----- (000000014003412C) ----------------------------------------------------
char __fastcall sub_14003412C(ULONG64 a1)
{
  char v2; // bl
  int v3; // eax
  __int64 v5; // [rsp+48h] [rbp+10h] BYREF

  v2 = 0;
  if ( a1 )
  {
    EAC_IsUsermodeValidAddress(a1, 4096i64, 1);
    if ( GetModuleInfo(a1, 0x1000ui64, 0i64, &v5) )
    {
      if ( *(v5 + 22) == 271 && *(v5 + 6) == 5 )
      {
        v3 = *(v5 + 8);
        if ( v3 == 1319282472 || v3 == 1346332652 || v3 == 1361860258 || v3 == 1441440577 )
          return 1;
      }
    }
  }
  return v2;
}

//----- (0000000140034890) ----------------------------------------------------
// from @Swiftik
bool __fastcall EAC_CheckForPhysicalHandle(__int64 a1)
{
  bool v2; // zf
  _DWORD *SystemInformation; // rsi
  unsigned __int64 v4; // rdi
  unsigned int v5; // edx
  unsigned __int64 v6; // r8
  int v7; // ecx
  char v8; // cl
  int ObjectHandle; // eax
  PVOID v10; // rdx
  unsigned __int64 idx; // r15
  PVOID v12; // rcx
  PVOID *ProcessId; // rdi
  char v14; // r14
  unsigned int v15; // r12d
  unsigned __int8 (__fastcall *v16)(_QWORD); // rax
  char v17; // di
  char v18; // r14
  unsigned __int16 *v19; // rdx
  char v20; // al
  int v22[11]; // [rsp+30h] [rbp-99h] BYREF
  __int16 v23; // [rsp+5Ch] [rbp-6Dh]
  __int128 v24[3]; // [rsp+60h] [rbp-69h] BYREF
  _UNICODE_STRING unicode_string; // [rsp+90h] [rbp-39h] BYREF
  _UNICODE_STRING v26; // [rsp+A0h] [rbp-29h] BYREF
  UNICODE_STRING v27; // [rsp+B0h] [rbp-19h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+C0h] [rbp-9h] BYREF
  void *SectionHandle; // [rsp+130h] [rbp+67h] BYREF
  int *v30; // [rsp+138h] [rbp+6Fh]
  __int128 *v31; // [rsp+140h] [rbp+77h]

  if ( !a1 )
    return 0;

  v2 = qword_1400832C0 == 0;
  *a1 = 0i64;
  *(a1 + 0x10) = 0i64;
  if ( v2 || _InterlockedCompareExchange(dword_14008598C, 1, 0) )
    return 0;

  SystemInformation = EAC_NtQuerySystemInformation(0x10u, 0x80000u, 0x1000000u, 0i64);
  if ( !SystemInformation )
    goto LABEL_41;

  v22[0] = -1065725191;
  v23 = -6121;
  v4 = 44i64;
  v22[1] = 1412156615;
  v5 = -1069657435;
  v6 = 0i64;
  v22[2] = 98602512;
  v22[3] = 1318375812;
  v22[4] = -1072097224;
  v22[5] = 1836746413;
  v22[6] = 1259120119;
  v22[7] = -1907231151;
  v22[8] = -1844563179;
  v22[9] = -1788111433;
  v22[10] = -958705266;

  memset(v24, 0, 46);
  v30 = v22;
  v31 = v24;

  do
  {
    v7 = v30[v6] ^ v5;
    v5 = __ROL4__(29857 * v5 + 10559237, 4);
    *(v31 + v6 * 4) = v7;
    ++v6;
  }
  while ( v6 < 11 );
  v30 = v22;
  v31 = v24;

  do
  {
    v8 = v5;
    v5 >>= 8;
    *(v31 + v4) = *(v30 + v4) ^ v8;
    ++v4;
  }
  while ( v4 < 0x2E );

  Get_Unicode_string_Inline(&v26, v24);
  ObjectAttributes.Length = 48;
  ObjectAttributes.ObjectName = &v26;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  *&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwOpenSection(&SectionHandle, 1u, &ObjectAttributes) >= 0 )
  {
    ObjectHandle = Get_ObReferenceObjectByHandle(SectionHandle, 1u, 0i64, 0, &qword_140085CB0, 0i64);
    v10 = qword_140085CB0;
    if ( ObjectHandle < 0 )
      v10 = 0i64;

    qword_140085CB0 = v10;
    ZwClose(SectionHandle);
  }

  idx = 0i64;
  memset(v24, 0, 0x2Eui64);
  if ( !*SystemInformation )
    goto LABEL_37;

  v12 = qword_140085CB0;
  ProcessId = (SystemInformation + 2);
  v14 = 0;
  while ( 1 )
  {
    if ( ProcessId[1] != v12 || !v12 || *ProcessId == 4 )
      goto LABEL_21;

    v15 = *(ProcessId + 3);
    v16 = (loc_14005B768)(qword_140086028, &qword_140086028, 0i64);
    if ( !v16 || !v16(v15) )
      break;

    v12 = qword_140085CB0;
LABEL_21:

    ++idx;
    ProcessId += 3;
    if ( idx >= *SystemInformation )
      goto LABEL_38;
  }
  v17 = sub_140053130(*ProcessId, &unicode_string);
  if ( v17 )
    v14 = EAC_Copy_Unicode_from_Unicode(&unicode_string, &v27);
  v18 = -v14;
  v19 = (&v27 & -(v18 != 0));
  if ( !*(a1 + 4) )
  {
    *a1 = 1;
    *(a1 + 4) = 13;
    if ( v19 )
    {
      if ( *((&v27 & -(v18 != 0)) + 8) && *v19 && *((&v27 & -(v18 != 0)) + 2) && !*(a1 + 8) )
      {
        if ( a1 == -16 )
          v20 = 0;
        else
          v20 = EAC_Allocate_Unicode_string((a1 + 16), v19, *v19);
        *(a1 + 8) = v20;
      }
    }
  }
  if ( v17 )
    EAC_Free_UnicodeString(&unicode_string);
LABEL_37:
  v12 = qword_140085CB0;
LABEL_38:
  if ( v12 )
  {
    ObfDereferenceObject(v12);
    qword_140085CB0 = 0i64;
  }

  Get_ExFreePool(SystemInformation);
LABEL_41:
  _InterlockedExchange(dword_14008598C, 0);
  return *(a1 + 4) != 0;
}
// 1400832C0: using guessed type __int64 qword_1400832C0;
// 14008598C: using guessed type signed __int32 dword_14008598C[37];
// 140086028: using guessed type __int64 qword_140086028;

//----- (0000000140034E4C) ----------------------------------------------------
// from @Swiftik
bool EAC_CheckForCodeIntegirtySections()
{
  int Flag; // ebx
  unsigned int *SystemInformation; // rax MAPDST
  unsigned int v3; // r9d
  unsigned int Index; // r8d
  _DWORD *v5; // rcx
  int v6; // eax

  Flag = 0;
  SystemInformation = EAC_NtQuerySystemInformation(0x16u, 0x10000u, 0x100000u, 0i64);
  if ( SystemInformation )
  {
    v3 = *SystemInformation;
    Index = 0;
    if ( *SystemInformation )
    {
      v5 = SystemInformation + 3;
      do
      {
        if ( Flag == 3 )
          break;

        v6 = *(v5 - 1);
        if ( v6 == 0x72634943 )
        {
          if ( *v5 > v5[1] )
            Flag |= 1u;
        }
        else if ( v6 == 0x63734943 && *v5 > v5[1] )
        {
          Flag |= 2u;
        }
        ++Index;
        v5 += 10;
      }
      while ( Index < v3 );
    }
    Get_ExFreePool(SystemInformation);
  }
  else
  {
    Flag = 3;
  }
  return Flag == 3;
}

//----- (0000000140035ED4) ----------------------------------------------------
__int64 sub_140035ED4()
{
  __int64 result; // rax
  unsigned __int64 v1; // rax
  unsigned __int8 *v2; // rbx
  unsigned __int64 v3; // rdi
  int v4[6]; // [rsp+20h] [rbp-40h] BYREF
  char v5[33]; // [rsp+38h] [rbp-28h] BYREF
  int v6; // [rsp+59h] [rbp-7h]

  result = dword_140083054;
  if ( dword_140083054 == -1 )
  {
    v4[0] = 0x5BB8CB25;
    v4[1] = 0x26798B71;
    v4[2] = 0xE41F75EB;
    v4[3] = 0xE17689F2;
    v4[4] = 0x548E003C;
    v1 = (loc_14003CB4C)(v4);
    v2 = v1;
    if ( v1 )
    {
      v3 = v1 + 0x18;
      if ( v1 < v1 + 0x18 )
      {
        do
        {
          sub_1400210C8(v2, v5);

          if ( (v6 & 0x1000) != 0 )
            break;

          if ( *v2 == 0xC3 )
          {
            result = *(v2 - 1);
            goto LABEL_8;
          }
          v2 += v5[0];
        }
        while ( v2 < v3 );
      }
    }
    result = dword_140083054;
LABEL_8:
    if ( result == -1 )
      result = 0i64;

    dword_140083054 = result;
  }
  return result;
}
// 140083054: using guessed type int dword_140083054;
// 140035ED4: using guessed type char var_28[33];

//----- (0000000140035F88) ----------------------------------------------------
__int64 sub_140035F88()
{
  __int64 result; // rax
  __int64 v1; // rcx
  int v2[8]; // [rsp+20h] [rbp-20h] BYREF

  result = dword_140083050;
  if ( dword_140083050 == -1 )
  {
    v2[0] = -1957534572;
    v2[1] = -1046621055;
    v2[2] = -1495824732;
    v2[3] = 1742819452;
    v2[4] = -1498110839;
    v1 = (loc_14003CB4C)(v2);
    result = 0i64;
    if ( v1 && *v1 == 72 && *(v1 + 1) == 0x818B )
      result = *(v1 + 3);
    dword_140083050 = result;
  }
  return result;
}
// 140083050: using guessed type int dword_140083050;

//----- (0000000140035FF4) ----------------------------------------------------
__int64 sub_140035FF4()
{
  __int64 result; // rax
  __int64 v1; // rcx
  int v2[8]; // [rsp+20h] [rbp-20h] BYREF

  result = dword_14008304C;
  if ( dword_14008304C == -1 )
  {
    v2[0] = 163425800;
    v2[1] = -1163634381;
    v2[2] = 1055290716;
    v2[3] = 1101368593;
    v2[4] = 637690508;
    v1 = (loc_14003CB4C)(v2);
    result = 0i64;
    if ( v1 && *v1 == 72 && *(v1 + 1) == 0x818B )
      result = *(v1 + 3);
    dword_14008304C = result;
  }
  return result;
}
// 14008304C: using guessed type int dword_14008304C;

//----- (0000000140036060) ----------------------------------------------------
__int64 sub_140036060()
{
  unsigned int v0; // eax
  unsigned __int8 *v1; // rax
  unsigned __int8 *v2; // rdi
  unsigned __int8 *i; // rbx
  int v4; // edx
  int v6[6]; // [rsp+20h] [rbp-40h] BYREF
  char v7[11]; // [rsp+38h] [rbp-28h] BYREF
  char v8; // [rsp+43h] [rbp-1Dh]
  char v9; // [rsp+47h] [rbp-19h]
  char v10; // [rsp+4Dh] [rbp-13h]
  unsigned int v11; // [rsp+55h] [rbp-Bh]
  int v12; // [rsp+59h] [rbp-7h]

  if ( sub_14004D4E8(&qword_1400864B0) == 0x103 )
  {
    if ( KUSER_SHARED_DATA.NtMajorVersion == 6 && KUSER_SHARED_DATA.NtMinorVersion == 1 )
    {
      v0 = 0x164;
      dword_1400864B8 = 0x164;
    }
    else
    {
      v6[0] = -1736486417;
      v6[1] = 1724254275;
      v6[2] = 1127193747;
      v6[3] = 168604527;
      v6[4] = 873553684;
      v1 = (loc_14003CB4C)(v6);
      if ( v1 )
      {
        v2 = v1 + 306;
        for ( i = &v1[sub_1400210C8(v1, v7)];
              i < v2 && (v12 & 0x1000) == 0 && ((v8 + 62) & 0xF6) != 0;
              i += sub_1400210C8(i, v7) )
        {
          if ( (v12 & 1) != 0 && (v12 & 0x100) != 0 && v8 == -118 && !v9 && v11 < 0x300 )
          {
            dword_1400864B8 = v11;
            i += sub_1400210C8(i, v7);
            if ( (v12 & 0x1000) == 0 && (v12 & 4) != 0 && v8 == 60 && v10 == 5 )
              break;
            dword_1400864B8 = 0;
          }
        }
      }
      v0 = dword_1400864B8;
    }
    if ( v0 )
    {
      v4 = dword_1400864B8;
      if ( *(KeGetCurrentThread() + v0) != 2 )
        v4 = 0;
      dword_1400864B8 = v4;
    }
    _InterlockedExchange64(&qword_1400864B0, 2i64);
  }
  return dword_1400864B8;
}
// 1400864B0: using guessed type __int64 qword_1400864B0;
// 1400864B8: using guessed type int dword_1400864B8;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (00000001400361E8) ----------------------------------------------------
__int64 Get_IoGetInitialStack()
{
  struct _KTHREAD *CurrentThread; // rbx MAPDST
  __int64 (*g_IoGetInitialStack)(void); // rax
  __int64 InitialStack; // rax
  int v5[8]; // [rsp+20h] [rbp-20h] BYREF

  CurrentThread = KeGetCurrentThread();
  if ( sub_14004D4E8(&qword_1400864A0) == 0x103 )
  {
    g_IoGetInitialStack = qword_1400864A8;
    if ( qword_1400864A8
      || (v5[0] = 0xB561C7BB,
          v5[1] = 0xA18E6AF7,
          v5[2] = 0x79FC5803,
          v5[3] = 0xE5FCFF30,
          v5[4] = 0xDCD73801,
          g_IoGetInitialStack = (loc_14003CB4C)(v5),
          (qword_1400864A8 = g_IoGetInitialStack) != 0) )
    {
      InitialStack = g_IoGetInitialStack();     // IoGetInitialStack
      if ( CurrentThread < (CurrentThread + 0x2F8) )
      {
        while ( *CurrentThread != InitialStack )
        {
          CurrentThread = (CurrentThread + 8);
          if ( CurrentThread >= (CurrentThread + 0x2F8) )
            goto LABEL_9;
        }
        dword_140086494 = CurrentThread - CurrentThread;
      }
    }
LABEL_9:
    _InterlockedExchange64(&qword_1400864A0, 2i64);
  }
  return dword_140086494;
}
// 140086494: using guessed type int dword_140086494;
// 1400864A0: using guessed type __int64 qword_1400864A0;
// 1400864A8: using guessed type __int64 qword_1400864A8;

//----- (000000014003629C) ----------------------------------------------------
__int64 Get_PsGetCurrentThreadStackLimit()
{
  struct _KTHREAD *CurrentThread; // rbx
  __int64 (*g_PsGetCurrentThreadStackLimit)(void); // rax
  __int64 v2; // rax
  struct _KTHREAD *v3; // rcx
  int v5[8]; // [rsp+20h] [rbp-20h] BYREF

  CurrentThread = KeGetCurrentThread();
  if ( sub_14004D4E8(&qword_140086498) == 0x103 )
  {
    g_PsGetCurrentThreadStackLimit = qword_140086488;
    if ( qword_140086488
      || (v5[0] = 0xBCBD5655,
          v5[1] = 0x331D91A0,
          v5[2] = 0x47A78762,
          v5[3] = 0x62205FCE,
          v5[4] = 0x8EBE40B,
          g_PsGetCurrentThreadStackLimit = (loc_14003CB4C)(v5),
          (qword_140086488 = g_PsGetCurrentThreadStackLimit) != 0) )
    {
      v2 = g_PsGetCurrentThreadStackLimit();    // PsGetCurrentThreadStackLimit
      v3 = CurrentThread;
      if ( CurrentThread < (CurrentThread + 0x2F8) )
      {
        while ( *v3 != v2 )
        {
          v3 = (v3 + 8);
          if ( v3 >= (CurrentThread + 0x2F8) )
            goto LABEL_9;
        }
        dword_140086490 = v3 - CurrentThread;
      }
    }
LABEL_9:
    _InterlockedExchange64(&qword_140086498, 2i64);
  }
  return dword_140086490;
}
// 140086488: using guessed type __int64 qword_140086488;
// 140086490: using guessed type int dword_140086490;
// 140086498: using guessed type __int64 qword_140086498;

//----- (0000000140036350) ----------------------------------------------------
__int64 Get_PsGetCurrentThreadStackBase()
{
  struct _KTHREAD *CurrentThread; // rbx
  __int64 (*g_PsGetCurrentThreadStackBase)(void); // rax
  __int64 ThreadStackBase; // rax
  struct _KTHREAD *OldCurrentThread; // rcx
  int v5[8]; // [rsp+20h] [rbp-20h] BYREF

  CurrentThread = KeGetCurrentThread();
  if ( sub_14004D4E8(&qword_140086478) == 0x103 )
  {
    g_PsGetCurrentThreadStackBase = qword_140086480;
    if ( qword_140086480
      || (v5[0] = 0x450DAB76,
          v5[1] = 0x902A3DD5,
          v5[2] = 0x77D1A5FD,
          v5[3] = 0x1AFA63E8,
          v5[4] = 0x2D210D01,
          g_PsGetCurrentThreadStackBase = (loc_14003CB4C)(v5),
          (qword_140086480 = g_PsGetCurrentThreadStackBase) != 0) )
    {
      ThreadStackBase = g_PsGetCurrentThreadStackBase();// PsGetCurrentThreadStackBase
      OldCurrentThread = CurrentThread;
      if ( CurrentThread < (CurrentThread + 0x2F8) )// 0x2F8 = ThreadListEntry
      {
        while ( *OldCurrentThread != ThreadStackBase )
        {
          OldCurrentThread = (OldCurrentThread + 8);
          if ( OldCurrentThread >= (CurrentThread + 0x2F8) )// 0x2F8 = ThreadListEntry
            goto LABEL_9;
        }
        dword_140086468 = OldCurrentThread - CurrentThread;
      }
    }
LABEL_9:
    _InterlockedExchange64(&qword_140086478, 2i64);
  }
  return dword_140086468;
}
// 140086468: using guessed type int dword_140086468;
// 140086478: using guessed type __int64 qword_140086478;
// 140086480: using guessed type __int64 qword_140086480;

//----- (0000000140036404) ----------------------------------------------------
__int64 Iterate_System_Threads()
{
  struct _KTHREAD *CurrentThread; // rbx
  int InitialStack; // ebp
  unsigned int CurrentThreadStackBase; // eax
  unsigned __int64 ThreadStackLimit; // rdi
  unsigned __int64 ThreadStackBase; // rsi
  unsigned int CurrentThreadStackLimit; // eax
  struct _KTHREAD *OldCurrentThread; // rax
  bool i; // cf
  union _LARGE_INTEGER Interval; // [rsp+40h] [rbp+8h] BYREF
  union _LARGE_INTEGER v10; // [rsp+48h] [rbp+10h] BYREF

  Interval.QuadPart = 0i64;
  CurrentThread = KeGetCurrentThread();
  InitialStack = Get_IoGetInitialStack();
  CurrentThreadStackBase = Get_PsGetCurrentThreadStackBase();
  if ( CurrentThread )
  {
    if ( CurrentThreadStackBase )
      ThreadStackBase = *(CurrentThread + CurrentThreadStackBase);
    else
      ThreadStackBase = 0i64;
    CurrentThreadStackLimit = Get_PsGetCurrentThreadStackLimit();
    if ( CurrentThreadStackLimit )
      ThreadStackLimit = *(CurrentThread + CurrentThreadStackLimit);
    else
      ThreadStackLimit = 0i64;
  }
  else
  {
    Get_PsGetCurrentThreadStackLimit();
    ThreadStackLimit = 0i64;
    ThreadStackBase = 0i64;
  }
  if ( KeGetCurrentIrql() > 1u )
    return 0i64;
  if ( sub_14004D4E8(&qword_140086470) == 0x103 )
  {
    if ( InitialStack && ThreadStackLimit && ThreadStackBase )
    {
      if ( KeDelayExecutionThread(0, 0, &Interval) )
      {
        v10.QuadPart = -10000i64;
        KeDelayExecutionThread(0, 0, &v10);
      }
      OldCurrentThread = CurrentThread;
      for ( i = CurrentThread < (CurrentThread + 0x2F8); i; i = OldCurrentThread < (CurrentThread + 0x2F8) )// 0x2f8 = ThreadListEntry
      {
        if ( OldCurrentThread - CurrentThread != InitialStack
          && *OldCurrentThread < ThreadStackBase
          && *OldCurrentThread > ThreadStackLimit )
        {
          dword_14008645C = OldCurrentThread - CurrentThread;
          break;
        }
        OldCurrentThread = (OldCurrentThread + 8);
      }
    }
    _InterlockedExchange64(&qword_140086470, 2i64);
  }
  return dword_14008645C;
}
// 14008645C: using guessed type int dword_14008645C;
// 140086470: using guessed type __int64 qword_140086470;

//----- (000000014003650C) ----------------------------------------------------
__int64 sub_14003650C()
{
  unsigned __int8 *v0; // rax
  unsigned __int8 *v1; // rdi
  unsigned __int8 *i; // rbx
  int v4[6]; // [rsp+20h] [rbp-40h] BYREF
  char v5[33]; // [rsp+38h] [rbp-28h] BYREF
  int v6; // [rsp+59h] [rbp-7h]

  if ( sub_14004D4E8(&qword_140086460) == 0x103 )
  {
    v4[0] = 0x23AB35FD;
    v4[1] = 0x5BA72F51;
    v4[2] = 0xB48C45B2;
    v4[3] = 0xA4EF6532;
    v4[4] = 0x4EA4EFF0;
    v0 = (loc_14003CB4C)(v4);
    if ( v0 )
    {
      v1 = v0 + 241;
      for ( i = &v0[sub_1400210C8(v0, v5)]; i < v1 && (v6 & 0x1000) == 0; i += sub_1400210C8(i, v5) )
      {
        if ( (v6 & 0x40000000) != 0
          && (v6 & 0x10000000) != 0
          && (v6 & 1) != 0
          && (v6 & 0x40) != 0
          && (v6 & 4) != 0
          && !v5[21]
          && v5[7]
          && v5[11] == 0xF
          && v5[12] == 0xBA )
        {
          dword_140086458 = v5[0x1D];
          break;
        }
      }
    }
    _InterlockedExchange64(&qword_140086460, 2i64);
  }
  return dword_140086458;
}
// 140086458: using guessed type int dword_140086458;
// 140086460: using guessed type __int64 qword_140086460;

//----- (0000000140036600) ----------------------------------------------------
__int64 sub_140036600()
{
  __int64 result; // rax
  __int64 v1; // rax
  __int64 v2; // rdi
  unsigned __int64 i; // rbx
  int v4[6]; // [rsp+28h] [rbp-50h] BYREF
  char v5[33]; // [rsp+40h] [rbp-38h] BYREF
  int v6; // [rsp+61h] [rbp-17h]

  result = dword_140083048;
  if ( dword_140083048 == -1 )
  {
    v4[0] = 1504398807;
    v4[1] = 608353598;
    v4[2] = 343396823;
    v4[3] = 1057408629;
    v4[4] = -1381116326;
    v1 = (loc_14003CB4C)(v4);
    v2 = v1;
    if ( v1 )
    {
      for ( i = v1; i < v2 + 24; i += v5[0] )
      {
        sub_1400210C8(i, v5);
        if ( (v6 & 0x1000) != 0 )
          break;
        if ( ((*i + 32629) & 0xFEFF) == 0 )
        {
          dword_140083048 = *(i + 2);
          break;
        }
        if ( *i == 0xC2 || *i == 0xC3 )
          break;
      }
    }
    result = dword_140083048;
    if ( dword_140083048 == -1 )
      result = 0i64;
    dword_140083048 = result;
  }
  return result;
}
// 140083048: using guessed type int dword_140083048;
// 140036600: using guessed type char var_38[33];

//----- (00000001400366DC) ----------------------------------------------------
char __fastcall sub_1400366DC(__int64 a1)
{
  char ret; // bl
  unsigned int v3; // eax

  ret = 0;
  if ( a1 )
  {
    v3 = sub_140036600();
    if ( v3 )
    {
      ret = 1;
      *(v3 + a1) |= 4u;
    }
  }
  return ret;
}

//----- (0000000140036710) ----------------------------------------------------
__int64 __fastcall EAC_Get_Thread_Info(__int64 Object, _QWORD *ThreadInfo)
{
  int Status; // ebx
  unsigned __int64 Handle; // [rsp+50h] [rbp+8h] BYREF

  Handle = 0i64;
  if ( Object && ThreadInfo )
  {
    *ThreadInfo = 0i64;
    Status = Get_ObOpenObjectByPointer(Object, 0x200u, Object, 0x40u, PsThreadType, 0, &Handle);
    if ( Status >= 0 )
    {
      Status = Get_NtQueryInformationThread(Handle, 9u, ThreadInfo, 8u);
      Get_NtClose(Handle);
    }
  }
  else
  {
    return ((Object != 0) - 0x3FFFFF11);
  }
  return Status;
}

//----- (00000001400367A8) ----------------------------------------------------
__int64 __fastcall EAC_NtQueryInformationThread(__int64 ThreadId, _QWORD *ThreadInfo)
{
  int Status; // ebx
  __int64 AccessState; // r8
  PVOID Object; // [rsp+50h] [rbp+8h] MAPDST BYREF
  unsigned __int64 Handle; // [rsp+60h] [rbp+18h] BYREF

  Object = 0i64;
  if ( ThreadId && ThreadInfo )
  {
    Status = Get_PsLookupThreadByThreadId(ThreadId, &Object);
    if ( Status >= 0 )
    {
      Handle = 0i64;
      if ( Object && ThreadInfo )
      {
        *ThreadInfo = 0i64;
        Status = Get_ObOpenObjectByPointer(Object, 0x200u, AccessState, 0x40u, PsThreadType, 0, &Handle);
        if ( Status >= 0 )
        {
          Status = Get_NtQueryInformationThread(Handle, 9u, ThreadInfo, 8u);
          Get_NtClose(Handle);
        }
      }
      else
      {
        Status = (Object != 0i64) - 0x3FFFFF11;
      }
      ObfDereferenceObject(Object);
    }
  }
  else
  {
    return ((ThreadId != 0) - 0x3FFFFF11);
  }
  return Status;
}
// 140036823: variable 'AccessState' is possibly undefined

//----- (0000000140036940) ----------------------------------------------------
__int64 __fastcall sub_140036940(__int64 a1)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = sub_140035F88();
  result = 0i64;
  if ( a1 )
  {
    if ( v2 )
      return *(v2 + a1);
  }
  return result;
}

//----- (0000000140036968) ----------------------------------------------------
__int64 __fastcall sub_140036968(__int64 a1)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = sub_140035FF4();
  result = 0i64;
  if ( a1 )
  {
    if ( v2 )
      return *(v2 + a1);
  }
  return result;
}

//----- (0000000140036990) ----------------------------------------------------
char __fastcall sub_140036990(__int64 CurrentThread, char a2)
{
  unsigned int v4; // eax

  v4 = sub_140035ED4();

  if ( !CurrentThread || !v4 )
    return 0;

  *(v4 + CurrentThread) = a2;

  return 1;
}

//----- (00000001400369C8) ----------------------------------------------------
void __fastcall sub_1400369C8(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rbx
  unsigned int v4; // eax
  KSPIN_LOCK *v5; // rcx
  void (__fastcall *v6)(_QWORD, __int64); // rax
  int v7[8]; // [rsp+20h] [rbp-20h] BYREF

  v3 = a2;
  if ( KUSER_SHARED_DATA.NtMajorVersion < 6
    || KUSER_SHARED_DATA.NtMajorVersion == 6 && !KUSER_SHARED_DATA.NtMinorVersion )
  {
    v6 = qword_140083588;
    if ( qword_140083588
      || (v7[0] = 185684293,
          v7[1] = 384506604,
          v7[2] = -250882617,
          v7[3] = 540373460,
          v7[4] = 1333217803,
          v6 = (loc_14003CB4C)(v7),
          (qword_140083588 = v6) != 0) )
    {
      LOBYTE(a2) = v3;
      v6(0i64, a2);
    }
  }
  else
  {
    v4 = sub_14003650C();
    if ( a1 )
    {
      v5 = ((a1 + v4) & -(v4 != 0));
      if ( v5 )
      {
        KeReleaseSpinLockFromDpcLevel(v5);
        __writecr8(v3);
      }
    }
  }
}
// 140036A6C: variable 'a2' is possibly undefined
// 14003650C: using guessed type __int64 sub_14003650C(void);
// 140083588: using guessed type __int64 qword_140083588;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140036A80) ----------------------------------------------------
unsigned __int64 __fastcall EAC_Get_System_Thread_Info(PETHREAD Thread, __int64 a2, __m128 *Memory)
{
  unsigned __int64 Lenght; // rbx
  __int64 v6; // r14
  __int64 CurrentThread; // r15
  unsigned int CurrentThreadStackBase; // eax
  unsigned __int64 ThreadStackBase; // rsi
  unsigned int CurrentThreadStackLimit; // eax
  unsigned __int64 ThreadStackLimit; // rbp
  __int64 v13; // r12
  unsigned int v14; // eax
  KSPIN_LOCK *SpinLock; // rcx
  unsigned __int8 CurrentIrql; // r14
  __int64 v17; // rdx
  void *BaseAddress; // rcx
  char *Base_Address; // rdx
  unsigned __int64 Lenght_; // rsi
  __int64 v21; // [rsp+58h] [rbp+10h] BYREF

  v21 = a2;
  Lenght = 0i64;
  v6 = sub_140036060();
  CurrentThread = Iterate_System_Threads();
  CurrentThreadStackBase = Get_PsGetCurrentThreadStackBase();
  if ( !Thread )
  {
    Get_PsGetCurrentThreadStackLimit();
    return 0i64;
  }
  if ( CurrentThreadStackBase )
    ThreadStackBase = *(Thread + CurrentThreadStackBase);
  else
    ThreadStackBase = 0i64;
  CurrentThreadStackLimit = Get_PsGetCurrentThreadStackLimit();
  if ( CurrentThreadStackLimit )
    ThreadStackLimit = *(Thread + CurrentThreadStackLimit);
  else
    ThreadStackLimit = 0i64;
  if ( !Get_PsIsSystemThread(Thread)
    || !Memory
    || !v6
    || !CurrentThread
    || !ThreadStackBase
    || !ThreadStackLimit
    || KeGetCurrentIrql() > 1u
    || Thread == KeGetCurrentThread() )
  {
    return 0i64;
  }

  v13 = v6;
  EAC_memset(Memory, 0, 0x2000ui64);

  if ( KUSER_SHARED_DATA.NtMajorVersion < 6
    || KUSER_SHARED_DATA.NtMajorVersion == 6 && !KUSER_SHARED_DATA.NtMinorVersion )
  {
    if ( sub_14000F914(&v21) )
    {
      CurrentIrql = v21;
LABEL_25:
      if ( !PsIsThreadTerminating(Thread) && *(Thread + v13) == 5 )
      {
        BaseAddress = *(Thread + CurrentThread);
        if ( BaseAddress > ThreadStackLimit && BaseAddress < ThreadStackBase && *&MmGetPhysicalAddress(BaseAddress) )
        {
          Base_Address = *(Thread + CurrentThread);
          Lenght_ = ThreadStackBase - Base_Address;
          Lenght = 0x2000i64;

          if ( Lenght_ < 0x2000 )
            Lenght = Lenght_;

          EAC_memcpy(Memory, Base_Address, Lenght);
        }
      }
      LOBYTE(v17) = CurrentIrql;
      sub_1400369C8(Thread, v17);
    }
  }
  else
  {
    v14 = sub_14003650C();
    SpinLock = ((Thread + v14) & -(v14 != 0));
    if ( SpinLock )
    {
      CurrentIrql = KeGetCurrentIrql();
      __writecr8(0xCui64);
      KeAcquireSpinLockAtDpcLevel(SpinLock);
      goto LABEL_25;
    }
  }
  return Lenght;
}
// 140036C08: variable 'v17' is possibly undefined
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140037E08) ----------------------------------------------------
bool __fastcall sub_140037E08(_OWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  bool v4; // bl
  _OWORD *Memory; // rax
  _DWORD *v10; // rdi
  __int64 v11; // rcx
  __int128 v12; // xmm1
  int v13; // ecx
  int v14; // eax

  v4 = 0;
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  Memory = EAC_Allocate_Memory(0x200ui64);
  v10 = Memory;
  if ( Memory )
  {
    v11 = 4i64;
    do
    {
      *Memory = *a1;
      Memory[1] = a1[1];
      Memory[2] = a1[2];
      Memory[3] = a1[3];
      Memory[4] = a1[4];
      Memory[5] = a1[5];
      Memory[6] = a1[6];
      Memory += 8;
      v12 = a1[7];
      a1 += 8;
      *(Memory - 1) = v12;
      --v11;
    }
    while ( v11 );
    if ( sub_14003E60C(v10, 4u, 0x80u, sub_140037E00) )
    {
      v13 = v10[63];
      *a2 = v10[31];
      v4 = v13 != 0;
      v14 = v10[95];
      *a3 = v13;
      *a4 = v14;
    }
    Get_ExFreePool(v10);
  }
  return v4;
}
// 140037E00: using guessed type __int64 __fastcall sub_140037E00();

//----- (0000000140037EF4) ----------------------------------------------------
unsigned __int8 __fastcall sub_140037EF4(unsigned __int8 *a1, unsigned int a2, __int64 a3)
{
  unsigned __int8 v3; // si
  unsigned int v6; // edi
  unsigned __int8 *v7; // rbp
  __int64 v8; // r10
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r11
  __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rdx

  v3 = 0;
  v6 = 0;
  if ( a2 )
  {
    v7 = a1;
    do
    {
      if ( v6 >= 4 )
      {
        v8 = *v7;
        v9 = a1[v6 - 1];
        v10 = a1[v6 - 2];
        v11 = a1[v6 - 3];
        v12 = a1[v6 - 4];
        v3 = byte_140073E90[v3 ^ byte_140073E90[v9 ^ byte_140073E90[v8 ^ 1]]];
        v13 = byte_140073E90[v10 ^ byte_140073E90[v9 ^ byte_140073E90[v8 ^ 0x31]]];
        ++*(a3 + 4 * v13);
        v14 = byte_140073E90[v11 ^ byte_140073E90[v9 ^ byte_140073E90[v8 ^ 0xCi64]]];
        ++*(a3 + 4 * v14);
        v15 = byte_140073E90[v11 ^ byte_140073E90[v10 ^ byte_140073E90[v8 ^ 0xB2i64]]];
        ++*(a3 + 4 * v15);
        v16 = byte_140073E90[v12 ^ byte_140073E90[v10 ^ byte_140073E90[v8 ^ 0xA6i64]]];
        ++*(a3 + 4 * v16);
        v17 = byte_140073E90[v12 ^ byte_140073E90[v9 ^ byte_140073E90[v8 ^ 0x54i64]]];
        v18 = v12 ^ byte_140073E90[v11 ^ byte_140073E90[v8 ^ 0xE6]];
        ++*(a3 + 4 * v17);
        ++*(a3 + 4i64 * byte_140073E90[v18]);
      }
      ++v6;
      ++v7;
    }
    while ( v6 < a2 );
  }
  return v3;
}
// 140073E90: using guessed type unsigned __int8 byte_140073E90[256];

//----- (0000000140038070) ----------------------------------------------------
char __fastcall sub_140038070(unsigned __int8 *a1, unsigned int a2, __int64 a3)
{
  unsigned int v3; // ebx
  _BYTE *Memory; // rdi
  __m128 *v8; // rax
  __m128 *v9; // r14
  unsigned __int8 v10; // r15
  unsigned __int8 v11; // dl
  unsigned __int8 v12; // al
  unsigned __int64 v13; // r8
  unsigned int v14; // r9d
  unsigned int *v15; // r10
  unsigned __int64 v16; // rax
  unsigned int v17; // eax
  char v18; // r8
  char v19; // al
  __int64 v20; // rdx
  _BYTE *v21; // rsi
  __int64 v22; // rax
  unsigned int v24[14]; // [rsp+20h] [rbp-38h] BYREF
  unsigned int v25; // [rsp+60h] [rbp+8h] BYREF
  unsigned int v26; // [rsp+78h] [rbp+20h] BYREF

  v3 = 0;
  if ( !a1 || a2 < 0x100 || !a3 || a2 > 0xFBC96A80 )
    return 0;
  *a3 = 0i64;
  *(a3 + 16) = 0i64;
  *(a3 + 32) = 0;
  *(a3 + 34) = 0;
  Memory = EAC_Allocate_Memory(0x23ui64);
  if ( Memory )
  {
    *Memory = 0i64;
    *(Memory + 1) = 0i64;
    *(Memory + 16) = 0;
    Memory[34] = 0;
    v8 = EAC_Allocate_Memory(0x400ui64);
    v9 = v8;
    if ( v8 )
    {
      EAC_memset(v8, 0, 0x400ui64);
      v10 = sub_140037EF4(a1, a2, v9);
      if ( sub_140037E08(v9, &v25, &v26, v24) )
      {
        *Memory = v10;
        v11 = 0;
        v12 = 1;
        while ( a2 > dword_140073F90[v12] || a2 <= dword_140073F90[v12 - 1] )
        {
          if ( ++v12 >= 0xAAu )
            goto LABEL_14;
        }
        v11 = v12;
LABEL_14:
        v13 = v24[0];
        v14 = 0;
        v15 = v9;
        v16 = 100i64 * v25;
        Memory[1] = v11;
        Memory[2] = 16 * (100 * v26 / v13) + ((v16 / v13) & 0xF);
        do
        {
          v17 = *v15;
          if ( *v15 > v25 )
          {
            if ( v17 > v26 )
              v18 = (v17 > v24[0]) + 2;
            else
              v18 = 1;
          }
          else
          {
            v18 = 0;
          }
          v19 = v14 & 3;
          v20 = (v14++ >> 2) + 3;
          ++v15;
          Memory[v20] += v18 << (2 * v19);
        }
        while ( v14 < 0x80 );
        *a3 = __PAIR16__(*Memory, *Memory) >> 4;
        *(a3 + 1) = (Memory[1] >> 4) + 16 * Memory[1];
        *(a3 + 2) = (Memory[2] >> 4) + 16 * Memory[2];
        v21 = (a3 + 3);
        do
        {
          v22 = 34 - v3++;
          *v21++ = Memory[v22];
        }
        while ( v3 < 0x20 );
        LOBYTE(v3) = 1;
      }
      Get_ExFreePool(v9);
    }
    Get_ExFreePool(Memory);
  }
  return v3;
}
// 140073F90: using guessed type _DWORD dword_140073F90[31];
// 140038070: using guessed type unsigned int var_38[14];

//----- (0000000140038264) ----------------------------------------------------
char __fastcall sub_140038264(__int64 a1, char *a2)
{
  __int64 v4; // rdi
  unsigned int v5; // ecx
  __int64 v6; // rax
  unsigned int v7; // edx
  char result; // al

  if ( *(a1 + 16) != 2 )
    return 0;
  v4 = *(a1 + 24);
  if ( !v4 )
    return 0;
  v5 = *(a1 + 32);
  if ( v5 <= 0x10 )
    return 0;
  v6 = -1i64;
  do
    ++v6;
  while ( *&a2[2 * v6] );
  v7 = 2 * v6 + 2;
  if ( v7 > v5 - 16 )
    return 0;
  *(v4 + 8) = v7;
  *(v4 + 4) = 1;
  EAC_memcpy((v4 + 12), a2, v7);
  result = 1;
  **(a1 + 40) = *(v4 + 8) + 16;
  return result;
}

//----- (00000001400382E0) ----------------------------------------------------
char __fastcall sub_1400382E0(__int64 a1, _UNICODE_STRING *UnicodeString, _UNICODE_STRING *UnicodeString2)
{
  WCHAR **string; // rsi
  unsigned __int64 v7; // rdi
  unsigned __int64 v9; // rbx
  int v10; // edi
  unsigned __int64 v11; // r9
  LONG ret; // edx
  int v13[5]; // [rsp+28h] [rbp-28h]
  _BYTE v14[20]; // [rsp+3Ch] [rbp-14h] BYREF

  string = off_140083060;
  v7 = 0i64;
  while ( Get_CompareUnicodeString(UnicodeString2, *string) )
  {
    v7 += 120i64;
    string += 15;
    if ( v7 >= 0xF0 )
      return 0;
  }
  v9 = 0i64;
  while ( Get_CompareUnicodeString(UnicodeString, string[v9 + 1]) )
  {
    v9 += 2i64;
    if ( v9 >= 14 )
      return 0;
  }
  v13[0] = 543763053;
  v13[1] = 33345544;
  v13[2] = -1748325302;
  v10 = -1251524226;
  v13[3] = 397930400;
  v11 = 0i64;
  v13[4] = 498198019;
  memset(v14, 0, sizeof(v14));
  do
  {
    v10 = __ROR4__(1140671485 * v10 + 12820163, 3);
    *&v14[v11 * 4] = v13[v11] ^ v10;
    ++v11;
  }
  while ( v11 < 5 );

  ret = Get_CompareUnicodeString(*(a1 + 8), v14);
  memset(v14, 0, sizeof(v14));

  if ( ret )
    return 0;
  return sub_140038264(a1, string[v9 + 2]);
}
// 140083060: using guessed type wchar_t *off_140083060[30];

//----- (0000000140038418) ----------------------------------------------------
char __fastcall sub_140038418(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int32 v7; // edx
  unsigned __int64 v8; // rdi
  unsigned __int64 i; // r8
  unsigned __int64 j; // r8
  char v11; // cl
  char v12; // si
  unsigned __int32 v13; // edx
  unsigned __int64 k; // r8
  int v15; // ecx
  unsigned __int64 m; // r8
  char v17; // cl
  unsigned int v18; // edx
  unsigned __int64 n; // r8
  char v20; // cl
  char v21; // dl
  unsigned int v22; // edi
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r8
  char v25; // dl
  LONG v26; // edx
  unsigned __int32 v27; // edi
  unsigned __int64 v28; // r8
  LONG v29; // edx
  unsigned __int64 v30; // r8
  unsigned int v31; // edi
  int v32; // ecx
  char v33; // dl
  char result; // al
  unsigned __int64 v35; // rcx
  __int128 *v36; // rdi
  unsigned int v37; // edi
  unsigned __int64 v38; // r8
  LONG v39; // edx
  unsigned __int64 v40; // r8
  unsigned __int32 v41; // edi
  char v42; // dl
  int v43[2]; // [rsp+30h] [rbp-D8h]
  __int64 v44; // [rsp+38h] [rbp-D0h]
  __int16 v45; // [rsp+40h] [rbp-C8h]
  int v46[10]; // [rsp+42h] [rbp-C6h]
  __int64 v47; // [rsp+6Ah] [rbp-9Eh]
  __int16 v48; // [rsp+72h] [rbp-96h]
  int v49[13]; // [rsp+74h] [rbp-94h]
  __int16 v50; // [rsp+A8h] [rbp-60h]
  int v51[18]; // [rsp+AAh] [rbp-5Eh]
  __int16 v52; // [rsp+F2h] [rbp-16h]
  int v53[18]; // [rsp+F4h] [rbp-14h]
  __int16 v54; // [rsp+13Ch] [rbp+34h]
  int v55[18]; // [rsp+13Eh] [rbp+36h]
  __int16 v56; // [rsp+186h] [rbp+7Eh]
  int v57[14]; // [rsp+188h] [rbp+80h]
  int v58[15]; // [rsp+1C0h] [rbp+B8h]
  _BYTE v59[18]; // [rsp+1FCh] [rbp+F4h] BYREF
  __int128 v60[3]; // [rsp+20Eh] [rbp+106h] BYREF
  int v61; // [rsp+23Eh] [rbp+136h]
  __int16 v62; // [rsp+242h] [rbp+13Ah]
  __int128 v63[3]; // [rsp+244h] [rbp+13Ch] BYREF
  __int16 v64; // [rsp+274h] [rbp+16Ch]
  _BYTE v65[60]; // [rsp+276h] [rbp+16Eh] BYREF
  _BYTE v66[56]; // [rsp+2B2h] [rbp+1AAh] BYREF
  char v67[74]; // [rsp+2EAh] [rbp+1E2h] BYREF
  char v68[74]; // [rsp+334h] [rbp+22Ch] BYREF
  char v69[74]; // [rsp+37Eh] [rbp+276h] BYREF

  v3 = 0i64;
  v51[0] = -89849792;
  v51[1] = 180221680;
  v51[2] = 643951198;
  v51[3] = 1859780885;
  v51[4] = 1393088218;
  v51[5] = 6630449;
  v51[6] = -630174266;
  v51[7] = -284904386;
  v51[8] = 1968323371;
  v51[9] = 1756886878;
  v51[10] = 593517081;
  v51[11] = -173410660;
  v51[12] = 1676895537;
  v51[13] = -1339815008;
  v51[14] = -1218484696;
  v51[15] = -773353565;
  v51[16] = 1953767004;
  v51[17] = -1016840221;
  v52 = 25726;
  EAC_memset(v69, 0, 0x4Aui64);
  v7 = -91029501;
  v8 = 72i64;
  for ( i = 0i64; i < 18; ++i )
  {
    *&v69[i * 4] = v51[i] ^ v7;
    v7 = _byteswap_ulong(((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13) ^ (32
                                                                      * (((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13))));
  }
  for ( j = 72i64; j < 0x4A; ++j )
  {
    v11 = v7;
    v7 >>= 8;
    v69[j] = *(v51 + j) ^ v11;
  }
  v12 = 1;
  if ( !Get_CompareUnicodeString(a3, v69) )
    goto LABEL_16;
  v53[0] = -1860320182;
  v54 = -11505;
  v53[1] = -1723901409;
  v53[2] = 1057062706;
  v53[3] = -1159845163;
  v53[4] = 551183714;
  v53[5] = -698395211;
  v53[6] = -210662524;
  v53[7] = -1944164753;
  v53[8] = -1454120095;
  v53[9] = 1425129240;
  v53[10] = 608252565;
  v53[11] = 1106495867;
  v53[12] = -549263629;
  v53[13] = 2055627480;
  v53[14] = -219937506;
  v53[15] = 1166351618;
  v53[16] = 12486931;
  v53[17] = 1164866031;
  EAC_memset(v68, 0, 0x4Aui64);
  v13 = -1856453618;
  for ( k = 0i64; k < 18; ++k )
  {
    v15 = v53[k] ^ v13;
    v13 = _byteswap_ulong(214013 * v13 + 2531011);
    *&v68[k * 4] = v15;
  }
  for ( m = 72i64; m < 0x4A; ++m )
  {
    v17 = v13;
    v13 >>= 8;
    v68[m] = *(v53 + m) ^ v17;
  }
  v12 = 3;
  if ( !Get_CompareUnicodeString(a3, v68) )
    goto LABEL_16;
  v55[0] = -283058899;
  v56 = 30675;
  v55[1] = 1765805946;
  v55[2] = -539470338;
  v55[3] = 1732549989;
  v55[4] = 21055580;
  v55[5] = -229961451;
  v55[6] = 898255945;
  v55[7] = 1375908631;
  v55[8] = -2097987071;
  v55[9] = -242693271;
  v55[10] = -1463858850;
  v55[11] = 50378991;
  v55[12] = -1423842554;
  v55[13] = -636948099;
  v55[14] = 1026741118;
  v55[15] = -558426481;
  v55[16] = 1355700521;
  v55[17] = 448281655;
  EAC_memset(v67, 0, 0x4Aui64);
  v18 = -278733548;
  for ( n = 0i64; n < 18; ++n )
  {
    *&v67[n * 4] = v55[n] ^ v18;
    v18 = ~(((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7) ^ ((((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7)) >> 13));
  }
  do
  {
    v20 = v18;
    v18 >>= 8;
    v67[v8] = *(v55 + v8) ^ v20;
    ++v8;
  }
  while ( v8 < 0x4A );
  v12 = 7;
  if ( Get_CompareUnicodeString(a3, v67) )
  {
    v21 = 1;
  }
  else
  {
LABEL_16:
    v21 = 0;
    if ( (v12 & 4) == 0 )
      goto LABEL_18;
  }
  memset(v67, 0, sizeof(v67));
LABEL_18:
  if ( (v12 & 2) != 0 )
    memset(v68, 0, sizeof(v68));
  memset(v69, 0, sizeof(v69));
  if ( !v21 )
  {
    v43[0] = 1831962975;
    v45 = -14011;
    v43[1] = 430616539;
    v22 = 1833208089;
    v44 = 0x8404DFCFD8294F10ui64;
    v23 = 0i64;
    memset(v59, 0, sizeof(v59));
    v24 = 16i64;
    do
    {
      *&v59[v23 * 4] = v43[v23] ^ v22;
      ++v23;
      v22 = __ROL4__(
              ((v22 ^ (v22 >> 7)) << 9) ^ v22 ^ (v22 >> 7) ^ ((((v22 ^ (v22 >> 7)) << 9) ^ v22 ^ (v22 >> 7)) >> 13),
              4);
    }
    while ( v23 < 4 );
    do
    {
      v25 = v22;
      v22 >>= 8;
      v59[v24] = *(v43 + v24) ^ v25;
      ++v24;
    }
    while ( v24 < 0x12 );
    v26 = Get_CompareUnicodeString(*(a1 + 8), v59);
    memset(v59, 0, sizeof(v59));
    if ( !v26 )
    {
      v57[0] = 478454280;
      memset(v66, 0, sizeof(v66));
      v57[1] = -1810609242;
      v27 = 1932996329;
      v57[2] = 1348266954;
      v28 = 0i64;
      v57[3] = 1116567371;
      v57[4] = -1676765905;
      v57[5] = -1936441989;
      v57[6] = 1338590432;
      v57[7] = 1931255633;
      v57[8] = 1211638453;
      v57[9] = 1423607912;
      v57[10] = -1840164234;
      v57[11] = 704560610;
      v57[12] = -2144235690;
      v57[13] = -1417768574;
      do
      {
        v27 = _byteswap_ulong(((v27 ^ (v27 << 13)) >> 17) ^ v27 ^ (v27 << 13) ^ (32
                                                                               * (((v27 ^ (v27 << 13)) >> 17) ^ v27 ^ (v27 << 13))));
        *&v66[v28 * 4] = v57[v28] ^ v27;
        ++v28;
      }
      while ( v28 < 14 );
      v29 = Get_CompareUnicodeString(a2, v66);
      memset(v66, 0, sizeof(v66));
      if ( !v29 )
      {
        v46[0] = 402371405;
        v48 = 8987;
        v30 = 48i64;
        v46[1] = 750282698;
        v64 = 0;
        v31 = 394900238;
        v46[2] = 1574780417;
        v46[3] = -1925300571;
        v46[4] = -338701704;
        v46[5] = -1037796108;
        v46[6] = 2098021697;
        v46[7] = 1918029191;
        v46[8] = 486114117;
        v46[9] = 288406349;
        v47 = 0xC7A08D8AE7BF83C6ui64;
        memset(v63, 0, sizeof(v63));
        do
        {
          v32 = v46[v3] ^ v31;
          v31 = __ROR4__(214013 * v31 + 2531011, 3);
          *(v63 + v3 * 4) = v32;
          ++v3;
        }
        while ( v3 < 12 );
        do
        {
          v33 = v31;
          v31 >>= 8;
          *(v63 + v30) = *(v46 + v30) ^ v33;
          ++v30;
        }
        while ( v30 < 0x32 );
        result = sub_140038264(a1, v63);
        v35 = 50i64;
        v36 = v63;
LABEL_32:
        memset(v36, 0, v35);
        return result;
      }
      v37 = -1708759147;
      v38 = 0i64;
      v58[0] = 1942260899;
      v58[1] = 419339475;
      v58[2] = 1472225868;
      v58[3] = -1091274204;
      v58[4] = -213750270;
      v58[5] = 496592902;
      v58[6] = 386248433;
      v58[7] = 1234655376;
      v58[8] = -1064204344;
      v58[9] = 711771383;
      v58[10] = -1637238590;
      v58[11] = 927454774;
      v58[12] = -276231249;
      v58[13] = 1744053022;
      v58[14] = -504472554;
      memset(v65, 0, sizeof(v65));
      do
      {
        v37 = ~(((v37 ^ (v37 << 13)) >> 17) ^ v37 ^ (v37 << 13) ^ (32 * (((v37 ^ (v37 << 13)) >> 17) ^ v37 ^ (v37 << 13))));
        *&v65[v38 * 4] = v58[v38] ^ v37;
        ++v38;
      }
      while ( v38 < 15 );
      v39 = Get_CompareUnicodeString(a2, v65);
      memset(v65, 0, sizeof(v65));
      if ( !v39 )
      {
        v49[0] = 954466087;
        v49[1] = 1431461504;
        v50 = -12830;
        v40 = 52i64;
        v49[2] = -1595097551;
        v61 = 0;
        v41 = 949092196;
        v62 = 0;
        v49[3] = -603947499;
        v49[4] = 211375450;
        v49[5] = 1370863797;
        v49[6] = 1433369033;
        v49[7] = -336914588;
        v49[8] = 1124166186;
        v49[9] = 1176477676;
        v49[10] = -1207097655;
        v49[11] = -416373266;
        v49[12] = 1186919312;
        memset(v60, 0, sizeof(v60));
        do
        {
          *(v60 + v3 * 4) = v49[v3] ^ v41;
          ++v3;
          v41 = _byteswap_ulong(((v41 ^ (v41 >> 7)) << 9) ^ v41 ^ (v41 >> 7) ^ ((((v41 ^ (v41 >> 7)) << 9) ^ v41 ^ (v41 >> 7)) >> 13));
        }
        while ( v3 < 13 );
        do
        {
          v42 = v41;
          v41 >>= 8;
          *(v60 + v40) = *(v49 + v40) ^ v42;
          ++v40;
        }
        while ( v40 < 0x36 );
        result = sub_140038264(a1, v60);
        v35 = 54i64;
        v36 = v60;
        goto LABEL_32;
      }
    }
  }
  return 0;
}
// 140038264: using guessed type __int64 __fastcall sub_140038264(_QWORD, _QWORD);

//----- (0000000140038E64) ----------------------------------------------------
__int64 __fastcall sub_140038E64(unsigned __int16 *a1, __int64 a2, __int64 a3)
{
  unsigned __int16 v4; // di
  __int64 v7; // rcx
  __int64 v8; // rbx
  unsigned int v9; // edx
  unsigned __int64 i; // rdi
  unsigned __int64 v11; // rdi
  unsigned int v12; // r12d
  char v13; // cl
  char *v14; // r14
  char *v15; // r8
  char *v16; // r8
  int v17; // ecx
  unsigned __int64 j; // rdi
  char *v19; // r8
  __int64 v20; // rax
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rcx
  __int64 result; // rax
  bool v24; // zf
  __int16 v25; // bx
  int v26[20]; // [rsp+28h] [rbp-D8h]
  __int16 v27; // [rsp+78h] [rbp-88h]
  int v28[22]; // [rsp+7Ah] [rbp-86h]
  char v29[82]; // [rsp+D2h] [rbp-2Eh] BYREF
  __m128 v30[8]; // [rsp+124h] [rbp+24h] BYREF
  unsigned __int64 v31; // [rsp+1C0h] [rbp+C0h]

  v4 = *a1 >> 1;
  if ( v4 < 0x40u )
    return 0i64;
  v7 = *(a1 + 1);
  if ( *(v7 + 2i64 * v4 - 76) != 123 )
    return 0i64;
  v31 = v4;
  if ( *(v7 + 2i64 * v4 - 2) != 125 )
    return 0i64;
  v26[0] = 1328833858;
  v26[1] = -1138102334;
  v26[2] = -24899783;
  v26[3] = -1232694247;
  v26[4] = 1097065051;
  v26[5] = -2031870694;
  v26[6] = 532364657;
  v26[7] = -1809095114;
  v26[8] = -1779796326;
  v26[9] = 638291669;
  v26[10] = -1405948427;
  v26[11] = 1033266840;
  v26[12] = 1520539075;
  v26[13] = -1152857624;
  v26[14] = -151401918;
  v26[15] = -2043353883;
  v26[16] = 928167621;
  v26[17] = -1826604560;
  v26[18] = -1007908003;
  v26[19] = 826311093;
  v27 = 6013;
  EAC_memset(v29, 0, 0x52ui64);
  v8 = 0i64;
  v9 = 1333355806;
  for ( i = 0i64; i < 20; ++i )
  {
    *&v29[i * 4] = v26[i] ^ v9;
    v9 = ~(((v9 ^ (v9 << 13)) >> 7) ^ v9 ^ (v9 << 13) ^ ((((v9 ^ (v9 << 13)) >> 7) ^ v9 ^ (v9 << 13)) << 17));
  }
  v11 = 80i64;
  v12 = 1;
  do
  {
    v13 = v9;
    v9 >>= 8;
    v29[v11] = *(v26 + v11) ^ v13;
    ++v11;
  }
  while ( v11 < 0x52 );
  v14 = *(a1 + 1);
  v15 = sub_14005D7E4(v14, v29, v31);
  memset(v29, 0, sizeof(v29));
  if ( !v15 )
  {
    v28[0] = 698831567;
    v28[1] = 1711800935;
    v28[2] = -1395376827;
    v28[3] = 1478585833;
    v28[4] = 230663133;
    v28[5] = -650963046;
    v28[6] = 2026790765;
    v28[7] = 1654780898;
    v28[8] = -1887649780;
    v28[9] = -197125236;
    v28[10] = 1483854071;
    v28[11] = -1697475469;
    v28[12] = 1184862404;
    v28[13] = -1140979982;
    v28[14] = 1810315562;
    v28[15] = -188381343;
    v28[16] = -900826025;
    v28[17] = 45502336;
    v28[18] = 1564918147;
    v28[19] = 1434944522;
    v28[20] = 1528916859;
    v28[21] = 1249898490;
    EAC_memset(v30, 0, 0x58ui64);
    v17 = 861162018;
    for ( j = 0i64; j < 22; ++j )
    {
      v17 = -5524003 - 13141 * v17;
      v30[0].m128_i32[j] = v28[j] ^ v17;
    }
    v14 = *(a1 + 1);
    v19 = sub_14005D7E4(v14, v30, v31);
    memset(v30, 0, 0x58ui64);
    if ( v19 )
    {
      v12 = 2;
      v16 = v19 + 86;
      goto LABEL_14;
    }
    return 0i64;
  }
  v16 = v15 + 80;
LABEL_14:
  v20 = *a1 - v16;
  *a2 = 0;
  v21 = &v14[v20] >> 1;
  if ( !v21 )
    return 0i64;
  while ( 1 )
  {
    v22 = v8 + 1;
    if ( *&v16[2 * v8] == 92 )
      break;
    ++v8;
    if ( v22 >= v21 )
      return 0i64;
  }
  v24 = 2 * v8 == 0;
  v25 = 2 * v8;
  *(a2 + 8) = v16;
  *a2 = v25;
  *(a2 + 2) = v25;
  if ( v24 || v21 - v22 < 0x26 || *&v16[2 * v22] != 123 || *&v16[2 * v22 + 74] != 125 )
    return 0i64;
  *a3 = 4718664;
  result = v12;
  *(a3 + 8) = &v16[2 * v22 + 2];
  return result;
}
// 140038E64: using guessed type __m128 var_8C[8];

//----- (00000001400391F0) ----------------------------------------------------
void __fastcall sub_1400391F0(__int64 Process, char a2)
{
  __m128 *Memory; // rax
  __int64 v5; // rdi
  char v6; // si
  int v7; // ebx
  int ProcessWow64Process; // eax
  __int64 v9; // rbx
  __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 i; // rcx
  char v13[16]; // [rsp+40h] [rbp-28h] BYREF
  char v14[16]; // [rsp+50h] [rbp-18h] BYREF

  if ( Process )
  {
    Memory = EAC_Allocate_Memory(0x330ui64);
    v5 = Memory;
    if ( Memory )
    {
      EAC_memset(Memory, 0, 0x330ui64);
      if ( !a2 || (v6 = 1, !sub_140053410(Process, v14)) )
        v6 = 0;

      v7 = Get_PsGetProcessId(Process);
      ProcessWow64Process = Get_PsGetProcessWow64Process(Process);
      v9 = sub_14004ADA0(0, 0, 0, 2049, ProcessWow64Process, v14 & -(v6 != 0), v7, 0i64);
      if ( v9 )
      {
        if ( !v6 )
        {
          if ( EAC_GetProcessImageFileName(Process, v13) )
          {
            v10 = v9 + 32;
            if ( v9 != -32 )
            {
              v11 = -1i64;
              do
                ++v11;
              while ( v13[v11] );
              for ( i = 0i64; i < 0xFF; ++i )
              {
                if ( i >= v11 )
                  break;
                *(v10 + 2 * i) = v13[i];
              }
              *(v10 + 2 * i) = 0;
            }
          }
        }
        *v5 = v9;
        *(v5 + 40) = 1;
        *(v5 + 48) = 1659741067;
        *(v5 + 64) = 0;
        *(v5 + 56) = 0i64;
        (loc_140014608)(v5, 0i64);
        Get_ExFreePool(v9);
      }
      if ( v6 )
        EAC_Free_UnicodeString(v14);
      Get_ExFreePool(v5);
    }
  }
}
// 14004ADA0: using guessed type __int64 __fastcall sub_14004ADA0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD, __int64);
// 140053410: using guessed type __int64 __fastcall sub_140053410(_QWORD, _QWORD);
// 1400391F0: using guessed type char var_28[16];

//----- (0000000140039E28) ----------------------------------------------------
__int64 __fastcall sub_140039E28(_BYTE *a1, _DWORD *a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v5; // rdi
  char *v6; // rbp
  unsigned __int64 v7; // rsi
  unsigned int v8; // r15d
  __m128 *Memory; // rax
  __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // r10
  unsigned __int64 v13; // r8
  int v14; // r9d
  _BYTE *v15; // rdx
  unsigned int v16; // r9d
  char v17; // cl
  unsigned __int64 v18; // rcx
  __int64 result; // rax
  __int64 v20; // rsi

  v2 = 0i64;
  v5 = 0i64;
  if ( a1 && a2 )
  {
    v6 = (a2 + 2);
    v7 = 0i64;
    if ( a2 != -8i64 )
    {
      do
      {
        if ( !v6[v7] )
          break;
        ++v7;
      }
      while ( v7 < 0x100 );
    }
    v8 = v7 + 10;
    Memory = EAC_Allocate_Memory(v7 + 10);
    v5 = Memory;
    if ( Memory )
    {
      EAC_memset(Memory, 0, v7 + 10);
      *v5 = *a1;
      *(v5 + 1) = *a2;
      *(v5 + 5) = a2[1];
      if ( v7 )
        EAC_memcpy((v5 + 9), v6, v7);
      if ( v7 != -10i64 )
      {
        v10 = EAC_Allocate_Memory(0x8208ui64);
        v11 = v10;
        if ( v10 )
        {
          EAC_memset((v10 + 8), 0, 0x8200ui64);
          v12 = v11 + 8;
          *v11 = 0i64;
          *(v11 + 8) = -2115313531;
          v13 = 24i64;
          *(v11 + 12) = -1409722411;
          *(v11 + 16) = 1847766854;
          *(v11 + 24) = -1697202964;
          *(v11 + 28) = -2113269444;
          v14 = (1685200711 * (v5 >> 2)) ^ 0x1BBA0EE7;
          *(v11 + 20) = (1685200711 * (v5 >> 2)) ^ 0x806C60AE;
          if ( v8 )
          {
            do
            {
              if ( v2 >= 0x8000 )
                break;
              v15 = (v2 + v5);
              ++v13;
              v16 = __ROR4__(
                      ((v14 ^ (v14 << 13)) >> 17) ^ v14 ^ (v14 << 13) ^ (32
                                                                       * (((v14 ^ (v14 << 13)) >> 17) ^ v14 ^ (v14 << 13))),
                      1);
              v17 = 8 * (v2++ & 3);
              v15[v12 - v5 + 24] = *v15 ^ (v16 >> v17);
              v14 = *v15 ^ v16;
            }
            while ( v2 < v8 );
          }
          v18 = (v13 + 255) & 0xFFFFFFFFFFFFFF00ui64;
          while ( v13 < v18 )
          {
            v14 *= 1685200711;
            *(v13 + v12) = BYTE1(v14);
            ++v13;
          }
          *(v11 + 24) ^= v14;
          *(v11 + 28) ^= v2;
          *v11 = v13;
          (loc_140016B54)(1965044622i64, v11 + 8);
          Get_ExFreePool(v11);
        }
        return Get_ExFreePool(v5);
      }
    }
  }
  result = EAC_Allocate_Memory(0x8208ui64);
  v20 = result;
  if ( result )
  {
    EAC_memset((result + 8), 0, 0x8200ui64);
    *(v20 + 8) = -2115313531;
    *(v20 + 12) = -1409722411;
    *(v20 + 16) = 1847766854;
    *(v20 + 20) = -2140381010;
    *(v20 + 24) = -2123582965;
    *(v20 + 28) = -2113269444;
    *v20 = 24i64;
    (loc_140016B54)(1965044622i64);
    result = Get_ExFreePool(v20);
  }
  if ( v5 )
    return Get_ExFreePool(v5);
  return result;
}

//----- (000000014003A090) ----------------------------------------------------
char __fastcall sub_14003A090(__int64 a1, __int64 a2, __int64 a3, _DWORD *a4)
{
  char ret; // bp
  unsigned __int64 v7; // rsi
  _DWORD *System_Information; // rax
  __int64 v9; // rdi
  unsigned int v11; // ecx
  __int64 v12; // r14
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rsi
  char *v15; // rdx

  ret = 0;
  if ( !a1 )
  {
    if ( a4 )
      *a4 = 2;
    return 0;
  }
  v7 = *(a1 + 224);
  if ( !v7 )
  {
    if ( a4 )
      *a4 = 4;
    return 0;
  }
  System_Information = Get_System_Information();
  v9 = System_Information;
  if ( !System_Information )
  {
    if ( a4 )
      *a4 = 5;
    return 0;
  }
  v11 = 0;
  if ( *System_Information )
  {
    while ( 1 )
    {
      v12 = 74i64 * v11;
      v13 = *&System_Information[v12 + 6];
      if ( v13 >= MmSystemRangeStart && v7 >= v13 && v7 <= v13 + System_Information[v12 + 8] )
        break;
      if ( ++v11 >= *System_Information )
        goto LABEL_26;
    }
    ret = 1;
    if ( a3 )
    {
      *a3 = v7 - v13;
      v14 = 0i64;
      v15 = &System_Information[v12 + 12];
      if ( v15 )
      {
        do
        {
          if ( !v15[v14] )
            break;
          ++v14;
        }
        while ( v14 < 0x100 );
      }
      if ( v14 > 0xFF )
        v14 = 255i64;
      EAC_memcpy((a3 + 8), v15, v14);
      *(v14 + a3 + 8) = 0;
      *(a3 + 4) = *(v12 * 4 + v9 + 32);
    }
    if ( a4 )
      *a4 = 7;
  }
LABEL_26:
  Get_ExFreePool(v9);
  if ( !ret && a4 )
    *a4 = 6;

  return ret;
}

//----- (000000014003A1D4) ----------------------------------------------------
__int64 __fastcall sub_14003A1D4(__int64 a1)
{
  __int64 Memory; // rbx
  int (__fastcall *v3)(__int64, __int64, __int64, char *); // rax
  char v5; // [rsp+30h] [rbp+8h] BYREF

  Memory = 0i64;
  if ( a1 )
  {
    Memory = EAC_Allocate_Memory(0x400ui64);
    if ( Memory )
    {
      v3 = (loc_14005B768)(qword_140086040, &qword_140086040, 0i64);
      if ( !v3 || v3(a1, Memory, 1024i64, &v5) < 0 )
      {
        Get_ExFreePool(Memory);
        return 0i64;
      }
    }
  }
  return Memory;
}
// 140086040: using guessed type __int64 qword_140086040;

//----- (000000014003A244) ----------------------------------------------------
char __fastcall sub_14003A244(PVOID Object, __int64 Length, _UNICODE_STRING *unicode_string)
{
  char ret; // bl
  NTSTATUS v6; // eax
  __int64 Memory; // rdi
  struct _UNICODE_STRING ValueName; // [rsp+40h] [rbp-10h] BYREF
  ULONG ResultLength; // [rsp+70h] [rbp+20h] BYREF
  HANDLE KeyHandle; // [rsp+88h] [rbp+38h] BYREF

  ret = 0;
  ResultLength = 0;
  if ( !Object || !Length || !*(Length + 8) || !*Length || !*(Length + 2) || !unicode_string )
    return 0;

  if ( EAC_Allocate_Unicode_string(&ValueName, Length, *Length) )
  {
    if ( ObOpenObjectByPointer(Object, 0x200u, 0i64, 0x20019u, 0i64, 0, &KeyHandle) >= 0 )
    {
      v6 = ZwQueryValueKey(KeyHandle, &ValueName, KeyValuePartialInformation, 0i64, 0, &ResultLength);
      if ( v6 == -1073741789 || v6 == -2147483643 )
      {
        if ( ResultLength )
        {
          Memory = EAC_Allocate_Memory(ResultLength);
          if ( Memory )
          {
            if ( ZwQueryValueKey(KeyHandle, &ValueName, KeyValuePartialInformation, Memory, ResultLength, &ResultLength) >= 0
              && *(Memory + 4) == 1 )
            {
              ret = EAC_Read_String_From_Unicode_String(unicode_string, (Memory + 0xC));
            }
            Get_ExFreePool(Memory);
          }
        }
      }
      ZwClose(KeyHandle);
    }
    EAC_Free_UnicodeString(&ValueName);
  }
  return ret;
}

//----- (000000014003A390) ----------------------------------------------------
bool __fastcall sub_14003A390(__int64 a1)
{
  bool v2; // bl
  unsigned int v3; // edx
  unsigned __int64 i; // rdi
  unsigned __int64 j; // rdi
  char v6; // cl
  _WORD *v7; // rdi
  __int64 v8; // rcx
  _WORD *v9; // rax
  unsigned int v10; // ecx
  unsigned __int8 *v11; // rdx
  int v12; // eax
  unsigned int v13; // edx
  unsigned __int64 v14; // rdi
  unsigned __int64 k; // rdi
  char v16; // cl
  char v17; // di
  int v18; // edx
  unsigned __int64 v19; // rdi
  char v20; // dl
  _WORD *v21; // rax
  __int64 v22; // rdi
  int v24[6]; // [rsp+20h] [rbp-E0h]
  __int16 v25; // [rsp+38h] [rbp-C8h]
  int v26[6]; // [rsp+3Ah] [rbp-C6h]
  int v27[50]; // [rsp+52h] [rbp-AEh]
  __int16 v28; // [rsp+11Ah] [rbp+1Ah]
  __int16 v29[4]; // [rsp+120h] [rbp+20h] BYREF
  _WORD *v30; // [rsp+128h] [rbp+28h]
  _BYTE v31[26]; // [rsp+130h] [rbp+30h] BYREF
  __int128 v32[2]; // [rsp+14Ah] [rbp+4Ah] BYREF
  __m128 v33; // [rsp+170h] [rbp+70h] BYREF

  v27[0] = 947019656;
  v2 = 0;
  v27[1] = 1868678778;
  v27[2] = 596415071;
  v27[3] = 1569437789;
  v27[4] = 96877521;
  v27[5] = 1696684430;
  v27[6] = 1648238825;
  v27[7] = -988798556;
  v27[8] = -1510886983;
  v27[9] = 513139540;
  v27[10] = 1220684717;
  v27[11] = 709782484;
  v27[12] = -1207191700;
  v27[13] = -490396060;
  v27[14] = 29657190;
  v27[15] = 1608562842;
  v27[16] = 63635319;
  v27[17] = 233547451;
  v27[18] = 521652438;
  v27[19] = -1824788923;
  v27[20] = 1220607421;
  v27[21] = 546154789;
  v27[22] = -1421458919;
  v27[23] = -313872754;
  v27[24] = -369629409;
  v27[25] = -607899146;
  v27[26] = 818743467;
  v27[27] = 1714118624;
  v27[28] = -678252573;
  v27[29] = -1419967512;
  v27[30] = 207220670;
  v27[31] = 2126128228;
  v27[32] = -57734635;
  v27[33] = 1815061306;
  v27[34] = 405965779;
  v27[35] = 810016858;
  v27[36] = 268987502;
  v27[37] = 1239504017;
  v27[38] = -1922748355;
  v27[39] = 1149581409;
  v27[40] = -1826092852;
  v27[41] = 881728587;
  v27[42] = -1578765827;
  v27[43] = -127954963;
  v27[44] = 1603589049;
  v27[45] = 1161280846;
  v27[46] = 1209770963;
  v27[47] = 2146175865;
  v27[48] = 99058097;
  v27[49] = -126043254;
  v28 = -9594;
  EAC_memset(&v33, 0, 0xCAui64);
  v3 = 941645780;
  for ( i = 0i64; i < 50; ++i )
  {
    v33.m128_i32[i] = v27[i] ^ v3;
    v3 = -12241381 - 11451 * v3;
  }
  for ( j = 200i64; j < 0xCA; ++j )
  {
    v6 = v3;
    v3 >>= 8;
    v33.m128_i8[j] = *(v27 + j) ^ v6;
  }
  if ( a1 )
  {
    if ( *(a1 + 20) == 1 && *(a1 + 32) > 0x18u )
    {
      v7 = *(a1 + 24);
      if ( *v7 == 118 )
      {
        v8 = *(a1 + 8);
        if ( v8 )
        {
          v9 = *(v8 + 8);
          if ( v9 )
          {
            if ( *v8
              && *(v8 + 2)
              && *v8 == 76
              && *v9 == 123
              && v9[37] == 125
              && v9[9] == 45
              && v9[14] == 45
              && v9[19] == 45
              && v9[24] == 45 )
            {
              v10 = 1;
              v11 = (v9 + 1);
              do
              {
                if ( v10 > 0x18 || (v12 = 17318400, !_bittest(&v12, v10)) )
                {
                  if ( !byte_14007CC60[*v11] )
                    goto LABEL_41;
                }
                ++v10;
                v11 += 2;
              }
              while ( v10 < 0x25 );
              v29[0] = *(a1 + 32);
              v13 = 1204426770;
              v29[1] = v29[0];
              v25 = -29013;
              v30 = v7;
              v14 = 0i64;
              v24[0] = 1202264147;
              v24[1] = 1451107070;
              v24[2] = -1096959662;
              v24[3] = -1457208317;
              v24[4] = -170649417;
              v24[5] = -1626349368;
              memset(v31, 0, sizeof(v31));
              do
              {
                *&v31[v14 * 4] = v24[v14] ^ v13;
                ++v14;
                v13 = __ROL4__(
                        ((v13 ^ (v13 << 13)) >> 7) ^ v13 ^ (v13 << 13) ^ ((((v13 ^ (v13 << 13)) >> 7) ^ v13 ^ (v13 << 13)) << 17),
                        2);
              }
              while ( v14 < 6 );
              for ( k = 24i64; k < 0x1A; ++k )
              {
                v16 = v13;
                v13 >>= 8;
                v31[k] = *(v24 + k) ^ v16;
              }
              v17 = 1;
              if ( !sub_14005D25C(v29, v31) )
                goto LABEL_34;
              v26[0] = -1129355199;
              v26[1] = 1284705140;
              v26[2] = -1547037321;
              v18 = 162966912;
              v26[3] = 1432581203;
              v19 = 0i64;
              v26[4] = -1129280489;
              v26[5] = 897105891;
              memset(v32, 0, 24);
              do
              {
                v18 = __ROL4__(2487 * v18 + 11971968, 1);
                *(v32 + v19 * 4) = v26[v19] ^ v18;
                ++v19;
              }
              while ( v19 < 6 );
              v17 = 3;
              if ( sub_14005D25C(v29, v32) )
              {
                v20 = 1;
              }
              else
              {
LABEL_34:
                v20 = 0;
                if ( (v17 & 2) == 0 )
                {
LABEL_36:
                  memset(v31, 0, sizeof(v31));
                  if ( v20 )
                  {
                    v21 = sub_14003A1D4(*a1);
                    v22 = v21;
                    if ( v21 )
                    {
                      if ( *v21 == 200 )
                        v2 = Get_CompareUnicodeString(v21, &v33) == 0;
                      Get_ExFreePool(v22);
                    }
                  }
                  goto LABEL_41;
                }
              }
              memset(v32, 0, 0x18ui64);
              goto LABEL_36;
            }
          }
        }
      }
    }
  }
LABEL_41:
  memset(&v33, 0, 0xCAui64);
  return v2;
}
// 14005D25C: using guessed type __int64 __fastcall sub_14005D25C(_QWORD, _QWORD);
// 14007CC60: using guessed type _BYTE byte_14007CC60[256];
// 14003A390: using guessed type __m128 var_F0;

//----- (000000014003A8DC) ----------------------------------------------------
__int64 __fastcall sub_14003A8DC(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  char v5; // bl
  __int64 v7; // rax
  unsigned __int32 v8; // edx
  unsigned __int64 i; // rdi
  char v10; // al
  char v11; // dl
  char v12; // bl
  int v13; // edx
  unsigned __int64 j; // rdi
  int v15; // edx
  unsigned __int64 k; // rdi
  char v17; // al
  char v18; // dl
  unsigned __int32 v19; // edi
  unsigned __int64 v20; // r8
  unsigned __int64 m; // rdx
  int v22; // ecx
  char v23; // dl
  char v24; // dl
  int v25; // edi
  unsigned __int64 n; // r8
  char v27; // dl
  int v28; // edi
  unsigned __int64 ii; // r8
  char v30; // dl
  int v32[22]; // [rsp+20h] [rbp-E0h]
  __int16 v33; // [rsp+78h] [rbp-88h]
  int v34[19]; // [rsp+7Ah] [rbp-86h]
  int v35[20]; // [rsp+C6h] [rbp-3Ah]
  int v36[21]; // [rsp+116h] [rbp+16h]
  int v37[25]; // [rsp+16Ah] [rbp+6Ah]
  int v38[33]; // [rsp+1CEh] [rbp+CEh]
  char v39[90]; // [rsp+252h] [rbp+152h] BYREF
  char v40[76]; // [rsp+2ACh] [rbp+1ACh] BYREF
  __m128 v41[5]; // [rsp+2F8h] [rbp+1F8h] BYREF
  char v42[84]; // [rsp+348h] [rbp+248h] BYREF
  char v43[100]; // [rsp+39Ch] [rbp+29Ch] BYREF
  __m128 v44[12]; // [rsp+400h] [rbp+300h] BYREF

  v5 = 0;
  if ( !a4 )
    return 0i64;
  if ( !a1 )
    return 0i64;
  if ( ExGetPreviousMode() != 1 )
    return 0i64;
  v7 = *a4;
  if ( !*a4 || !*(v7 + 8) || !*v7 || !*(v7 + 2) )
    return 0i64;
  if ( PsGetCurrentThreadId() != *(a1 + 32) )
    goto LABEL_12;
  v37[0] = 546435985;
  v37[1] = -1314737242;
  v37[2] = 1388397560;
  v37[3] = -640361175;
  v37[4] = -864473902;
  v37[5] = 1499371026;
  v37[6] = -2128250697;
  v37[7] = -1304234808;
  v37[8] = 1433014135;
  v37[9] = -1886125251;
  v37[10] = -1180791508;
  v37[11] = -1215872723;
  v37[12] = 1726849609;
  v37[13] = 1766723866;
  v37[14] = 920378143;
  v37[15] = 96255665;
  v37[16] = 383871744;
  v37[17] = -70599294;
  v37[18] = 799517355;
  v37[19] = -1025247904;
  v37[20] = 952269789;
  v37[21] = -180109512;
  v37[22] = -1916621156;
  v37[23] = -1061624173;
  v37[24] = 2088212845;
  EAC_memset(v43, 0, 0x64ui64);
  v8 = 1582989871;
  for ( i = 0i64; i < 25; ++i )
  {
    v8 = _byteswap_ulong(((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13) ^ (32
                                                                      * (((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13))));
    *&v43[i * 4] = v37[i] ^ v8;
  }
  v5 = 1;
  v10 = sub_14005D25C(*a4, v43);
  v11 = 1;
  if ( !v10 )
LABEL_12:
    v11 = 0;
  if ( (v5 & 1) != 0 )
  {
    v5 &= ~1u;
    memset(v43, 0, sizeof(v43));
  }
  if ( v11 )
    return 3221225524i64;
  v36[0] = 1733256860;
  v12 = v5 | 2;
  v36[1] = 1220885338;
  v36[2] = -347337939;
  v36[3] = -1340770202;
  v36[4] = -1200721706;
  v36[5] = 1772528747;
  v36[6] = 998485857;
  v36[7] = 1474817284;
  v36[8] = -1760240756;
  v36[9] = 347659548;
  v36[10] = -1874190063;
  v36[11] = -633328947;
  v36[12] = -1182473375;
  v36[13] = 1485127238;
  v36[14] = -1932600732;
  v36[15] = -1512788521;
  v36[16] = -1723686520;
  v36[17] = 1985848607;
  v36[18] = 1748423062;
  v36[19] = -1089201953;
  v36[20] = -1722602513;
  EAC_memset(v42, 0, 0x54ui64);
  v13 = -565676549;
  for ( j = 0i64; j < 21; ++j )
  {
    v13 = __ROR4__(
            ((v13 ^ (v13 << 13)) >> 17) ^ v13 ^ (v13 << 13) ^ (32 * (((v13 ^ (v13 << 13)) >> 17) ^ v13 ^ (v13 << 13))),
            1);
    *&v42[j * 4] = v36[j] ^ v13;
  }
  if ( sub_14005D25C(*a4, v42) )
    goto LABEL_22;
  v12 |= 4u;
  v34[0] = -2091233147;
  v34[1] = 419475368;
  v34[2] = -1606052616;
  v34[3] = -645293434;
  v34[4] = 150713978;
  v34[5] = 1251811098;
  v34[6] = 1236837154;
  v34[7] = -1351547248;
  v34[8] = -620381610;
  v34[9] = 516385683;
  v34[10] = -93108058;
  v34[11] = -929417119;
  v34[12] = 2146897158;
  v34[13] = -1103387388;
  v34[14] = 110409184;
  v34[15] = -1328693649;
  v34[16] = 615014390;
  v34[17] = 2056510583;
  v34[18] = -1514661595;
  EAC_memset(v40, 0, 0x4Cui64);
  v15 = -163748897;
  for ( k = 0i64; k < 19; ++k )
  {
    v15 = ~(1140671485 * v15 + 12820163);
    *&v40[k * 4] = v34[k] ^ v15;
  }
  v17 = sub_14005D25C(*a4, v40);
  v18 = 0;
  if ( v17 )
LABEL_22:
    v18 = 1;
  if ( (v12 & 4) != 0 )
    memset(v40, 0, sizeof(v40));
  memset(v42, 0, sizeof(v42));
  if ( v18 )
    return 3221225524i64;
  v32[0] = -976170980;
  v32[1] = 55409475;
  v32[2] = 1161458036;
  v32[3] = -1316178348;
  v32[4] = 1319896519;
  v32[5] = -536422540;
  v32[6] = 1272413278;
  v32[7] = 514453741;
  v32[8] = 675461241;
  v32[9] = -1721702292;
  v32[10] = -548862090;
  v32[11] = 1575224239;
  v32[12] = -13609117;
  v32[13] = -1871451579;
  v32[14] = 1664498288;
  v32[15] = -1217265491;
  v32[16] = 1809162378;
  v32[17] = -659463050;
  v32[18] = 2018996504;
  v32[19] = -148977105;
  v32[20] = -444231452;
  v32[21] = 1079438358;
  v33 = -12535;
  EAC_memset(v39, 0, 0x5Aui64);
  v19 = -979513280;
  v20 = 88i64;
  for ( m = 0i64; m < 22; ++m )
  {
    v22 = v32[m] ^ v19;
    v19 = _byteswap_ulong(1140671485 * v19 + 12820163);
    *&v39[m * 4] = v22;
  }
  do
  {
    v23 = v19;
    v19 >>= 8;
    v39[v20] = *(v32 + v20) ^ v23;
    ++v20;
  }
  while ( v20 < 0x5A );
  v24 = sub_14005D25C(*a4, v39);
  memset(v39, 0, sizeof(v39));
  if ( v24 )
    return 3221225524i64;
  v38[0] = -733893329;
  v38[1] = 75784;
  v38[2] = -598548609;
  v38[3] = -489210377;
  v38[4] = -2031799619;
  v38[5] = -214949204;
  v38[6] = 170942651;
  v38[7] = -1067857118;
  v38[8] = 245572216;
  v38[9] = -1082358503;
  v38[10] = -1606644056;
  v38[11] = -1889619127;
  v38[12] = -1816465788;
  v38[13] = -617626229;
  v38[14] = -762186389;
  v38[15] = 1105723581;
  v38[16] = -1281247215;
  v38[17] = 1687100297;
  v38[18] = 137579027;
  v38[19] = -838939691;
  v38[20] = 179501892;
  v38[21] = 425693281;
  v38[22] = 441766820;
  v38[23] = -1330534047;
  v38[24] = -1723810401;
  v38[25] = 1868162162;
  v38[26] = 483172476;
  v38[27] = 382018676;
  v38[28] = -1847538357;
  v38[29] = -1172464198;
  v38[30] = 1325346656;
  v38[31] = 1810540308;
  v38[32] = -313920702;
  EAC_memset(v44, 0, 0x84ui64);
  v25 = -867913600;
  for ( n = 0i64; n < 33; ++n )
  {
    v25 = __ROL4__(1103515245 * v25 + 12345, 1);
    v44[0].m128_i32[n] = v38[n] ^ v25;
  }
  v27 = sub_14005D25C(*a4, v44);
  memset(v44, 0, 0x84ui64);
  if ( v27 )
    return 3221225524i64;
  v35[0] = -157366276;
  v35[1] = 885946628;
  v35[2] = -556392350;
  v35[3] = -625864899;
  v35[4] = 1101966051;
  v35[5] = 136290768;
  v35[6] = -1587213827;
  v35[7] = -1842533157;
  v35[8] = -729550975;
  v35[9] = 650282496;
  v35[10] = 1238697004;
  v35[11] = 2091028219;
  v35[12] = 1357306364;
  v35[13] = 1840936517;
  v35[14] = -330089644;
  v35[15] = 1950741397;
  v35[16] = 8256688;
  v35[17] = -757983450;
  v35[18] = 902197078;
  v35[19] = 1293325950;
  EAC_memset(v41, 0, 0x50ui64);
  v28 = 198941625;
  for ( ii = 0i64; ii < 20; ++ii )
  {
    v28 = __ROR4__(
            ((v28 ^ (v28 << 13)) >> 17) ^ v28 ^ (v28 << 13) ^ (32 * (((v28 ^ (v28 << 13)) >> 17) ^ v28 ^ (v28 << 13))),
            4);
    v41[0].m128_i32[ii] = v35[ii] ^ v28;
  }
  v30 = sub_14005D25C(*a4, v41);
  memset(v41, 0, sizeof(v41));
  if ( v30 )
    return 3221225524i64;
  else
    return 0i64;
}
// 14003A8DC: using guessed type __m128 var_C0[12];
// 14003A8DC: using guessed type __m128 var_1C8[5];

//----- (000000014003B1E0) ----------------------------------------------------
__int64 __fastcall sub_14003B1E0(_QWORD *a1, char a2, __int64 *a3)
{
  unsigned int v6; // r14d
  __int64 v7; // r15
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  int v11; // eax
  char v12; // al
  __int64 v13; // rax
  char v14; // dl
  __int64 v15; // rax
  char v16; // dl
  __int64 v17; // rdi
  __int64 v18; // rax
  char v19; // dl
  __int64 v20; // rax
  char v21; // dl
  __int64 v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rdi
  __int64 CurrentProcess; // r14
  __int64 v26; // rsi
  __int64 v27; // rax
  __int64 v28; // rdx
  char v29; // si
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  char v35; // al
  char v36; // dl
  char v37; // si
  WCHAR *v38; // rax
  __int64 v39; // rax
  char v40; // al
  char v41; // dl
  _DWORD *v42; // rsi
  unsigned int v43; // eax
  WCHAR *v44; // rax
  LONG CompareString; // edx
  WCHAR *v46; // rax
  LONG v47; // edx
  ULONG64 v48; // rcx
  __int64 v49; // rdx
  ULONG64 v50; // rdi
  unsigned __int64 v51; // rcx
  _UNICODE_STRING v53; // [rsp+28h] [rbp-4A0h] BYREF
  int v54; // [rsp+38h] [rbp-490h]
  int v55; // [rsp+3Ch] [rbp-48Ch]
  __int16 v56; // [rsp+40h] [rbp-488h]
  _UNICODE_STRING v57[2]; // [rsp+48h] [rbp-480h] BYREF
  int v58[9]; // [rsp+68h] [rbp-460h] BYREF
  int v59[26]; // [rsp+8Ch] [rbp-43Ch] BYREF
  int v60[9]; // [rsp+F4h] [rbp-3D4h] BYREF
  int v61[19]; // [rsp+118h] [rbp-3B0h] BYREF
  int v62[21]; // [rsp+164h] [rbp-364h] BYREF
  int v63[22]; // [rsp+1B8h] [rbp-310h] BYREF
  __int16 v64; // [rsp+210h] [rbp-2B8h]
  int v65[26]; // [rsp+212h] [rbp-2B6h] BYREF
  int v66[33]; // [rsp+27Ah] [rbp-24Eh] BYREF
  int v67[19]; // [rsp+2FEh] [rbp-1CAh] BYREF
  int v68[21]; // [rsp+34Ah] [rbp-17Eh] BYREF
  __int64 v69; // [rsp+3A0h] [rbp-128h]
  int v70[24]; // [rsp+3A8h] [rbp-120h] BYREF
  unsigned __int64 v71; // [rsp+408h] [rbp-C0h]
  char v72[144]; // [rsp+410h] [rbp-B8h] BYREF
  ULONG64 v74; // [rsp+4E8h] [rbp+20h]

  v6 = 0;
  v7 = 0i64;
  v69 = 0i64;
  if ( !a1 )
  {
    v8 = sub_14002D23C();
    if ( !EAC_Is_Equal_ProcessId(v8) )
      goto LABEL_76;
  }
  if ( sub_14005D214(a3[1]) )
    goto LABEL_76;
  v9 = sub_14003A1D4(*a3);
  v7 = v9;
  v69 = v9;
  if ( !v9 )
    goto LABEL_76;
  if ( *(v9 + 8) )
  {
    if ( *v9 )
    {
      if ( *(v9 + 2) )
      {
        v10 = a3[1];
        if ( v10 )
        {
          if ( *(v10 + 8) && *v10 && *(v10 + 2) )
          {
            v11 = sub_140038E64(v7, v57, &v53);
            if ( v11 == 1 )
            {
              v12 = sub_1400382E0(a3, v57, &v53);
              goto LABEL_17;
            }
            if ( v11 == 2 )
            {
              v12 = sub_140038418(a3, v57, &v53);
              goto LABEL_17;
            }
          }
        }
      }
    }
  }
  v12 = 0;
LABEL_17:
  if ( v12 )
  {
    v6 = -1073740541;
    goto LABEL_76;
  }
  if ( a1 )
  {
    v59[0] = -10524552;
    v59[1] = -639080242;
    v59[2] = 1464937436;
    v59[3] = -2001935473;
    v59[4] = -762280589;
    v59[5] = -1368194192;
    v59[6] = -1602412593;
    v59[7] = -122630909;
    v59[8] = 1514297640;
    v59[9] = -1354655322;
    v59[10] = -218138118;
    v59[11] = -2135850204;
    v59[12] = -195270301;
    v59[13] = -2042658505;
    v59[14] = -1028549360;
    v59[15] = -128252051;
    v59[16] = -1259864809;
    v59[17] = -2051739081;
    v59[18] = -639503633;
    v59[19] = 16587634;
    v59[20] = -417443078;
    v59[21] = 1716828493;
    v59[22] = 1216746385;
    v59[23] = 1880873485;
    v59[24] = -1587100794;
    v59[25] = -667041285;
    v13 = sub_14003C190(v59, v65);
    v14 = sub_14005D25C(v7, v13);
    memset(v65, 0, sizeof(v65));
    if ( v14 )
    {
      if ( !sub_14003A244(*a3, a3[1], &v53) )
      {
LABEL_29:
        if ( a2 )
        {
          v24 = a1[1];
          CurrentProcess = Get_PsGetCurrentProcess();
          v26 = (loc_14005423C)(v24, 0i64, 0i64);
          if ( (v26 & 0x880000002000000i64) == 0 )
          {
            v27 = (loc_14005423C)(CurrentProcess, 0i64, 0i64) & 0x880000002000000i64;
            if ( v27 )
            {
              LOBYTE(v28) = 1;
              (loc_14005423C)(v24, v28, v26 | v27);
            }
          }
        }
LABEL_75:
        v6 = -1073741772;
        goto LABEL_76;
      }
      v70[0] = -894207587;
      v70[1] = 1676849933;
      v70[2] = -240802971;
      v70[3] = 728821827;
      v70[4] = 213480505;
      v70[5] = 311390802;
      v70[6] = 1394374817;
      v70[7] = -1483343986;
      v70[8] = -1056887195;
      v70[9] = 689897298;
      v70[10] = -25140311;
      v70[11] = 2061328685;
      LOWORD(v70[12]) = 348;
      v15 = sub_14003C208(v70, v68);
      v16 = sub_14005D25C(&v53, v15);
      memset(v68, 0, 0x32ui64);
      if ( v16 )
      {
        v17 = 0x880000000000000i64;
      }
      else
      {
        *&v57[0].Length = -458654211;
        *(&v57[0].MaximumLength + 1) = 1162311668;
        v57[0].Buffer = 0x5D43BBFEEFE3710i64;
        *&v57[1].Length = -7376277;
        *(&v57[1].MaximumLength + 1) = -21953;
        v18 = sub_14003C2A0(v57, v58);
        v19 = sub_14005D25C(&v53, v18);
        memset(v58, 0, 0x16ui64);
        if ( v19 )
        {
          v17 = 0x80000000000000i64;
        }
        else
        {
          v58[0] = 1780224106;
          v58[1] = 657675499;
          v58[2] = 56333307;
          v58[3] = -283921828;
          v58[4] = -1311190130;
          v58[5] = 2063741661;
          LOWORD(v58[6]) = -14269;
          v20 = sub_14003C334(v58, v57);
          v21 = sub_14005D25C(&v53, v20);
          memset(v57, 0, 0x1Aui64);
          v17 = v21 != 0 ? 0x2000000 : 0;
          if ( !v21 )
          {
LABEL_28:
            EAC_Free_UnicodeString(&v53);
            goto LABEL_29;
          }
        }
      }
      v22 = (loc_14005423C)(a1[1], 0i64, 0i64);
      LOBYTE(v23) = 1;
      (loc_14005423C)(a1[1], v23, v17 | v22);
      goto LABEL_28;
    }
    v65[0] = 63067191;
    v65[1] = 430730365;
    v65[2] = -1603660797;
    v65[3] = -1496232894;
    v65[4] = -1017826720;
    v65[5] = -175528935;
    v65[6] = 1846677082;
    v65[7] = -1785741138;
    v65[8] = 495649900;
    v65[9] = -528550490;
    v65[10] = -2115163589;
    v65[11] = 1104837520;
    v65[12] = -1013311967;
    v65[13] = 530882234;
    v65[14] = -1795149038;
    v65[15] = -474527645;
    v65[16] = 1654969815;
    v65[17] = 488672993;
    v65[18] = 921360013;
    v65[19] = -1961627634;
    v65[20] = 715345687;
    v65[21] = 412533535;
    v65[22] = 993461360;
    v65[23] = -1684450195;
    v65[24] = -1713498835;
    v29 = 1;
    v30 = sub_14003C3C8(v65, v59);
    if ( sub_14005D25C(v7, v30) )
      goto LABEL_38;
    v62[0] = -1631166270;
    v62[1] = 284840105;
    v62[2] = -2050253887;
    v62[3] = 519510029;
    v62[4] = -1386946011;
    v62[5] = -401943533;
    v62[6] = 1148566374;
    v62[7] = -1845307535;
    v62[8] = -51934268;
    v62[9] = -1518530532;
    v62[10] = -374488465;
    v62[11] = 624781730;
    v62[12] = -783001623;
    v62[13] = 1103578367;
    v62[14] = -688811333;
    v62[15] = 1340500271;
    v62[16] = -1576307171;
    v62[17] = 733083219;
    v62[18] = -592110721;
    v62[19] = -474351839;
    v62[20] = 153840057;
    v29 = 3;
    v31 = sub_14003C434(v62, v68);
    if ( sub_14005D25C(v7, v31) )
      goto LABEL_38;
    v61[0] = 1083347725;
    v61[1] = 701553243;
    v61[2] = -830244768;
    v61[3] = 646293187;
    v61[4] = 1252914370;
    v61[5] = 284275041;
    v61[6] = -598864212;
    v61[7] = -1568629766;
    v61[8] = 665950318;
    v61[9] = 622642884;
    v61[10] = -970472709;
    v61[11] = -128384575;
    v61[12] = -1806908158;
    v61[13] = 492228844;
    v61[14] = -1092396424;
    v61[15] = 1031843190;
    v61[16] = 1368771459;
    v61[17] = -513033521;
    v61[18] = -1716024619;
    v29 = 7;
    v32 = sub_14003C4AC(v61, v67);
    if ( sub_14005D25C(v7, v32) )
      goto LABEL_38;
    v63[0] = 1737250854;
    v63[1] = -2061212519;
    v63[2] = -536241287;
    v63[3] = 1386200039;
    v63[4] = 124560511;
    v63[5] = -711616244;
    v63[6] = -104852099;
    v63[7] = -1117922083;
    v63[8] = -759746724;
    v63[9] = -274844719;
    v63[10] = 244107641;
    v63[11] = 1804749282;
    v63[12] = -172798647;
    v63[13] = 1579253654;
    v63[14] = 1184747273;
    v63[15] = 897332932;
    v63[16] = 44082380;
    v63[17] = 1698099575;
    v63[18] = -1095810107;
    v63[19] = 1729272296;
    v63[20] = -1469183831;
    v63[21] = -286925147;
    v64 = 31195;
    v29 = 15;
    v33 = sub_14003C518(v63, v70);
    if ( sub_14005D25C(v7, v33) )
      goto LABEL_38;
    v66[0] = -1495211729;
    v66[1] = 1550323876;
    v66[2] = -2118951815;
    v66[3] = 1116450471;
    v66[4] = -533160914;
    v66[5] = 1910799713;
    v66[6] = -1704006904;
    v66[7] = 104240240;
    v66[8] = -286890457;
    v66[9] = 1654551898;
    v66[10] = -1296632674;
    v66[11] = -1515442865;
    v66[12] = -389756799;
    v66[13] = 1168734616;
    v66[14] = -1821127443;
    v66[15] = 380181498;
    v66[16] = -934276977;
    v66[17] = -533705962;
    v66[18] = 167337047;
    v66[19] = 1502883513;
    v66[20] = -209490897;
    v66[21] = 1938280221;
    v66[22] = -1848079160;
    v66[23] = 485021689;
    v66[24] = -247156552;
    v66[25] = -1951508580;
    v66[26] = 510981934;
    v66[27] = 1506942207;
    v66[28] = 816391246;
    v66[29] = 1767929347;
    v66[30] = -259937009;
    v66[31] = 1074808869;
    v66[32] = -1269322289;
    v29 = 31;
    v34 = sub_14003C5BC(v66, v72);
    v35 = sub_14005D25C(v7, v34);
    v36 = 0;
    if ( v35 )
LABEL_38:
      v36 = 1;
    if ( (v29 & 0x10) != 0 )
    {
      v29 &= ~0x10u;
      memset(v72, 0, 0x84ui64);
    }
    if ( (v29 & 8) != 0 )
    {
      v29 &= ~8u;
      memset(v70, 0, 0x5Aui64);
    }
    if ( (v29 & 4) != 0 )
    {
      v29 &= ~4u;
      memset(v67, 0, sizeof(v67));
    }
    if ( (v29 & 2) != 0 )
    {
      v29 &= ~2u;
      memset(v68, 0, sizeof(v68));
    }
    if ( (v29 & 1) != 0 )
    {
      v29 &= ~1u;
      memset(v59, 0, 0x64ui64);
    }
    if ( v36 )
      goto LABEL_75;
    if ( !a2 )
    {
      v60[0] = -299119915;
      v60[1] = 710439793;
      v60[2] = -734390362;
      v60[3] = -1837698634;
      v60[4] = 946475830;
      v60[5] = 845417690;
      v60[6] = -164852514;
      v60[7] = -937358731;
      v60[8] = -985233612;
      v37 = v29 | 0x20;
      v38 = sub_14003C62C(v60, v58);
      if ( Get_CompareUnicodeString(a3[1], v38) )
        goto LABEL_53;
      v68[0] = 62292622;
      v68[1] = 414646600;
      v68[2] = 906316506;
      v68[3] = -20961484;
      v68[4] = -1576974387;
      v68[5] = 1903711789;
      v68[6] = 477718995;
      v68[7] = -206884811;
      v68[8] = 138645108;
      v68[9] = -897034951;
      v68[10] = -1822694034;
      v68[11] = 405394758;
      LOWORD(v68[12]) = -218;
      v37 |= 0x40u;
      v39 = sub_14003C680(v68, v70);
      v40 = sub_14005D25C(v7, v39);
      v41 = 1;
      if ( !v40 )
LABEL_53:
        v41 = 0;
      if ( (v37 & 0x40) != 0 )
      {
        v37 &= ~0x40u;
        memset(v70, 0, 0x32ui64);
      }
      if ( (v37 & 0x20) != 0 )
        memset(v58, 0, sizeof(v58));
      if ( v41 )
        goto LABEL_75;
      if ( *(a3 + 4) == 2 )
      {
        v42 = a3[3];
        if ( v42 )
        {
          v43 = *(a3 + 8);
          if ( v43 >= 0x10 )
          {
            LODWORD(v74) = v43 - 16;
            v67[0] = 1011954420;
            v67[1] = -344387872;
            v67[2] = 981275079;
            v67[3] = -627298260;
            v67[4] = 2101821791;
            v67[5] = 2101349871;
            v67[6] = 630442330;
            v67[7] = 2025021001;
            v67[8] = 1942761871;
            v67[9] = 808409624;
            v67[10] = -1134132591;
            v67[11] = 203274853;
            v67[12] = 847791141;
            v44 = sub_14003C718(v67, v68);
            CompareString = Get_CompareUnicodeString(a3[1], v44);
            memset(v68, 0, 0x34ui64);
            if ( !CompareString )
            {
              if ( v74 < 4 )
              {
                v42[2] = 0;
                v6 = -1073741789;
              }
              else
              {
                v42[2] = 4;
                v42[3] = 1;
                v6 = -1073740541;
              }
              v42[1] = 4;
              *a3[5] = 20;
              goto LABEL_76;
            }
            *&v53.Length = 167526672;
            *(&v53.MaximumLength + 1) = -309815623;
            v53.Buffer = 0xD94C0C9E689E43BCi64;
            v54 = -1933531011;
            v55 = -1819914280;
            v56 = -8187;
            v46 = sub_14003C770(&v53, v58);
            v47 = Get_CompareUnicodeString(a3[1], v46);
            memset(v58, 0, 0x1Aui64);
            if ( !v47 )
            {
              if ( sub_14002D23C() != a1[2] )
                goto LABEL_75;
              v48 = a1[44];
              if ( !v48 )
                goto LABEL_75;
              EAC_IsUsermodeValidAddress(v48, 60i64, 1);
              v49 = a1[44];
              v50 = 0i64;
              v74 = 0i64;
              if ( v49 )
              {
                v51 = 0i64;
                v71 = 0i64;
                while ( v51 < 8 )
                {
                  *(&v74 + v51) = *(v49 + 4 * v51 + 28) ^ 0x90;
                  v71 = ++v51;
                  v50 = v74;
                }
              }
              EAC_IsUsermodeValidAddress(v50, 40i64, 1);
              if ( PsGetCurrentThreadId() != *(v50 + 12) )
                goto LABEL_75;
            }
          }
        }
      }
    }
  }
LABEL_76:
  if ( v7 )
    Get_ExFreePool(v7);
  return v6;
}
// 14003B63A: variable 'v23' is possibly undefined
// 14003B6A2: variable 'v28' is possibly undefined
// 140038E64: using guessed type __int64 __fastcall sub_140038E64(_QWORD, _QWORD, _QWORD);
// 14003C190: using guessed type __int64 __fastcall sub_14003C190(_QWORD, _QWORD);
// 14003C208: using guessed type __int64 __fastcall sub_14003C208(_QWORD, _QWORD);
// 14003C2A0: using guessed type __int64 __fastcall sub_14003C2A0(_QWORD, _QWORD);
// 14003C334: using guessed type __int64 __fastcall sub_14003C334(_QWORD, _QWORD);
// 14003C3C8: using guessed type __int64 __fastcall sub_14003C3C8(_QWORD, _QWORD);
// 14003C434: using guessed type __int64 __fastcall sub_14003C434(_QWORD, _QWORD);
// 14003C4AC: using guessed type __int64 __fastcall sub_14003C4AC(_QWORD, _QWORD);
// 14003C518: using guessed type __int64 __fastcall sub_14003C518(_QWORD, _QWORD);
// 14003C5BC: using guessed type __int64 __fastcall sub_14003C5BC(_QWORD, _QWORD);
// 14003C62C: using guessed type __int64 __fastcall sub_14003C62C(_QWORD, _QWORD);
// 14003C680: using guessed type __int64 __fastcall sub_14003C680(_QWORD, _QWORD);
// 14003C718: using guessed type __int64 __fastcall sub_14003C718(_QWORD, _QWORD);
// 14003C770: using guessed type __int64 __fastcall sub_14003C770(_QWORD, _QWORD);
// 14005D214: using guessed type __int64 __fastcall sub_14005D214(_QWORD);

//----- (000000014003C190) ----------------------------------------------------
__m128 *__fastcall sub_14003C190(__int64 a1, __m128 *a2)
{
  unsigned int v4; // r8d
  unsigned __int64 i; // rdx
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x68ui64);
  v4 = 423529899;
  for ( i = 0i64; i < 26; ++i )
  {
    v4 = -(((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7) ^ ((((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7)) >> 13));
    result = a2;
    a2->m128_i32[i] = *(a1 + i * 4) ^ v4;
  }
  return result;
}

//----- (000000014003C208) ----------------------------------------------------
__int64 __fastcall sub_14003C208(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  v3 = -889751078;
  *(a2 + 16) = 0i64;
  v4 = 0i64;
  v5 = 48i64;
  *(a2 + 32) = 0i64;
  *(a2 + 48) = 0;
  do
  {
    *(a2 + v4) = *(a1 + v4) ^ v3;
    v4 += 4i64;
    v3 = -(((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13) ^ (32 * (((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13))));
  }
  while ( v4 < 0x30 );
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v5) = *(a1 + v5) ^ v6;
    ++v5;
  }
  while ( v5 < 0x32 );
  return result;
}

//----- (000000014003C2A0) ----------------------------------------------------
__int64 __fastcall sub_14003C2A0(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r9
  unsigned __int64 i; // r11
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0;
  *(a2 + 20) = 0;
  v3 = -453411399;
  v4 = 20i64;
  for ( i = 0i64; i < 0x14; i += 4i64 )
  {
    *(a2 + i) = *(a1 + i) ^ v3;
    v3 = __ROL4__(((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13) ^ (32 * (((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13))), 1);
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v4) = *(a1 + v4) ^ v6;
    ++v4;
  }
  while ( v4 < 0x16 );
  return result;
}

//----- (000000014003C334) ----------------------------------------------------
__int64 __fastcall sub_14003C334(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r9
  unsigned __int64 i; // r11
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 24) = 0;
  v3 = 1783959586;
  v4 = 24i64;
  for ( i = 0i64; i < 0x18; i += 4i64 )
  {
    *(a2 + i) = *(a1 + i) ^ v3;
    v3 = __ROL4__(((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13) ^ (32 * (((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13))), 4);
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v4) = *(a1 + v4) ^ v6;
    ++v4;
  }
  while ( v4 < 0x1A );
  return result;
}

//----- (000000014003C3C8) ----------------------------------------------------
__m128 *__fastcall sub_14003C3C8(__int64 a1, __m128 *a2)
{
  int v4; // r8d
  unsigned __int64 i; // rdx
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x64ui64);
  v4 = 1274721298;
  for ( i = 0i64; i < 25; ++i )
  {
    v4 = __ROL4__(1140671485 * v4 + 12820163, 3);
    result = a2;
    a2->m128_i32[i] = *(a1 + i * 4) ^ v4;
  }
  return result;
}

//----- (000000014003C434) ----------------------------------------------------
__m128 *__fastcall sub_14003C434(__int64 a1, __m128 *a2)
{
  unsigned int v4; // r8d
  unsigned __int64 i; // rdx
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x54ui64);
  v4 = -1447583250;
  for ( i = 0i64; i < 21; ++i )
  {
    v4 = ~(((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7) ^ ((((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7)) >> 13));
    result = a2;
    a2->m128_i32[i] = *(a1 + i * 4) ^ v4;
  }
  return result;
}

//----- (000000014003C4AC) ----------------------------------------------------
__m128 *__fastcall sub_14003C4AC(__int64 a1, __m128 *a2)
{
  int v4; // r8d
  unsigned __int64 i; // rdx
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x4Cui64);
  v4 = -2132421846;
  for ( i = 0i64; i < 19; ++i )
  {
    v4 = __ROR4__(214013 * v4 + 2531011, 2);
    result = a2;
    a2->m128_i32[i] = *(a1 + i * 4) ^ v4;
  }
  return result;
}

//----- (000000014003C518) ----------------------------------------------------
__m128 *__fastcall sub_14003C518(__int64 a1, __m128 *a2)
{
  unsigned __int64 v4; // rdx
  unsigned int v5; // r8d
  unsigned __int64 v6; // r9
  char v7; // cl
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x5Aui64);
  v4 = 0i64;
  v5 = 1740724346;
  v6 = 88i64;
  do
  {
    a2->m128_i32[v4] = *(a1 + v4 * 4) ^ v5;
    ++v4;
    v5 = -(((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7) ^ ((((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7)) >> 13));
  }
  while ( v4 < 22 );
  do
  {
    v7 = v5;
    v5 >>= 8;
    result = a2;
    a2->m128_i8[v6] = *(a1 + v6) ^ v7;
    ++v6;
  }
  while ( v6 < 0x5A );
  return result;
}

//----- (000000014003C5BC) ----------------------------------------------------
__m128 *__fastcall sub_14003C5BC(__int64 a1, __m128 *a2)
{
  int v4; // r8d
  unsigned __int64 i; // rdx
  __m128 *result; // rax

  EAC_memset(a2, 0, 0x84ui64);
  v4 = 877649506;
  for ( i = 0i64; i < 33; ++i )
  {
    v4 = __ROR4__(214013 * v4 + 2531011, 3);
    result = a2;
    a2->m128_i32[i] = *(a1 + i * 4) ^ v4;
  }
  return result;
}

//----- (000000014003C62C) ----------------------------------------------------
__int64 __fastcall sub_14003C62C(__int64 a1, __int64 a2)
{
  int v2; // r8d
  unsigned __int64 v3; // r9
  __int64 result; // rax

  *a2 = 0i64;
  v2 = 1508012553;
  v3 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 32) = 0;
  do
  {
    v2 = __ROL4__(214013 * v2 + 2531011, 4);
    result = a2;
    *(a2 + v3) = *(a1 + v3) ^ v2;
    v3 += 4i64;
  }
  while ( v3 < 0x24 );
  return result;
}

//----- (000000014003C680) ----------------------------------------------------
__int64 __fastcall sub_14003C680(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r11
  unsigned __int64 v5; // r9
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  v3 = 66421458;
  *(a2 + 16) = 0i64;
  v4 = 0i64;
  v5 = 48i64;
  *(a2 + 32) = 0i64;
  *(a2 + 48) = 0;
  do
  {
    *(a2 + v4) = *(a1 + v4) ^ v3;
    v4 += 4i64;
    v3 = -(((v3 ^ (v3 >> 7)) << 9) ^ v3 ^ (v3 >> 7) ^ ((((v3 ^ (v3 >> 7)) << 9) ^ v3 ^ (v3 >> 7)) >> 13));
  }
  while ( v4 < 0x30 );
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v5) = *(a1 + v5) ^ v6;
    ++v5;
  }
  while ( v5 < 0x32 );
  return result;
}

//----- (000000014003C718) ----------------------------------------------------
__int64 __fastcall sub_14003C718(__int64 a1, __int64 a2)
{
  int v2; // r9d
  unsigned __int64 v3; // r8
  __int64 result; // rax

  *a2 = 0i64;
  v2 = 2095673433;
  v3 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 32) = 0i64;
  *(a2 + 48) = 0;
  do
  {
    v2 = -15298649 - 31977 * v2;
    result = a2;
    *(a2 + v3) = *(a1 + v3) ^ v2;
    v3 += 4i64;
  }
  while ( v3 < 0x34 );
  return result;
}

//----- (000000014003C770) ----------------------------------------------------
__int64 __fastcall sub_14003C770(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r9
  unsigned __int64 i; // r11
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 24) = 0;
  v3 = 160186705;
  v4 = 24i64;
  for ( i = 0i64; i < 0x18; i += 4i64 )
  {
    *(a2 + i) = *(a1 + i) ^ v3;
    v3 = __ROR4__(((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13) ^ ((((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13)) << 17), 1);
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v4) = *(a1 + v4) ^ v6;
    ++v4;
  }
  while ( v4 < 0x1A );
  return result;
}

//----- (000000014003C804) ----------------------------------------------------
__int64 __fastcall sub_14003C804(__int64 a1, __int64 a2, __int64 *a3)
{
  int v4; // edi
  bool v5; // r14
  __int64 CurrentProcess; // rax
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 *v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r15
  __int64 *i; // rax
  int v14; // edi
  int v15; // edi
  int v16; // edi
  __int64 *v17; // r9
  __int64 *v18; // r8
  unsigned int v19; // eax
  int v20; // edi
  unsigned int v22; // [rsp+20h] [rbp-28h]

  v4 = a2;
  v22 = 0;
  v5 = 0;
  if ( !a2 || !a3 )
    return v22;
  CurrentProcess = Get_PsGetCurrentProcess();
  v7 = Get_PsGetProcessId(CurrentProcess);
  v9 = sub_14000D7E8(v7);
  if ( !v9 )
  {
    v10 = Get_PsGetCurrentProcess();
    v11 = Get_PsGetProcessId(v10);
    v12 = v11;
    if ( dword_140083578 && v11 && KeGetCurrentIrql() <= 1u )
    {
      ExAcquireFastMutex(&stru_140083540);
      for ( i = qword_140083530; i != &qword_140083530; i = *i )
      {
        v9 = i - 76;
        if ( *(i - 73) == v12 )
          goto LABEL_13;
      }
      v9 = 0i64;
LABEL_13:
      if ( !v9 || *(v9 + 604) )
        v9 = 0i64;
      else
        ++*(v9 + 150);
      ExReleaseFastMutex(&stru_140083540);
      v5 = v9 != 0i64;
    }
    else
    {
      v9 = 0i64;
    }
  }
  v14 = v4 - 1;
  if ( !v14 )
  {
    v20 = 0;
    if ( dword_140083190 > 0 && sub_14003A390(a3) )
      v20 = -1073740541;
    v22 = v20;
    goto LABEL_31;
  }
  v15 = v14 - 7;
  if ( v15 )
  {
    v16 = v15 - 4;
    if ( v16 )
    {
      if ( v16 != 16 )
        goto LABEL_31;
      v17 = a3;
      v18 = 0i64;
    }
    else
    {
      v17 = 0i64;
      v18 = a3;
    }
    LOBYTE(v8) = v5;
    v19 = sub_14003A8DC(v9, v8, v18, v17);
  }
  else
  {
    v19 = sub_14003B1E0(v9, v5, a3);
  }
  v22 = v19;
LABEL_31:
  if ( v9 )
    sub_14000D924(v9);
  return v22;
}
// 14003C926: variable 'v8' is possibly undefined
// 14000D924: using guessed type __int64 __fastcall sub_14000D924(_QWORD);
// 14003A8DC: using guessed type __int64 __fastcall sub_14003A8DC(_QWORD, _QWORD, _QWORD, _QWORD);
// 140083190: using guessed type int dword_140083190;
// 140083530: using guessed type __int64 qword_140083530;
// 140083578: using guessed type int dword_140083578;

//----- (000000014003CE7C) ----------------------------------------------------
char EAC_Get_Imports()
{
  __int64 ntoskrnlbase; // rax
  __int64 v1; // rbx
  __int64 v2; // rcx
  unsigned int *v3; // rdx
  __int64 v4; // rax
  __int64 NtHeaders; // [rsp+30h] [rbp+8h] BYREF

  ntoskrnlbase = Ge_ntoskrnl_base();
  g_ntoskrnlbase = ntoskrnlbase;
  v1 = ntoskrnlbase;
  if ( ntoskrnlbase )
  {
    if ( GetModuleInfo(ntoskrnlbase, 0x1000ui64, 0i64, &NtHeaders)
      && (v2 = *(NtHeaders + 0x88), v2)
      && *(NtHeaders + 0x8C)
      && (v3 = (v1 + v2), *(v1 + v2 + 0x14))
      && v3[8]
      && v3[7]
      && v3[9] )
    {
      qword_140085CD0 = v1 + v2;
      if ( v3 )
      {
        v4 = g_ntoskrnlbase + v3[8];
        byte_14008568A = 1;
        qword_140085CD8 = v4;
        qword_140085CE0 = g_ntoskrnlbase + v3[7];
        qword_140085CE8 = g_ntoskrnlbase + v3[9];
        (loc_14002887C)();
        sub_14000C9A8();
        (loc_14004E904)();
        (loc_1400479C8)();
        (loc_140050314)();
        (loc_14002C634)();
        sub_14002D8FC();
        sub_14001AB0C();
        (loc_140057590)();
        return 1;
      }
    }
    else
    {
      qword_140085CD0 = 0i64;
    }
  }
  return 0;
}
// 14008568A: using guessed type char byte_14008568A;
// 140085CC8: using guessed type __int64 g_ntoskrnlbase;
// 140085CD0: using guessed type __int64 qword_140085CD0;
// 140085CD8: using guessed type __int64 qword_140085CD8;
// 140085CE0: using guessed type __int64 qword_140085CE0;
// 140085CE8: using guessed type __int64 qword_140085CE8;

//----- (000000014003CF7C) ----------------------------------------------------
__int64 __fastcall sub_14003CF7C(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // r8
  unsigned __int64 i; // r9
  char v7; // cl
  unsigned __int64 j; // r8
  __int128 v9; // xmm1
  __int64 result; // rax
  __int128 v11; // xmm0
  __int128 v12; // xmm1
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  __int128 v15; // [rsp+20h] [rbp-19h] BYREF
  __int128 v16[5]; // [rsp+30h] [rbp-9h] BYREF
  __int64 v17; // [rsp+80h] [rbp+47h]

  LOBYTE(v15) = 0x80;
  EAC_memset((&v15 + 1), 0, 0x47ui64);
  v4 = *(a1 + 24);
  v5 = (-(v4 + 9) & 0x3F) + 1i64;
  for ( i = 0i64; i < 0x40; i += 8i64 )
  {
    v7 = 56 - i;
    *(&v16[-1] + v5++) = (8 * v4) >> v7;
  }
  sub_14003D0B8(a1, &v15, v5);
  *a2 = 0i64;
  *(a2 + 16) = 0;
  for ( j = 0i64; j < 0x14; ++j )
    *(j + a2) = *(a1 + 4 * (j >> 2)) >> (8 * (3 - (j & 3)));
  *&v15 = 0xEFCDAB8967452301ui64;
  *(&v15 + 1) = 0x1032547698BADCFEi64;
  LODWORD(v16[0]) = -1009589776;
  EAC_memset((v16 + 8), 0, 0x48ui64);
  LODWORD(v17) = 0;
  v9 = v16[0];
  result = a2;
  *a1 = v15;
  v11 = v16[1];
  *(a1 + 16) = v9;
  v12 = v16[2];
  *(a1 + 32) = v11;
  v13 = v16[3];
  *(a1 + 48) = v12;
  v14 = v16[4];
  *(a1 + 64) = v13;
  *&v13 = v17;
  *(a1 + 80) = v14;
  *(a1 + 96) = v13;
  return result;
}
// 14003D0B8: using guessed type __int64 __fastcall sub_14003D0B8(_QWORD, _QWORD, _QWORD);

//----- (000000014003D0B8) ----------------------------------------------------
__int64 __fastcall sub_14003D0B8(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rdi
  _BYTE *v8; // rdx
  __int64 v9; // rcx
  char v10; // al
  __int64 v11; // r14
  int v12; // r8d
  unsigned __int8 *v13; // r9
  __int64 v14; // r10
  int v15; // eax
  int v16; // ecx
  int v17; // ecx
  _BYTE *v18; // rcx
  char v19; // al
  __m128 v21[4]; // [rsp+20h] [rbp-58h] BYREF

  v3 = 0i64;
  v5 = *(a1 + 24) & 0x3Fi64;
  *(a1 + 24) += a3;
  if ( v5 + a3 >= 0x40 )
  {
    do
    {
      if ( v5 )
      {
        v8 = (v5 + a1 + 32);
        v9 = 64 - v5;
        do
        {
          v10 = *(v3 + a2);
          ++v3;
          *v8++ = v10;
          --v9;
        }
        while ( v9 );
        v11 = a1 + 32;
        v5 = 0i64;
      }
      else
      {
        v11 = v3 + a2;
        v3 += 64i64;
      }
      EAC_memset(v21, 0, 0x40ui64);
      v12 = *(a1 + 96);
      v13 = (v11 + 2);
      v14 = 16i64;
      do
      {
        v15 = *v13;
        v16 = v13[1];
        v13 += 4;
        v17 = *(v13 - 6) | ((*(v13 - 5) | ((v15 | (v16 << 8)) << 8)) << 8);
        if ( !v12 )
          v12 = 1819957430;
        v12 = -2531012 - 214013 * v12;
        *(a1 + 96) = v12;
        *&v13[v21 - v11 - 6] = v17 ^ v12;
        --v14;
      }
      while ( v14 );
      sub_140010DD8(a1, v21);
    }
    while ( a3 >= v3 + 64 );
  }
  if ( v3 < a3 )
  {
    v18 = (v5 + a1 + 32);
    do
    {
      v19 = *(v3 + a2);
      ++v3;
      *v18++ = v19;
    }
    while ( v3 < a3 );
  }
  return a1;
}
// 14003D103: conditional instruction was optimized away because rdi.8 is in (1..3F)
// 14003D0B8: using guessed type __m128 var_58[4];

//----- (000000014003D208) ----------------------------------------------------
bool __fastcall sub_14003D208(__int64 a1, int a2, int a3, int a4, int a5, int a6, int a7, __int64 a8)
{
  __int64 Memory; // rax

  if ( *(a1 + 8i64 * a5) )
    return 0;
  Memory = EAC_Allocate_Memory(0x28ui64);
  if ( Memory )
  {
    *(Memory + 4) = a6;
    *(Memory + 8) = a7;
    *(Memory + 16) = a8;
    *Memory = a5;
    *(Memory + 24) = a3;
    *(Memory + 28) = a4;
    *(Memory + 32) = a2;
    *(a1 + 8i64 * a5) = Memory;
  }
  return Memory != 0;
}

//----- (000000014003D294) ----------------------------------------------------
char __fastcall sub_14003D294(int a1)
{
  char *v2; // rbx
  unsigned __int64 v3; // rdi
  char *v4; // rbx
  unsigned __int64 v5; // rdi

  v2 = &unk_1400742B4;
  v3 = 0i64;
  while ( sub_14003D208(a1, *(v2 - 5), *(v2 - 4), *(v2 - 3), *(v2 - 2), *(v2 - 1), *v2, *(v2 + 4)) )
  {
    v3 += 40i64;
    v2 += 40;
    if ( v3 >= 0x1860 )
    {
      v4 = &unk_140075B04;
      v5 = 0i64;
      while ( sub_14003D208(a1, *(v4 - 1), *v4, 4, **(v4 + 20), 0, 0, *(v4 + 20) + 4i64) )
      {
        v5 += 40i64;
        v4 += 40;
        if ( v5 >= 0x4B0 )
          return 1;
      }
      return 0;
    }
  }
  return 0;
}
// 14003D208: using guessed type __int64 __fastcall sub_14003D208(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (000000014003D35C) ----------------------------------------------------
__int64 __fastcall sub_14003D35C(__int64 a1, int a2, int a3, _BYTE *a4, unsigned int a5, int a6)
{
  _DWORD *v6; // r11
  int v7; // eax
  __int64 v8; // r11

  if ( a1
    && (v6 = *(a1 + 8i64 * a6)) != 0i64
    && *v6 == a6
    && v6[2] == a5
    && v6[6] == a2
    && v6[7] == a3
    && (v7 = EAC_HashCR32(a4, a5), *(v8 + 4) == v7) )
  {
    return *(v8 + 32);
  }
  else
  {
    return 0i64;
  }
}
// 14003D3A1: variable 'v8' is possibly undefined

//----- (000000014003D3BC) ----------------------------------------------------
__int64 __fastcall sub_14003D3BC(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // r14
  int v8; // edi
  unsigned int *i; // rsi
  unsigned int v10; // ecx
  __int64 v11; // r11
  int v12; // eax
  int v13; // eax
  unsigned int v15; // edx
  int v16; // r8d

  v4 = qword_1400832A0;
  if ( !qword_1400832A0 || !a3 || !a4 )
    return 0i64;
  v8 = 0;
  for ( i = (a3 + 8); ; i += 4 )
  {
    v10 = i[1];
    v11 = *(v4 + 8i64 * v10);
    if ( !v11 || *v11 != v10 || *(v11 + 24) != a2 )
      goto LABEL_17;
    v12 = *(v11 + 28);
    if ( v12 != 1 )
      break;
    if ( *(v11 + 8) == *i )
    {
      v13 = EAC_HashCR32(*(i - 1), *i);
      if ( *(v11 + 4) == v13 )
        return *(v11 + 32);
    }
LABEL_17:
    if ( ++v8 >= a4 )
      return 0i64;
  }
  if ( v12 != 4 )
    goto LABEL_17;
  v15 = v8 + 1;
  if ( v8 + 1 >= a4 )
    goto LABEL_17;
  while ( 1 )
  {
    v16 = *(*(v11 + 16) + 4i64 * (v15 + ~v8));
    if ( !v16 )
      return *(v11 + 32);
    if ( v16 == *(a3 + 16i64 * v15 + 12) && ++v15 < a4 )
      continue;
    goto LABEL_17;
  }
}
// 14003D402: conditional instruction was optimized away because ebx.4!=0
// 14003D440: variable 'v11' is possibly undefined
// 1400832A0: using guessed type __int64 qword_1400832A0;

//----- (000000014003D4A8) ----------------------------------------------------
__int64 __fastcall sub_14003D4A8(__int64 NtHeaders, char *Buffer, unsigned __int64 Lenght)
{
  unsigned int ret; // ebx
  _OWORD *Allocate; // rax MAPDST
  __int64 v8; // rax
  __int64 v9; // rax
  _QWORD *v10; // rcx
  unsigned __int64 v11; // rdi
  int v12; // r8d
  __int64 v13; // rdx
  char v15[20]; // [rsp+28h] [rbp-59h] BYREF
  int v16[6]; // [rsp+40h] [rbp-41h] BYREF
  __m128 v17[4]; // [rsp+58h] [rbp-29h] BYREF
  int v18; // [rsp+A0h] [rbp+1Fh]
  char v19[32]; // [rsp+A8h] [rbp+27h] BYREF

  ret = 0;
  if ( !qword_1400832A0 || !Buffer || Lenght - 328 > 0xFFFFFEB7 )
    return 0i64;

  Allocate = EAC_Allocate_Memory(Lenght);
  if ( Allocate )
  {
    EAC_memcpy(Allocate, Buffer, Lenght);
    if ( GetModuleInfo(Allocate, Lenght, 0i64, &NtHeaders) )
    {
      v16[0] = 1732584193;
      v16[1] = -271733879;
      v16[2] = -1732584194;
      *(NtHeaders + 0x30) = 0x10000i64;
      v16[3] = 271733878;
      v16[4] = -1009589776;
      EAC_memset(v17, 0, 0x48ui64);
      v18 = 0;
      v8 = sub_140010C68(v16, Allocate, 0x148ui64);
      v9 = sub_140010B2C(v8, v19);
      v10 = &unk_140074250;
      v11 = 0i64;
      v12 = *(v9 + 16);
      *v15 = *v9;
      while ( 1 )
      {
        v13 = v10[4];
        if ( *v13 == *v15 && *(v13 + 8) == *&v15[8] && *(v13 + 16) == v12 )
          break;
        v11 += 40i64;
        v10 += 5;
        if ( v11 >= 0x50 )
          goto LABEL_13;
      }
      ret = *v10;
LABEL_13:
      memset(v15, 0, sizeof(v15));
    }
    memset(Allocate, 0, Lenght);
    Get_ExFreePool(Allocate);
  }
  return ret;
}
// 1400832A0: using guessed type __int64 qword_1400832A0;
// 14003D4A8: using guessed type __m128 var_80[4];
// 14003D4A8: using guessed type char var_30[32];

//----- (000000014003DF80) ----------------------------------------------------
char sub_14003DF80()
{
  unsigned __int64 v0; // rdi
  unsigned int v1; // edx
  char v2; // dl
  char result; // al
  int v4[11]; // [rsp+20h] [rbp-60h]
  __int128 v5[3]; // [rsp+4Ch] [rbp-34h] BYREF

  v0 = 0i64;
  if ( KUSER_SHARED_DATA.NtMajorVersion != 6 || KUSER_SHARED_DATA.NtMinorVersion != 1 )
    return 0;
  if ( byte_1400864BC )
    goto LABEL_8;
  v4[0] = -193336231;
  v1 = -1038488098;
  v4[1] = -995816395;
  v4[2] = 1907398744;
  v4[3] = -1477005977;
  v4[4] = -1457153636;
  v4[5] = -828038383;
  v4[6] = -515466186;
  v4[7] = 1497094857;
  v4[8] = 1456113243;
  v4[9] = -56994432;
  v4[10] = 15526258;
  memset(v5, 0, 44);
  do
  {
    v1 = ~(((v1 ^ (v1 << 13)) >> 17) ^ v1 ^ (v1 << 13) ^ (32 * (((v1 ^ (v1 << 13)) >> 17) ^ v1 ^ (v1 << 13))));
    *(v5 + v0) = *(v4 + v0) ^ v1;
    v0 += 4i64;
  }
  while ( v0 < 0x2C );
  LOBYTE(v0) = 1;
  if ( !EAC_Get_User_Module(v5) )
LABEL_8:
    v2 = 0;
  else
    v2 = 1;
  if ( (v0 & 1) != 0 )
    memset(v5, 0, 0x2Cui64);
  result = byte_1400864BC;
  if ( v2 )
    result = 1;
  byte_1400864BC = result;
  return result;
}
// 1400864BC: using guessed type char byte_1400864BC;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014003E0C8) ----------------------------------------------------
__int64 __fastcall sub_14003E0C8(UNICODE_STRING *unicode_string)
{
  unsigned int idx; // ebx
  __int64 ret; // rsi
  __int64 ObjectType; // rdi
  int v4; // r8d
  int v5; // r9d
  unsigned int DeviceObjectListSize; // r14d
  __int64 Allocate; // rax MAPDST
  int v10; // [rsp+40h] [rbp-30h] BYREF
  __int64 v11; // [rsp+48h] [rbp-28h]
  UNICODE_STRING *v12; // [rsp+50h] [rbp-20h]
  int v13; // [rsp+58h] [rbp-18h]
  __int128 v14; // [rsp+60h] [rbp-10h]
  int NumberDeviceObjects; // [rsp+A0h] [rbp+30h] BYREF
  PVOID Object; // [rsp+A8h] [rbp+38h] BYREF
  unsigned __int64 Handle; // [rsp+B0h] [rbp+40h]

  idx = 0;
  NumberDeviceObjects = 0;
  ret = 0i64;
  if ( !unicode_string || !unicode_string->Buffer || !unicode_string->Length || !unicode_string->MaximumLength )
    return 0i64;

  v10 = 48;
  v14 = 0i64;
  v11 = 0i64;
  v13 = 576;
  v12 = unicode_string;
  ObjectType = sub_14004CB58();
  if ( ObjectType && sub_1400507B8(&v10, ObjectType, v4, v5, 0x80000000) >= 0 )
  {
    if ( Get_ObReferenceObjectByHandle(Handle, 1u, ObjectType, 0, &Object, 0i64) >= 0 )
    {
      if ( Get_IoEnumerateDeviceObjectList(Object, 0i64, 0, &NumberDeviceObjects) == 0xC0000023 )
      {
        if ( NumberDeviceObjects )
        {
          DeviceObjectListSize = 8 * NumberDeviceObjects;
          Allocate = EAC_Allocate_Memory((8 * NumberDeviceObjects));
          if ( Allocate )
          {
            if ( Get_IoEnumerateDeviceObjectList(Object, Allocate, DeviceObjectListSize, &NumberDeviceObjects) >= 0 )
            {
              if ( NumberDeviceObjects )
              {
                ret = *(Allocate + 8i64 * (NumberDeviceObjects - 1));
                if ( NumberDeviceObjects != 1 )
                {
                  do
                    ObfDereferenceObject(*(Allocate + 8i64 * idx++));
                  while ( idx < NumberDeviceObjects - 1 );
                }
              }
            }
            Get_ExFreePool(Allocate);
          }
        }
      }
      ObfDereferenceObject(Object);
    }
    Get_NtClose(Handle);
  }
  return ret;
}
// 14003E14A: variable 'v4' is possibly undefined
// 14003E14A: variable 'v5' is possibly undefined

//----- (000000014003E224) ----------------------------------------------------
// from @Swiftik
char __fastcall EAC_GetFirstNetworkDeviceMacAddress(__int64 a1, void *a2, unsigned int *a3)
{
  __int64 v4; // r14
  char v5; // si
  int (__fastcall *v6)(void *, _QWORD, __int64, PVOID *); // rax
  __int64 v7; // r8
  char *Buffer; // rcx
  char *v9; // rbx
  unsigned __int64 v10; // r8
  unsigned int v11; // edx
  unsigned __int64 v12; // rdi
  char *v13; // r8
  __int64 v14; // rax
  __int64 i; // r14
  char *v16; // rbx
  unsigned __int64 v17; // r8
  int v18; // edx
  unsigned __int64 v19; // rdi
  char *v20; // r8
  __int64 idx; // rax
  __int64 v22; // rdi
  WCHAR *v23; // rdx
  char v24; // al
  __int64 v25; // rdx
  int v27[4]; // [rsp+20h] [rbp-50h]
  int v28[4]; // [rsp+30h] [rbp-40h]
  _UNICODE_STRING unicode_string; // [rsp+40h] [rbp-30h] BYREF
  __int128 Buf; // [rsp+50h] [rbp-20h] BYREF
  __int128 v31; // [rsp+60h] [rbp-10h] BYREF
  PVOID P; // [rsp+B8h] [rbp+48h] BYREF
  __int128 *p_Buf; // [rsp+C8h] [rbp+58h]

  P = a2;
  v4 = 0i64;
  v5 = 1;
  if ( KeGetCurrentIrql() )
    return 0;

  v6 = (loc_14005B768)(qword_140083508, &qword_140083508, 0i64);
  if ( !v6 || v6(&unk_14007D778, 0i64, v7, &P) < 0 )
    return 0;

  Buffer = P;
  do
  {
    v9 = &Buffer[2 * v4];
    if ( !*v9 )
      break;

    v10 = -1i64;

    do
      ++v10;
    while ( *&v9[2 * v10] );

    v27[0] = 1308437771;
    v27[1] = -834542836;
    Buf = 0i64;
    v27[2] = 1699318683;
    v11 = 423653385;
    v27[3] = -740494419;
    v12 = 0i64;
    p_Buf = &Buf;

    do
    {
      v11 = -(((v11 ^ (v11 << 13)) >> 7) ^ v11 ^ (v11 << 13) ^ ((((v11 ^ (v11 << 13)) >> 7) ^ v11 ^ (v11 << 13)) << 17));
      *(p_Buf + v12 * 4) = v27[v12] ^ v11;
      ++v12;
    }
    while ( v12 < 4 );

    v13 = sub_14005D7E4(v9, &Buf, v10);
    memset(&Buf, 0, sizeof(Buf));

    if ( v13 == v9 )
    {
      Get_Unicode_string_Inline(&unicode_string, v9);
      v5 = sub_14000F8A0(0i64, &unicode_string, a3);
    }

    Buffer = P;
    v14 = -1i64;

    do
      ++v14;
    while ( *(P + v4 + v14) );

    v4 += v14 + 1;
  }
  while ( v5 );

  for ( i = 0i64; v5; i += idx + 1 )
  {
    v16 = &Buffer[2 * i];
    if ( !*v16 )
      break;
    v17 = -1i64;

    do
      ++v17;
    while ( *&v16[2 * v17] );

    v28[0] = -1038501254;
    v28[1] = -302424194;
    v31 = 0i64;
    v28[2] = -321415352;
    v18 = 1134667778;
    v28[3] = -1668660807;
    v19 = 0i64;
    p_Buf = &v31;

    do
    {
      v18 = __ROL4__(17313 * v18 + 10594306, 3);
      *(p_Buf + v19 * 4) = v28[v19] ^ v18;
      ++v19;
    }
    while ( v19 < 4 );

    v20 = sub_14005D7E4(v16, &v31, v17);
    memset(&v31, 0, sizeof(v31));
    if ( v20 == v16 )
    {
      Get_Unicode_string_Inline(&unicode_string, v16);
      v5 = sub_14000F8A0(1i64, &unicode_string, a3);
    }
    Buffer = P;
    idx = -1i64;

    do
      ++idx;
    while ( *(P + i + idx) );
  }
  v22 = 0i64;
  if ( v5 )
  {
    do
    {
      v23 = &Buffer[2 * v22];
      if ( !*v23 )
        break;

      Get_Unicode_string_Inline(&unicode_string, v23);
      v24 = sub_14000F8A0(2i64, &unicode_string, a3);
      Buffer = P;
      v25 = -1i64;

      do
        ++v25;
      while ( *(P + v22 + v25) );

      v22 += v25 + 1;
    }
    while ( v24 );
  }
  ExFreePoolWithTag(Buffer, 0);
  return 1;
}
// 14003E289: variable 'v7' is possibly undefined
// 140083508: using guessed type __int64 qword_140083508;

//----- (000000014003E4E0) ----------------------------------------------------
NTSTATUS __fastcall EAC_Send_Irp(
        unsigned int IoControlCode,
        struct _DEVICE_OBJECT *DeviceObject,
        __int64 InputBuffer,
        unsigned int InputBufferLength,
        __int64 OutputBuffer,
        int OutputBufferLength)
{
  NTSTATUS result; // eax
  __int64 (__fastcall *g_IoBuildDeviceIoControlRequest)(_QWORD, struct _DEVICE_OBJECT *, __int64, _QWORD, __int64, int, char, struct _KEVENT *, int *); // rax
  char InternalDeviceIoControl; // r8
  IRP *Irp; // rax
  int IoStatusBlock[4]; // [rsp+50h] [rbp-38h] BYREF
  struct _KEVENT Event; // [rsp+60h] [rbp-28h] BYREF

  if ( !DeviceObject )
    return 0xC000000D;

  if ( KeGetCurrentIrql() || Get_KeAreAllApcsDisabled() )
    return 0xC0000148;

  KeInitializeEvent(&Event, NotificationEvent, 0);

  g_IoBuildDeviceIoControlRequest = (loc_14005B768)(qword_1400834F0, &qword_1400834F0, 0i64);
  if ( !g_IoBuildDeviceIoControlRequest )
    return 0xC0000017;

  Irp = g_IoBuildDeviceIoControlRequest(
          IoControlCode,
          DeviceObject,
          InputBuffer,
          InputBufferLength,
          OutputBuffer,
          OutputBufferLength,
          InternalDeviceIoControl,
          &Event,
          IoStatusBlock);
  if ( !Irp )
    return 0xC0000017;

  result = IofCallDriver(DeviceObject, Irp);
  if ( result == 259 )
  {
    Get_KeWaitForSingleObject(&Event);
    return IoStatusBlock[0];
  }
  return result;
}
// 14003E591: variable 'InternalDeviceIoControl' is possibly undefined
// 1400834F0: using guessed type __int64 qword_1400834F0;
// 14003E4E0: using guessed type int IoStatusBlock[4];

//----- (000000014003E5E8) ----------------------------------------------------
char sub_14003E5E8()
{
  char v0; // cl

  if ( !KeAreApcsDisabled() )
    return 0;
  v0 = 1;
  if ( !KeGetCurrentIrql() )
    return 0;
  return v0;
}

//----- (000000014003E60C) ----------------------------------------------------
char __fastcall sub_14003E60C(
        __int64 a1,
        unsigned int a2,
        unsigned int a3,
        unsigned __int8 (__fastcall *a4)(char *, char *))
{
  unsigned __int64 v4; // rsi
  char *Memory; // rbx
  unsigned int i; // r14d
  unsigned int v10; // edi
  char *v12; // [rsp+20h] [rbp-38h]
  unsigned int v13; // [rsp+60h] [rbp+8h]

  v4 = a2;
  if ( !a1 )
    return 0;
  if ( !a3 )
    return 0;
  if ( !a4 )
    return 0;
  Memory = EAC_Allocate_Memory(a2);
  if ( !Memory )
    return 0;
  for ( i = 1; i < a3; ++i )
  {
    EAC_memcpy(Memory, (a1 + v4 * i), v4);
    v10 = i;
    do
    {
      v13 = v10 - 1;
      v12 = (a1 + v4 * (v10 - 1));
      if ( !a4(Memory, v12) )
        break;
      EAC_memcpy((a1 + v4 * v10--), v12, v4);
    }
    while ( v13 );
    EAC_memcpy((a1 + v4 * v10), Memory, v4);
  }
  Get_ExFreePool(Memory);
  return 1;
}

//----- (000000014003E708) ----------------------------------------------------
__int64 Ge_ntoskrnl_base()
{
  _QWORD *PoolWithTag; // rax
  _QWORD *Data; // rbx
  ULONG SystemInformation; // [rsp+30h] [rbp+8h] BYREF

  SystemInformation = 0;
  if ( !ntoskrnlbase
    && ZwQuerySystemInformation(SystemModuleInformation, &SystemInformation, 0, &SystemInformation) == 0xC0000004 )
  {
    if ( SystemInformation )
    {
      PoolWithTag = ExAllocatePoolWithTag(NonPagedPool, SystemInformation, 'mMmS');
      Data = PoolWithTag;
      if ( PoolWithTag )
      {
        if ( ZwQuerySystemInformation(SystemModuleInformation, PoolWithTag, SystemInformation, &SystemInformation) >= 0
          && *Data )
        {
          ntoskrnlbase = Data[3];
        }
        ExFreePoolWithTag(Data, 0x6D4D6D53u);
      }
    }
  }
  return ntoskrnlbase;
}
// 1400864D8: using guessed type __int64 ntoskrnlbase;

//----- (000000014003E7A4) ----------------------------------------------------
__int64 Get_ntoskrnl_Size()
{
  _DWORD *System_Information; // rax

  System_Information = Get_System_Information();
  if ( System_Information )
  {
    if ( *System_Information )
      g_ModSize = System_Information[8];
    Get_ExFreePool(System_Information);
  }
  return g_ModSize;
}
// 1400864D4: using guessed type int g_ModSize;

//----- (000000014003E7D4) ----------------------------------------------------
__int64 __fastcall sub_14003E7D4(CHAR *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rax
  _DWORD *System_Information; // rax
  _DWORD *v5; // rdi
  int v6; // esi
  _DWORD *v7; // rbp
  CHAR *v8; // rcx
  __int64 v9; // rax
  STRING String2; // [rsp+20h] [rbp-28h] BYREF
  STRING String1; // [rsp+30h] [rbp-18h] BYREF

  v1 = 0i64;
  if ( !a1 )
    return 0i64;
  String1.Buffer = a1;
  v3 = -1i64;
  do
    ++v3;
  while ( a1[v3] );
  String1.Length = v3;
  String1.MaximumLength = v3 + 1;
  System_Information = Get_System_Information();
  v5 = System_Information;
  if ( System_Information )
  {
    v6 = 0;
    if ( *System_Information )
    {
      while ( 1 )
      {
        v7 = &v5[74 * v6];
        if ( *(v7 + 3) >= MmSystemRangeStart )
        {
          v8 = v7 + *(v7 + 23) + 48;
          String2.Buffer = v8;
          if ( v8 )
          {
            v9 = -1i64;
            do
              ++v9;
            while ( v8[v9] );
            String2.Length = v9;
            String2.MaximumLength = v9 + 1;
          }
          else
          {
            *&String2.Length = 0;
          }
          if ( !RtlCompareString(&String1, &String2, 1u) )
            break;
        }
        if ( ++v6 >= *v5 )
          goto LABEL_17;
      }
      v1 = *(v7 + 3);
    }
LABEL_17:
    Get_ExFreePool(v5);
  }
  return v1;
}

//----- (000000014003ECFC) ----------------------------------------------------
// from @Swiftik
char __fastcall EAC_GetNtoskrnlSection(__int64 szSection, _QWORD *SectionBase, _QWORD *SectionSize)
{
  char ret; // bl
  __int64 ntoskrnlbase; // r8
  __int64 v8; // rcx
  unsigned __int64 v9; // r9
  __int64 v10; // rdx
  unsigned __int64 v11; // rax
  __int64 v12; // rcx

  ret = 0;
  if ( !SectionBase )
    return 0;

  if ( !SectionSize )
    return 0;

  *SectionBase = 0i64;
  *SectionSize = 0i64;
  ntoskrnlbase = Ge_ntoskrnl_base();

  if ( !ntoskrnlbase )
    return 0;

  if ( *ntoskrnlbase != 0x5A4D )
    return 0;

  v8 = ntoskrnlbase + *(ntoskrnlbase + 0x3C);
  if ( *v8 != 0x4550 )
    return 0;

  v9 = *(v8 + 6);
  v10 = *(v8 + 20) + v8 + 0x18;
  v11 = 0i64;
  if ( *(v8 + 6) )
  {
    while ( 1 )
    {
      v12 = *(v10 + 0xC);
      if ( v12 )
      {
        if ( *(v10 + 8) && *v10 == szSection )
          break;
      }
      ++v11;
      v10 += 40i64;
      if ( v11 >= v9 )
        return ret;
    }
    ret = 1;
    *SectionBase = ntoskrnlbase + v12;
    *SectionSize = *(v10 + 8);
  }
  return ret;
}

//----- (000000014003EDB4) ----------------------------------------------------
char __fastcall Check_ntoskrnl_Address(unsigned __int64 Address)
{
  char v1; // bl
  unsigned __int64 ntoskrnlbase; // rsi
  unsigned int PageSize; // eax

  v1 = 0;
  if ( Address )
  {
    ntoskrnlbase = Ge_ntoskrnl_base();
    if ( ntoskrnlbase )
    {
      PageSize = Get_ntoskrnl_Size();
      if ( PageSize )
      {
        if ( Address >= ntoskrnlbase && Address < ntoskrnlbase + PageSize )
          return 1;
      }
    }
  }
  return v1;
}

//----- (000000014003EE08) ----------------------------------------------------
__int64 __fastcall sub_14003EE08(__int64 Value)
{
  volatile ULONG64 TickCountQuad; // rbx

  TickCountQuad = KUSER_SHARED_DATA.TickCountQuad;
  return (TickCountQuad * KeQueryTimeIncrement() - Value) / 10000;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014003EE58) ----------------------------------------------------
__int64 __fastcall EAC_EncodeBuffer(int a1, int a2)
{
  unsigned __int64 v2; // rax
  int v3; // r8d
  unsigned int v5; // ecx

  LODWORD(v2) = dword_1400864D0;
  v3 = 0;

  if ( !dword_1400864D0 )
    v2 = __rdtsc();

  dword_1400864D0 = 214013 * v2 + 2531011;
  if ( a1 != a2 )
  {
    v5 = ((dword_1400864D0 ^ (dword_1400864D0 << 13)) >> 17) ^ dword_1400864D0 ^ (dword_1400864D0 << 13);
    v3 = (v5 ^ (32 * v5)) % (a2 - a1);
  }
  return (v3 + a1);
}
// 1400864D0: using guessed type int dword_1400864D0;

//----- (000000014003EEB0) ----------------------------------------------------
void __fastcall sub_14003EEB0(_BYTE *a1, __int64 a2)
{
  unsigned __int64 v2; // r9
  _BYTE *v3; // r8
  unsigned __int64 v4; // rax
  __int64 v5; // rax

  v2 = &a1[a2];
  v3 = a1;
  if ( a1 && a2 && a1 < v2 )
  {
    do
    {
      v4 = __rdtsc();
      if ( &v3[-v2] < 4 )
      {
        *v3 = v4;
        v5 = 1i64;
      }
      else
      {
        *v3 = v4;
        v5 = 4i64;
      }
      v3 += v5;
    }
    while ( v3 < v2 );
  }
}

//----- (000000014003EEF8) ----------------------------------------------------
__int64 sub_14003EEF8()
{
  __int64 (__fastcall *v0)(unsigned int *); // rax
  int v2[8]; // [rsp+20h] [rbp-20h] BYREF
  unsigned int v3; // [rsp+50h] [rbp+10h] BYREF

  v3 = EAC_Generate_Seed(0, -1);
  v0 = qword_1400864C0;
  if ( qword_1400864C0 )
    return v0(&v3);

  v2[0] = -832292377;
  v2[1] = 1764209112;
  v2[2] = 599945686;
  v2[3] = 1029941445;
  v2[4] = 643490368;
  v0 = (loc_14003CB4C)(v2);
  qword_1400864C0 = v0;
  if ( v0 )
    return v0(&v3);
  else
    return v3;
}
// 1400864C0: using guessed type __int64 qword_1400864C0;

//----- (000000014003EF64) ----------------------------------------------------
char __fastcall sub_14003EF64(struct _UNICODE_STRING *a1, _UNICODE_STRING *a2)
{
  char v3; // bl
  void *v4; // rax
  struct _UNICODE_STRING LinkTarget; // [rsp+20h] [rbp-40h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+30h] [rbp-30h] BYREF
  ULONG ReturnedLength; // [rsp+80h] [rbp+20h] BYREF
  void *LinkHandle; // [rsp+90h] [rbp+30h] BYREF
  void *v10; // [rsp+98h] [rbp+38h]

  ReturnedLength = 0;
  v3 = 0;
  LinkTarget = 0i64;
  if ( a1 )
  {
    if ( a2 )
    {
      ObjectAttributes.ObjectName = a1;
      ObjectAttributes.Length = 48;
      ObjectAttributes.RootDirectory = 0i64;
      ObjectAttributes.Attributes = 512;
      *&ObjectAttributes.SecurityDescriptor = 0i64;
      if ( ZwOpenSymbolicLinkObject(&LinkHandle, 0x80000000, &ObjectAttributes) >= 0 )
      {
        if ( ZwQuerySymbolicLinkObject(LinkHandle, &LinkTarget, &ReturnedLength) != -1073741789 )
          goto LABEL_12;
        if ( !ReturnedLength )
          goto LABEL_12;
        LinkTarget.Buffer = EAC_Allocate_Memory(ReturnedLength + 2i64);
        if ( !LinkTarget.Buffer )
          goto LABEL_12;
        LinkTarget.MaximumLength = ReturnedLength;
        LinkTarget.Length = 0;
        if ( ZwQuerySymbolicLinkObject(LinkHandle, &LinkTarget, &ReturnedLength) >= 0 )
        {
          LinkTarget.Buffer[LinkTarget.Length >> 1] = 0;
          v3 = EAC_Read_String_From_Unicode_String(a2, LinkTarget.Buffer);
          v4 = v10;
          if ( v3 )
            v4 = LinkHandle;
          v10 = v4;
        }
        Get_ExFreePool(LinkTarget.Buffer);
        if ( v3 )
          Get_NtClose(v10);
        else
LABEL_12:
          Get_NtClose(LinkHandle);
      }
    }
  }
  return v3;
}
// 14003F065: conditional instruction was optimized away because bl.1==0

//----- (000000014003F084) ----------------------------------------------------
char __fastcall sub_14003F084(WCHAR *a1, _UNICODE_STRING *a2)
{
  char v4; // bl
  unsigned __int64 v5; // r8
  unsigned int v6; // edx
  unsigned __int64 v7; // r9
  char v8; // cl
  struct _UNICODE_STRING v10; // [rsp+20h] [rbp-40h] BYREF
  int v11[5]; // [rsp+30h] [rbp-30h]
  __int16 v12; // [rsp+44h] [rbp-1Ch]
  _BYTE v13[22]; // [rsp+46h] [rbp-1Ah] BYREF

  v4 = 0;
  if ( !a1 || !a2 )
    return 0;
  *&a2->Length = 0;
  a2->Buffer = 0i64;
  *&v10.Length = 0;
  v10.Buffer = 0i64;
  if ( sub_14005D2DC(&v10, 0x100u) )
  {
    v11[0] = -314876397;
    v12 = 18611;
    v5 = 20i64;
    v11[1] = 1337249798;
    v6 = -310616497;
    v11[2] = 1948066670;
    v11[3] = 146948739;
    v7 = 0i64;
    v11[4] = 1268342525;
    memset(v13, 0, sizeof(v13));
    do
    {
      *&v13[v7 * 4] = v11[v7] ^ v6;
      ++v7;
      v6 = ~(((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13) ^ (32 * (((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13))));
    }
    while ( v7 < 5 );
    v4 = 1;
    do
    {
      v8 = v6;
      v6 >>= 8;
      v13[v5] = *(v11 + v5) ^ v8;
      ++v5;
    }
    while ( v5 < 0x16 );
    if ( sub_14005D584(&v10.Length, v13) < 0 || sub_14005D584(&v10.Length, a1) < 0 || !sub_14003EF64(&v10, a2) )
      v4 = 0;
    memset(v13, 0, sizeof(v13));
    if ( v10.Buffer )
      Get_ExFreePool(v10.Buffer);
  }
  return v4;
}

//----- (000000014003F204) ----------------------------------------------------
bool __fastcall sub_14003F204(WCHAR *a1, __int64 a2)
{
  bool v2; // bl
  __int64 v4; // rdx
  _UNICODE_STRING v6; // [rsp+20h] [rbp-18h] BYREF
  char v7; // [rsp+40h] [rbp+8h] BYREF

  v2 = 0;
  if ( !a1 || !a2 )
    return 0;
  if ( sub_14003F084(a1, &v6) )
  {
    v2 = sub_14000CCBC(&v6, v4, a2, &v7) >= 0;
    EAC_Free_UnicodeString(&v6);
  }
  return v2;
}
// 14003F238: variable 'v4' is possibly undefined
// 14003F204: using guessed type _UNICODE_STRING var_18;

//----- (000000014003F268) ----------------------------------------------------
char __fastcall sub_14003F268(struct _FILE_OBJECT *Object, _UNICODE_STRING *unicode_string)
{
  char ret; // al MAPDST
  POBJECT_NAME_INFORMATION ObjectNameInformation; // [rsp+30h] [rbp+8h] MAPDST BYREF

  ret = 0;
  if ( !Object || !unicode_string )
    return 0;

  if ( IoQueryFileDosDeviceName(Object, &ObjectNameInformation) >= 0 )
  {
    if ( ObjectNameInformation && ObjectNameInformation->Name.Buffer && ObjectNameInformation->Name.Length )
    {
      if ( ObjectNameInformation->Name.MaximumLength )
        ret = EAC_Allocate_Unicode_string(
                unicode_string,
                &ObjectNameInformation->Name.Length,
                ObjectNameInformation->Name.Length);
    }
    ExFreePoolWithTag(ObjectNameInformation, 0);
  }
  return ret;
}

//----- (000000014003F2DC) ----------------------------------------------------
char __fastcall EAC_GetFileNameInformationUnsafe(PFILE_OBJECT FileObject, _UNICODE_STRING *unicode_string)
{
  char ret; // bl MAPDST
  UNICODE_STRING *p_Name; // rdx
  PFLT_FILE_NAME_INFORMATION FileNameInformation; // [rsp+30h] [rbp+8h] MAPDST BYREF

  ret = 0;
  if ( !FileObject || !unicode_string || KeGetCurrentIrql() > 1u || IoGetTopLevelIrp() )
    return 0;

  if ( FltGetFileNameInformationUnsafe(FileObject, 0i64, 0x101u, &FileNameInformation) >= 0
    || FltGetFileNameInformationUnsafe(FileObject, 0i64, 0x102u, &FileNameInformation) >= 0 )
  {
    p_Name = &FileNameInformation->Name;
    if ( FileNameInformation != -8i64 && FileNameInformation->Name.Buffer && p_Name->Length )
    {
      if ( FileNameInformation->Name.MaximumLength )
        ret = EAC_Allocate_Unicode_string(unicode_string, &p_Name->Length, p_Name->Length);
    }
    FltReleaseFileNameInformation(FileNameInformation);
  }
  return ret;
}

//----- (000000014003F39C) ----------------------------------------------------
char __fastcall sub_14003F39C(__int64 a1, __int16 *unicode_string)
{
  __int64 v2; // rdi
  unsigned __int16 v4; // r8
  unsigned __int16 v5; // dx
  __int64 v6; // r8
  unsigned __int16 v8; // cx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rax

  v2 = 0i64;
  if ( !a1 )
    return 0;
  if ( !*(a1 + 8) )
    return 0;
  v4 = *a1;
  if ( !*a1
    || !*(a1 + 2)
    || v4 > 0xFFEFu
    || !unicode_string
    || !EAC_Allocate_Unicode_string(unicode_string, a1, v4 + 16) )
  {
    return 0;
  }
  v5 = *unicode_string;
  if ( *unicode_string >= 8u )
  {
    v6 = *(unicode_string + 1);
    if ( *v6 == 0x5C003F005C005Ci64 )
    {
      *(v6 + 2) = 63;
      return 1;
    }
  }
  v8 = 0;
  if ( (v5 & 0xFFFE) != 0 )
  {
    do
    {
      v9 = *(unicode_string + 1);
      if ( *(v9 + 2i64 * v8) == 47 )
        *(v9 + 2i64 * v8) = 92;
      v5 = *unicode_string;
      ++v8;
    }
    while ( v8 < (*unicode_string >> 1) );
  }
  if ( v5 >= 8u )
  {
    if ( **(unicode_string + 1) == 0x5C002E005C005Ci64 )
    {
      do
      {
        *(v2 + *(unicode_string + 1) + 2) = 63;
        v2 += 2i64;
      }
      while ( v2 < 4 );
      return 1;
    }
LABEL_21:
    v10 = *(unicode_string + 1);
    if ( *v10 == 92 && *(v10 + 2) == 92 )
    {
      EAC_memcpy((v10 + 16), (v10 + 4), v5 - 4i64);
      **(unicode_string + 1) = xmmword_14007DC58;
      *unicode_string += 12;
      return 1;
    }
    goto LABEL_25;
  }
  if ( v5 >= 4u )
    goto LABEL_21;
  if ( v5 >= 2u )
  {
LABEL_25:
    v11 = *(unicode_string + 1);
    if ( *v11 != 92 && *v11 != 46 && v5 >= 3u && *(v11 + 2) == 58 && *(v11 + 4) == 92 )
    {
      EAC_memcpy((v11 + 8), *(unicode_string + 1), v5);
      **(unicode_string + 1) = 0x5C003F003F005Ci64;
      *unicode_string += 8;
      return 1;
    }
  }
  EAC_Free_UnicodeString(unicode_string);
  return 0;
}
// 14007DC58: using guessed type __int128 xmmword_14007DC58;

//----- (000000014003F558) ----------------------------------------------------
bool sub_14003F558()
{
  int v0; // edi
  unsigned __int64 v1; // rdx
  int v2; // edx
  unsigned __int64 v3; // rdi
  unsigned int v4; // edx
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rdi
  int v7; // ecx
  char v8; // cl
  int v9; // edx
  unsigned __int64 v10; // rdi
  unsigned int v11; // edx
  unsigned __int64 v12; // rdi
  int v13; // ecx
  unsigned __int64 v14; // rdi
  char v15; // cl
  unsigned int v16; // edx
  unsigned __int64 v17; // rdi
  unsigned int v18; // edx
  unsigned __int64 v19; // rdi
  int v20; // ecx
  unsigned __int64 v21; // rdi
  char v22; // cl
  unsigned int v23; // edx
  unsigned __int64 v24; // rdi
  int v25; // edx
  int v28[2]; // [rsp+20h] [rbp-E0h] BYREF
  __int16 v29; // [rsp+28h] [rbp-D8h]
  __int64 v30[2]; // [rsp+30h] [rbp-D0h] BYREF
  int v31[21]; // [rsp+40h] [rbp-C0h] BYREF
  __int16 v32; // [rsp+94h] [rbp-6Ch]
  int v33[21]; // [rsp+96h] [rbp-6Ah] BYREF
  __int16 v34; // [rsp+EAh] [rbp-16h]
  int v35[20]; // [rsp+ECh] [rbp-14h] BYREF
  int v36[21]; // [rsp+13Ch] [rbp+3Ch] BYREF
  int v37[21]; // [rsp+190h] [rbp+90h] BYREF
  int v38[31]; // [rsp+1E4h] [rbp+E4h] BYREF
  int v39[34]; // [rsp+260h] [rbp+160h] BYREF
  char v40[16]; // [rsp+2E8h] [rbp+1E8h] BYREF
  char v41[16]; // [rsp+2F8h] [rbp+1F8h] BYREF
  char v42[16]; // [rsp+308h] [rbp+208h] BYREF
  char v43[16]; // [rsp+318h] [rbp+218h] BYREF
  char v44[24]; // [rsp+328h] [rbp+228h] BYREF
  __m128 v45[6]; // [rsp+340h] [rbp+240h] BYREF
  __m128 v46[6]; // [rsp+3A0h] [rbp+2A0h] BYREF
  __m128 v47[5]; // [rsp+400h] [rbp+300h] BYREF
  __m128 v48[6]; // [rsp+450h] [rbp+350h] BYREF
  __m128 v49[6]; // [rsp+4B0h] [rbp+3B0h] BYREF
  __m128 v50[8]; // [rsp+510h] [rbp+410h] BYREF
  __m128 v51[11]; // [rsp+590h] [rbp+490h] BYREF
  char v52; // [rsp+650h] [rbp+550h] BYREF
  int *v53; // [rsp+658h] [rbp+558h]
  __m128 *v54; // [rsp+660h] [rbp+560h]

  v39[0] = 2138969687;
  v39[1] = 492943163;
  v39[2] = -1144615106;
  v39[3] = -1975717066;
  v39[4] = -150097030;
  v39[5] = 2127343115;
  v39[6] = -878390164;
  v39[7] = 2048254211;
  v39[8] = 55696670;
  v39[9] = 1182486013;
  v39[10] = -438365644;
  v39[11] = -1705329545;
  v39[12] = 1818742063;
  v39[13] = 1493384675;
  v39[14] = -678215283;
  v39[15] = 669018964;
  v39[16] = -482133336;
  v39[17] = 766485904;
  v39[18] = -1428235451;
  v39[19] = -1225828722;
  v39[20] = 427253126;
  v39[21] = 848047802;
  v39[22] = 1141167498;
  v39[23] = 1106470780;
  v39[24] = 1303375416;
  v39[25] = -1610481603;
  v39[26] = 826911296;
  v39[27] = -1670511631;
  v39[28] = 221783098;
  v39[29] = -892157352;
  v39[30] = 39407500;
  v39[31] = -1272900440;
  v39[32] = 1361491874;
  v39[33] = -1449353989;
  EAC_memset(v51, 0, 0x88ui64);
  v0 = 1318029722;
  v53 = v39;
  v1 = 0i64;
  v54 = v51;
  do
  {
    v0 = -12820163 - 1140671485 * v0;
    v54->m128_i32[v1] = v53[v1] ^ v0;
    ++v1;
  }
  while ( v1 < 34 );
  v38[0] = 1868524205;
  v38[1] = 291621502;
  v38[2] = 946635082;
  v38[3] = -644127701;
  v38[4] = -881089508;
  v38[5] = 423103995;
  v38[6] = 617266527;
  v38[7] = -1038437882;
  v38[8] = 2050936487;
  v38[9] = -354144308;
  v38[10] = 337804758;
  v38[11] = -1801742529;
  v38[12] = -1862832250;
  v38[13] = -1226350162;
  v38[14] = -1987513389;
  v38[15] = -1193273129;
  v38[16] = 152301836;
  v38[17] = -1345601370;
  v38[18] = 1946186109;
  v38[19] = 438414153;
  v38[20] = -707889336;
  v38[21] = 1583782148;
  v38[22] = -382836095;
  v38[23] = -1731568662;
  v38[24] = -1856135683;
  v38[25] = 2048987268;
  v38[26] = -622657337;
  v38[27] = 964591343;
  v38[28] = 832293173;
  v38[29] = 1846888233;
  v38[30] = 1175715337;
  EAC_memset(v50, 0, 0x7Cui64);
  v2 = 1772463230;
  v53 = v38;
  v3 = 0i64;
  v54 = v50;
  do
  {
    v2 = __ROR4__(((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13) ^ (32 * (((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13))), 3);
    v54->m128_i32[v3] = v53[v3] ^ v2;
    ++v3;
  }
  while ( v3 < 31 );
  v28[0] = -542856538;
  v29 = -6286;
  v4 = -539120910;
  v28[1] = 1982208610;
  v30[0] = 0i64;
  v5 = 0i64;
  LOWORD(v30[1]) = 0;
  v53 = v28;
  v54 = v30;
  v6 = 8i64;
  do
  {
    v7 = v53[v5] ^ v4;
    v4 = ~(1140671485 * v4 + 12820163);
    v54->m128_i32[v5++] = v7;
  }
  while ( v5 < 2 );
  v53 = v28;
  v54 = v30;
  do
  {
    v8 = v4;
    v4 >>= 8;
    v54->m128_i8[v6] = *(v53 + v6) ^ v8;
    ++v6;
  }
  while ( v6 < 0xA );
  v35[0] = 391656838;
  v35[1] = 604544685;
  v35[2] = 1247639852;
  v35[3] = 505774706;
  v35[4] = 1390701365;
  v35[5] = -1402836374;
  v35[6] = 76934297;
  v35[7] = 721477330;
  v35[8] = 438716392;
  v35[9] = 40636542;
  v35[10] = 1825496470;
  v35[11] = 1027552400;
  v35[12] = 2018357992;
  v35[13] = 979517294;
  v35[14] = 1517242504;
  v35[15] = 1192726244;
  v35[16] = -832623994;
  v35[17] = -562237314;
  v35[18] = 1222250809;
  v35[19] = -138662867;
  EAC_memset(v47, 0, 0x50ui64);
  v9 = -720878794;
  v53 = v35;
  v10 = 0i64;
  v54 = v47;
  do
  {
    v9 = __ROR4__(((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13) ^ (32 * (((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13))), 4);
    v54->m128_i32[v10] = v53[v10] ^ v9;
    ++v10;
  }
  while ( v10 < 20 );
  v31[0] = 1882525207;
  v31[1] = 411811772;
  v31[2] = -1164941667;
  v31[3] = 1554947196;
  v31[4] = 1718721870;
  v31[5] = -1176561995;
  v31[6] = 1283210610;
  v31[7] = 465459187;
  v31[8] = -869781277;
  v31[9] = 112806481;
  v31[10] = 723488614;
  v31[11] = 355840600;
  v31[12] = -480222980;
  v31[13] = -1761129928;
  v31[14] = -823406697;
  v31[15] = -778684761;
  v31[16] = -1440672640;
  v31[17] = -112740455;
  v31[18] = 1544607127;
  v31[19] = -1922334306;
  v31[20] = 768258847;
  v32 = 14627;
  EAC_memset(v46, 0, 0x56ui64);
  v11 = 1885736523;
  v53 = v31;
  v12 = 0i64;
  v54 = v46;
  do
  {
    v13 = v53[v12] ^ v11;
    v11 = __ROL4__(1140671485 * v11 + 12820163, 1);
    v54->m128_i32[v12++] = v13;
  }
  while ( v12 < 21 );
  v14 = 84i64;
  v53 = v31;
  v54 = v46;
  do
  {
    v15 = v11;
    v11 >>= 8;
    v54->m128_i8[v14] = *(v53 + v14) ^ v15;
    ++v14;
  }
  while ( v14 < 0x56 );
  v36[0] = -831072686;
  v36[1] = -464851492;
  v36[2] = 906993884;
  v36[3] = -684620724;
  v36[4] = 1646566373;
  v36[5] = -453996537;
  v36[6] = 2009712434;
  v36[7] = 1087881861;
  v36[8] = 690967013;
  v36[9] = 1172617099;
  v36[10] = -81888053;
  v36[11] = 481510421;
  v36[12] = -666716288;
  v36[13] = -1283928819;
  v36[14] = 1319694711;
  v36[15] = 103122327;
  v36[16] = -1835433668;
  v36[17] = 2045910638;
  v36[18] = 691386377;
  v36[19] = -756335106;
  v36[20] = -402067714;
  EAC_memset(v49, 0, 0x54ui64);
  v16 = 509570574;
  v53 = v36;
  v17 = 0i64;
  v54 = v49;
  do
  {
    v16 = __ROL4__(
            ((v16 ^ (v16 >> 7)) << 9) ^ v16 ^ (v16 >> 7) ^ ((((v16 ^ (v16 >> 7)) << 9) ^ v16 ^ (v16 >> 7)) >> 13),
            3);
    v54->m128_i32[v17] = v53[v17] ^ v16;
    ++v17;
  }
  while ( v17 < 21 );
  v33[0] = 600788136;
  v34 = -23049;
  v33[1] = 34152421;
  v33[2] = 530825163;
  v33[3] = -1414893961;
  v33[4] = 256373178;
  v33[5] = 566326630;
  v33[6] = 906829380;
  v33[7] = 1034125321;
  v33[8] = 416748849;
  v33[9] = -1907836114;
  v33[10] = 2137032172;
  v33[11] = 516306623;
  v33[12] = 1281145093;
  v33[13] = 1948318168;
  v33[14] = 2039375691;
  v33[15] = -63105653;
  v33[16] = 725742366;
  v33[17] = -436084334;
  v33[18] = -1698503774;
  v33[19] = -1075929761;
  v33[20] = -579327557;
  EAC_memset(v45, 0, 0x56ui64);
  v18 = 597445876;
  v53 = v33;
  v19 = 0i64;
  v54 = v45;
  do
  {
    v20 = v53[v19] ^ v18;
    v18 = __ROL4__(214013 * v18 + 2531011, 2);
    v54->m128_i32[v19++] = v20;
  }
  while ( v19 < 21 );
  v21 = 84i64;
  v53 = v33;
  v54 = v45;
  do
  {
    v22 = v18;
    v18 >>= 8;
    v54->m128_i8[v21] = *(v53 + v21) ^ v22;
    ++v21;
  }
  while ( v21 < 0x56 );
  v37[0] = 1555403500;
  v37[1] = -1947301342;
  v37[2] = 2144747598;
  v37[3] = -1672762706;
  v37[4] = 2017334368;
  v37[5] = -278095532;
  v37[6] = -872147997;
  v37[7] = 414111871;
  v37[8] = 951357590;
  v37[9] = -1551826294;
  v37[10] = 681129229;
  v37[11] = -995245365;
  v37[12] = 2130851811;
  v37[13] = 835893979;
  v37[14] = -793083642;
  v37[15] = -728432925;
  v37[16] = -49045980;
  v37[17] = 684718518;
  v37[18] = -718098270;
  v37[19] = -419853823;
  v37[20] = -245197182;
  EAC_memset(v48, 0, 0x54ui64);
  v23 = 821178630;
  v53 = v37;
  v24 = 0i64;
  v54 = v48;
  do
  {
    v23 = __ROL4__(
            ((v23 ^ (v23 >> 7)) << 9) ^ v23 ^ (v23 >> 7) ^ ((((v23 ^ (v23 >> 7)) << 9) ^ v23 ^ (v23 >> 7)) >> 13),
            2);
    v54->m128_i32[v24] = v53[v24] ^ v23;
    ++v24;
  }
  while ( v24 < 21 );
  v25 = dword_140083058;
  if ( dword_140083058 == -1 )
  {
    v25 = 1;
    if ( !(loc_140037B58)(v51, v30, &v52) && !(loc_140037B58)(v50, v30, &v52) )
    {
      Get_Unicode_string_Inline(v40, v47);
      if ( !Get_ZwQueryFullAttributesFile(v40) )
      {
        Get_Unicode_string_Inline(v41, v46);
        if ( !Get_ZwQueryFullAttributesFile(v41) )
        {
          Get_Unicode_string_Inline(v42, v49);
          if ( !Get_ZwQueryFullAttributesFile(v42) )
          {
            Get_Unicode_string_Inline(v43, v45);
            if ( !Get_ZwQueryFullAttributesFile(v43) )
            {
              Get_Unicode_string_Inline(v44, v48);
              if ( !Get_ZwQueryFullAttributesFile(v44) )
                v25 = 0;
            }
          }
        }
      }
    }
    dword_140083058 = v25;
  }
  memset(v48, 0, 0x54ui64);
  memset(v45, 0, 0x56ui64);
  memset(v49, 0, 0x54ui64);
  memset(v46, 0, 0x56ui64);
  memset(v47, 0, sizeof(v47));
  memset(v30, 0, 0xAui64);
  memset(v50, 0, 0x7Cui64);
  memset(v51, 0, 0x88ui64);
  return v25 == 1;
}
// 14002B8B0: using guessed type __int64 __fastcall sub_14002B8B0(_QWORD);
// 140083058: using guessed type int dword_140083058;
// 14003F558: using guessed type __m128 var_B0[11];
// 14003F558: using guessed type __m128 var_130[8];
// 14003F558: using guessed type __m128 var_240[5];
// 14003F558: using guessed type __m128 var_2A0[6];
// 14003F558: using guessed type __m128 var_190[6];
// 14003F558: using guessed type __m128 var_300[6];
// 14003F558: using guessed type __m128 var_1F0[6];

//----- (00000001400400C8) ----------------------------------------------------
char sub_1400400C8()
{
  unsigned int v0; // r15d
  unsigned int v1; // ebx
  char v2; // r13
  __int64 Memory; // rax
  __int64 v4; // rsi
  unsigned int v5; // r12d
  __int64 *v6; // r14
  char v7; // di
  int v8; // ebx
  int v9; // edi
  unsigned __int64 i; // rdx
  int v11; // edx
  unsigned __int64 j; // rdi
  char v13; // dl
  _DWORD *System_Information; // rax
  _DWORD *v15; // rsi
  unsigned int v16; // r14d
  __int64 v17; // rdx
  __int64 v18; // rax
  _DWORD *v19; // rcx
  bool v20; // zf
  CHAR *v21; // rcx
  __int64 v22; // rax
  int v23; // ebx
  int v24; // edx
  unsigned __int64 v25; // rdi
  int v26; // ecx
  __int64 v27; // rax
  unsigned int v28; // edx
  unsigned __int64 v29; // rdi
  unsigned __int64 k; // rdi
  char v31; // cl
  __int64 v32; // rax
  unsigned int v33; // edx
  unsigned __int64 v34; // rdi
  int v35; // ecx
  unsigned __int64 m; // rdi
  char v37; // cl
  __int64 v38; // rax
  LONG v39; // eax
  char v40; // dl
  int v42[2]; // [rsp+30h] [rbp-99h]
  char v43; // [rsp+38h] [rbp-91h]
  int v44[2]; // [rsp+39h] [rbp-90h]
  __int16 v45; // [rsp+41h] [rbp-88h]
  int v46[3]; // [rsp+43h] [rbp-86h]
  __int16 v47; // [rsp+4Fh] [rbp-7Ah]
  _BYTE v48[9]; // [rsp+51h] [rbp-78h] BYREF
  _BYTE v49[10]; // [rsp+5Ah] [rbp-6Fh] BYREF
  _BYTE v50[14]; // [rsp+64h] [rbp-65h] BYREF
  __int64 v51; // [rsp+72h] [rbp-57h] BYREF
  __int64 v52; // [rsp+7Ah] [rbp-4Fh] BYREF
  STRING String1; // [rsp+88h] [rbp-41h] BYREF
  PVOID Process; // [rsp+98h] [rbp-31h] BYREF
  char v55[16]; // [rsp+A0h] [rbp-29h] BYREF
  STRING String2; // [rsp+B0h] [rbp-19h] BYREF
  STRING v57; // [rsp+C0h] [rbp-9h] BYREF
  STRING v58; // [rsp+D0h] [rbp+7h] BYREF
  int v59; // [rsp+138h] [rbp+6Fh] BYREF
  int v60; // [rsp+140h] [rbp+77h]
  int v61; // [rsp+144h] [rbp+7Bh]
  int v62; // [rsp+148h] [rbp+7Fh]
  int v63; // [rsp+14Ch] [rbp+83h]

  v0 = 0;
  v1 = 0;
  v2 = 0;
  Memory = EAC_Allocate_Memory(0x800ui64);
  v4 = Memory;
  if ( !Memory )
    goto LABEL_23;
  v5 = sub_140052EF4(Memory, 0x100u);
  if ( v5 )
  {
    v6 = v4;
    while ( 1 )
    {
      if ( *v6 )
      {
        if ( Get_PsLookupProcessByProcessId(*v6, &Process) >= 0 )
        {
          v7 = EAC_GetProcessImageFileName(Process, v55);
          ObfDereferenceObject(Process);
          if ( v7 )
          {
            v60 = 698931028;
            v52 = 0i64;
            v8 = v1 | 1;
            v61 = -740252252;
            v9 = -1355047599;
            for ( i = 0i64; i < 8; i += 4i64 )
            {
              v9 = -2531011 - 214013 * v9;
              *(&v52 + i) = *(&v60 + i) ^ v9;
            }
            if ( sub_14005D784(v55, &v52, 7ui64) )
              goto LABEL_15;
            v62 = 152281377;
            v51 = 0i64;
            v8 |= 2u;
            v63 = -449446603;
            v11 = 1259177789;
            for ( j = 0i64; j < 8; j += 4i64 )
            {
              v11 = __ROR4__(19213 * v11 + 886589, 4);
              *(&v51 + j) = *(&v62 + j) ^ v11;
            }
            if ( sub_14005D784(v55, &v51, 7ui64) || (v8 |= 4u, v59 = 6256244, sub_14005D784(v55, &v59, 3ui64)) )
LABEL_15:
              v13 = 1;
            else
              v13 = 0;
            if ( (v8 & 4) != 0 )
            {
              v8 &= ~4u;
              memset(&v59, 0, sizeof(v59));
            }
            if ( (v8 & 2) != 0 )
            {
              v8 &= ~2u;
              memset(&v51, 0, sizeof(v51));
            }
            v1 = v8 & 0xFFFFFFFE;
            memset(&v52, 0, sizeof(v52));
            if ( v13 )
              break;
          }
        }
      }
      ++v0;
      ++v6;
      if ( v0 >= v5 )
        goto LABEL_22;
    }
    v2 = 1;
  }
LABEL_22:
  Get_ExFreePool(v4);
  if ( !v2 )
  {
LABEL_23:
    System_Information = Get_System_Information();
    v15 = System_Information;
    if ( System_Information )
    {
      v16 = 0;
      if ( *System_Information )
      {
        while ( 1 )
        {
          v17 = 74i64 * v16;
          if ( *&v15[v17 + 6] >= MmSystemRangeStart )
          {
            v18 = HIWORD(v15[v17 + 11]);
            v19 = &v15[v17 + 12];
            v20 = (v19 + v18) == 0i64;
            v21 = v19 + v18;
            String1.Buffer = v21;
            if ( v20 )
            {
              *&String1.Length = 0;
            }
            else
            {
              v22 = -1i64;
              do
                ++v22;
              while ( v21[v22] );
              String1.Length = v22;
              String1.MaximumLength = v22 + 1;
            }
            v42[0] = 1164229484;
            v23 = v1 | 8;
            v42[1] = 1358511698;
            memset(v48, 0, sizeof(v48));
            v24 = 855890216;
            v25 = 0i64;
            v43 = -93;
            do
            {
              v26 = v42[v25] ^ v24;
              v24 = __ROR4__(61515 * v24 + 4921144, 2);
              *&v48[v25 * 4] = v26;
              ++v25;
            }
            while ( v25 < 2 );
            v48[8] = v43 ^ v24;
            String2.Buffer = v48;
            v27 = -1i64;
            do
              ++v27;
            while ( v48[v27] );
            String2.Length = v27;
            String2.MaximumLength = v27 + 1;
            if ( !RtlCompareString(&String1, &String2, 1u) )
              goto LABEL_51;
            v46[0] = 1077108460;
            v23 |= 0x10u;
            v46[1] = -116004074;
            memset(v50, 0, sizeof(v50));
            v28 = 58461372;
            v29 = 0i64;
            v46[2] = -209341410;
            v47 = -23596;
            do
            {
              *&v50[v29 * 4] = v46[v29] ^ v28;
              ++v29;
              v28 = -(((v28 ^ (v28 << 13)) >> 7) ^ v28 ^ (v28 << 13) ^ ((((v28 ^ (v28 << 13)) >> 7) ^ v28 ^ (v28 << 13)) << 17));
            }
            while ( v29 < 3 );
            for ( k = 12i64; k < 0xE; ++k )
            {
              v31 = v28;
              v28 >>= 8;
              v50[k] = *(v46 + k) ^ v31;
            }
            v57.Buffer = v50;
            v32 = -1i64;
            do
              ++v32;
            while ( v50[v32] );
            v57.Length = v32;
            v57.MaximumLength = v32 + 1;
            if ( !RtlCompareString(&String1, &v57, 1u) )
              goto LABEL_51;
            v44[0] = 840585828;
            v23 |= 0x20u;
            v44[1] = 1911730490;
            memset(v49, 0, sizeof(v49));
            v33 = 74526720;
            v34 = 0i64;
            v45 = -18593;
            do
            {
              v35 = v44[v34] ^ v33;
              v33 = __ROR4__(43007 * v33 + 16656496, 3);
              *&v49[v34 * 4] = v35;
              ++v34;
            }
            while ( v34 < 2 );
            for ( m = 8i64; m < 0xA; ++m )
            {
              v37 = v33;
              v33 >>= 8;
              v49[m] = *(v44 + m) ^ v37;
            }
            v58.Buffer = v49;
            v38 = -1i64;
            do
              ++v38;
            while ( v49[v38] );
            v58.Length = v38;
            v58.MaximumLength = v38 + 1;
            v39 = RtlCompareString(&String1, &v58, 1u);
            v40 = 0;
            if ( !v39 )
LABEL_51:
              v40 = 1;
            if ( (v23 & 0x20) != 0 )
            {
              v23 &= ~0x20u;
              memset(v49, 0, sizeof(v49));
            }
            if ( (v23 & 0x10) != 0 )
            {
              v23 &= ~0x10u;
              memset(v50, 0, sizeof(v50));
            }
            v1 = v23 & 0xFFFFFFF7;
            memset(v48, 0, sizeof(v48));
            if ( v40 )
              break;
          }
          if ( ++v16 >= *v15 )
            goto LABEL_60;
        }
        v2 = 1;
      }
LABEL_60:
      Get_ExFreePool(v15);
    }
  }
  return v2;
}
// 1400400C8: using guessed type __int64 var_A6;

//----- (0000000140040684) ----------------------------------------------------
char __fastcall sub_140040684(__int64 a1)
{
  char v1; // bl
  int v2; // esi
  __int64 v3; // rcx
  unsigned int i; // r14d
  __int64 v5; // r15
  unsigned __int32 v6; // edx
  unsigned __int64 v7; // rdi
  unsigned __int64 j; // rdi
  char v9; // cl
  unsigned __int32 v10; // edi
  unsigned __int64 v11; // rdx
  int v12; // ecx
  unsigned __int64 k; // r8
  char v14; // dl
  char v15; // al
  char v16; // dl
  int v18[3]; // [rsp+20h] [rbp-40h]
  __int16 v19; // [rsp+2Ch] [rbp-34h]
  _BYTE v20[14]; // [rsp+2Eh] [rbp-32h] BYREF
  _BYTE v21[18]; // [rsp+3Ch] [rbp-24h] BYREF
  __m128i si128; // [rsp+4Eh] [rbp-12h]
  __int16 v23; // [rsp+5Eh] [rbp-2h]

  v1 = 0;
  v2 = 0;
  sub_140031C84(a1, 0);
  for ( i = 0; i < word_14008327C; ++i )
  {
    v3 = qword_140083280 + 832i64 * i;
    if ( !v3 )
      break;
    v5 = v3 + 8;
    if ( v3 != -8 )
    {
      v2 |= 1u;
      v23 = 16372;
      v6 = -164762973;
      si128 = _mm_load_si128(&xmmword_14007E700);
      v7 = 0i64;
      memset(v21, 0, sizeof(v21));
      do
      {
        *&v21[v7 * 4] = si128.m128i_i32[v7] ^ v6;
        ++v7;
        v6 = _byteswap_ulong(((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13) ^ (32
                                                                          * (((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13))));
      }
      while ( v7 < 4 );
      for ( j = 16i64; j < 0x12; ++j )
      {
        v9 = v6;
        v6 >>= 8;
        v21[j] = si128.m128i_i8[j] ^ v9;
      }
      if ( sub_14005D784(v5, v21, 0x100ui64) )
        goto LABEL_14;
    }
    v18[0] = 1687479651;
    v2 |= 2u;
    v18[1] = -1655423913;
    memset(v20, 0, sizeof(v20));
    v10 = 283411488;
    v11 = 0i64;
    v18[2] = -693734942;
    v19 = 30452;
    do
    {
      v12 = v18[v11] ^ v10;
      v10 = _byteswap_ulong(1103515245 * v10 + 12345);
      *&v20[v11 * 4] = v12;
      ++v11;
    }
    while ( v11 < 3 );
    for ( k = 12i64; k < 0xE; ++k )
    {
      v14 = v10;
      v10 >>= 8;
      v20[k] = *(v18 + k) ^ v14;
    }
    v15 = sub_14005D784(v5, v20, 0x100ui64);
    v16 = 0;
    if ( v15 )
LABEL_14:
      v16 = 1;
    if ( (v2 & 2) != 0 )
    {
      v2 &= ~2u;
      memset(v20, 0, sizeof(v20));
      v3 = 0i64;
    }
    if ( (v2 & 1) != 0 )
    {
      v2 &= ~1u;
      memset(v21, 0, sizeof(v21));
      v3 = 0i64;
    }
    if ( v16 )
    {
      v1 = 1;
      break;
    }
  }
  sub_140031C84(v3, 1);
  return v1;
}
// 140040894: variable 'v3' is possibly undefined
// 14007E700: using guessed type __int128 xmmword_14007E700;
// 14008327C: using guessed type __int16 word_14008327C;
// 140083280: using guessed type __int64 qword_140083280;

//----- (00000001400408B0) ----------------------------------------------------
bool __fastcall sub_1400408B0(__int64 a1)
{
  __int64 v1; // rax MAPDST
  int v3; // ebx
  bool result; // al
  unsigned int v5; // [rsp+30h] [rbp+8h] BYREF

  result = 0;
  if ( a1 )
  {
    v1 = sub_14002D354(a1);
    if ( v1 )
    {
      v3 = sub_14001AC5C(v1, 25u, &v5);
      sub_14002D38C(v1);
      if ( v3 >= 0 && v5 >= 0x4000 )
        return 1;
    }
  }
  return result;
}

//----- (0000000140041494) ----------------------------------------------------
bool __fastcall sub_140041494(__int64 Process)
{
  unsigned __int64 v1; // rdi
  int v3; // edx
  char v4; // dl
  unsigned __int64 v5; // rdi
  unsigned int v6; // edx
  unsigned __int64 v7; // rdi
  char v8; // cl
  int v9; // edx
  unsigned __int64 v10; // rdi
  char v11; // dl
  __int64 v12; // rax
  int v13; // edi
  unsigned __int64 v14; // rdx
  char v15; // bl
  int v17; // [rsp+20h] [rbp-89h]
  unsigned __int64 v18; // [rsp+30h] [rbp-79h] BYREF
  __int64 v19; // [rsp+38h] [rbp-71h] BYREF
  __int64 v20; // [rsp+40h] [rbp-69h]
  __int64 v21; // [rsp+48h] [rbp-61h]
  _BYTE v22[34]; // [rsp+50h] [rbp-59h] BYREF
  int v23; // [rsp+72h] [rbp-37h]
  int v24; // [rsp+76h] [rbp-33h]
  int v25; // [rsp+7Ah] [rbp-2Fh]
  int v26; // [rsp+7Eh] [rbp-2Bh]
  int v27; // [rsp+82h] [rbp-27h]
  _BYTE v28[12]; // [rsp+86h] [rbp-23h] BYREF
  _BYTE v29[26]; // [rsp+92h] [rbp-17h] BYREF
  _BYTE v30[24]; // [rsp+ACh] [rbp+3h] BYREF
  _BYTE v31[24]; // [rsp+C4h] [rbp+1Bh] BYREF
  char v32[32]; // [rsp+E0h] [rbp+37h] BYREF
  PVOID Object; // [rsp+110h] [rbp+67h] BYREF
  unsigned __int64 *v34; // [rsp+118h] [rbp+6Fh]
  _BYTE *v35; // [rsp+120h] [rbp+77h]

  v1 = 0i64;
  LODWORD(Object) = 0;
  if ( !Process || KUSER_SHARED_DATA.NtMajorVersion == 5 )
    return 0;

  if ( !EAC_GetProcessImageFileName(Process, v32) )
    goto LABEL_8;

  v18 = 0xB05588E5CEDFA47Bui64;
  memset(v28, 0, sizeof(v28));
  v3 = 276323658;
  LODWORD(v19) = 1895499455;
  v34 = &v18;
  v35 = v28;
  do
  {
    v3 = ~(1140671485 * v3 + 12820163);
    *&v35[v1] = *(v34 + v1) ^ v3;
    v1 += 4i64;
  }
  while ( v1 < 0xC );
  LOBYTE(v1) = 1;
  if ( sub_14005D784(v32, v28, 0xBui64) )
LABEL_8:
    v4 = 0;
  else
    v4 = 1;
  if ( (v1 & 1) != 0 )
    memset(v28, 0, sizeof(v28));
  if ( v4 )
    return 0;
  HIDWORD(v19) = 1819218728;
  *&v22[4] = 44;
  v20 = 0x1795EC011CA4D5F4i64;
  v5 = 0i64;
  v6 = 1812075333;
  v21 = 0x70E8995F3AA59F86i64;
  *v22 = 1751655180;
  memset(v29, 0, sizeof(v29));
  v34 = (&v19 + 4);
  v35 = v29;
  do
  {
    *&v35[v5] = *(v34 + v5) ^ v6;
    v5 += 4i64;
    v6 = -(((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13) ^ (32 * (((v6 ^ (v6 << 13)) >> 17) ^ v6 ^ (v6 << 13))));
  }
  while ( v5 < 0x18 );
  v7 = 24i64;
  v34 = (&v19 + 4);
  v35 = v29;
  do
  {
    v8 = v6;
    v6 >>= 8;
    v35[v7] = *(v34 + v7) ^ v8;
    ++v7;
  }
  while ( v7 < 0x1A );
  *&v22[6] = 928601069;
  *&v22[10] = 186586325;
  *&v22[14] = -91149217;
  v9 = -2080207114;
  *&v22[18] = -660096717;
  v10 = 0i64;
  *&v22[22] = -1919070345;
  *&v22[26] = -764256259;
  memset(v30, 0, sizeof(v30));
  v34 = &v22[6];
  v35 = v30;
  do
  {
    v9 = __ROR4__(((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13) ^ (32 * (((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13))), 1);
    *&v35[v10] = *(v34 + v10) ^ v9;
    v10 += 4i64;
  }
  while ( v10 < 0x18 );
  v11 = (loc_140040908)(Process, v30, v29, 0i64, 0, 0x4000, v18, v19, v20, v21, *v22, *&v22[8], *&v22[16], *&v22[24]);
  memset(v30, 0, sizeof(v30));
  memset(v29, 0, sizeof(v29));
  if ( !v11 )
    return 0;
  v12 = sub_140053088(Process);
  if ( !v12 )
    return 1;
  if ( Get_PsLookupProcessByProcessId(v12, &Object) < 0 )
    return 1;
  *&v22[30] = -1437804171;
  v23 = 1328632877;
  v24 = 2008983113;
  v13 = 1081774062;
  v25 = -1596245030;
  v14 = 0i64;
  v26 = 959700003;
  v27 = -2123407765;
  memset(v31, 0, sizeof(v31));
  v34 = &v22[30];
  v35 = v31;
  do
  {
    v13 = -12820164 - 1140671485 * v13;
    *&v35[v14] = *(v34 + v14) ^ v13;
    v14 += 4i64;
  }
  while ( v14 < 0x18 );
  LOBYTE(v17) = 0;
  v15 = (loc_140040908)(Object, v31, 0i64, 0i64, v17, 0x4000);
  memset(v31, 0, sizeof(v31));
  ObfDereferenceObject(Object);
  return v15 != 0;
}
// 14004179B: variable 'v17' is possibly undefined
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (00000001400417D4) ----------------------------------------------------
bool __fastcall sub_1400417D4(__int64 a1)
{
  unsigned int v2; // edx
  unsigned __int64 v3; // r8
  char v4; // bl
  int v5; // edx
  unsigned __int64 v6; // r8
  int v7; // edx
  unsigned __int64 v8; // r8
  int v9; // edx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r8
  unsigned int v12; // edx
  unsigned __int64 v13; // r9
  char v14; // cl
  char v15; // dl
  int v17[11]; // [rsp+20h] [rbp-E0h]
  __int16 v18; // [rsp+4Ch] [rbp-B4h]
  int v19[9]; // [rsp+4Eh] [rbp-B2h]
  int v20[9]; // [rsp+72h] [rbp-8Eh]
  int v21[10]; // [rsp+96h] [rbp-6Ah]
  int v22[10]; // [rsp+BEh] [rbp-42h]
  _BYTE v23[46]; // [rsp+E6h] [rbp-1Ah] BYREF
  _BYTE v24[36]; // [rsp+114h] [rbp+14h] BYREF
  _BYTE v25[36]; // [rsp+138h] [rbp+38h] BYREF
  _BYTE v26[40]; // [rsp+15Ch] [rbp+5Ch] BYREF
  __int128 v27[3]; // [rsp+184h] [rbp+84h] BYREF

  if ( !a1 || !*(a1 + 8) || !*a1 || !*(a1 + 2) )
    return 0;
  v21[0] = -1094355545;
  v21[1] = -1971294327;
  v21[2] = -114004675;
  v2 = -2112804579;
  v21[3] = -1271906809;
  v3 = 0i64;
  v21[4] = 1437538784;
  v21[5] = 275442664;
  v21[6] = -1627130516;
  v21[7] = -424901096;
  v21[8] = -2139813503;
  v21[9] = 2053449732;
  memset(v27, 0, 40);
  do
  {
    v2 = ~(((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13) ^ (32 * (((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13))));
    *(v27 + v3 * 4) = v21[v3] ^ v2;
    ++v3;
  }
  while ( v3 < 10 );
  v4 = 1;
  if ( sub_14005D25C(a1, v27) )
    goto LABEL_22;
  v19[0] = -1490983965;
  v19[1] = 851949274;
  v19[2] = 311387932;
  v5 = -1127335239;
  v19[3] = 1994193293;
  v6 = 0i64;
  v19[4] = 2034234644;
  v19[5] = -653440710;
  v19[6] = -1095835101;
  v19[7] = 444795641;
  v19[8] = -1747164504;
  memset(v25, 0, sizeof(v25));
  do
  {
    v5 = __ROR4__(1103515245 * v5 + 12345, 2);
    *&v25[v6 * 4] = v19[v6] ^ v5;
    ++v6;
  }
  while ( v6 < 9 );
  v4 = 3;
  if ( sub_14005D25C(a1, v25) )
    goto LABEL_22;
  v22[0] = -1114199132;
  v22[1] = -16132015;
  v22[2] = 1544767437;
  v7 = -1426792955;
  v22[3] = 622302885;
  v8 = 0i64;
  v22[4] = 1115643776;
  v22[5] = -1681456462;
  v22[6] = 616613020;
  v22[7] = -654563355;
  v22[8] = -1019749148;
  v22[9] = 232579649;
  memset(v26, 0, sizeof(v26));
  do
  {
    v7 = __ROL4__(((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13) ^ (32 * (((v7 ^ (v7 << 13)) >> 17) ^ v7 ^ (v7 << 13))), 3);
    *&v26[v8 * 4] = v22[v8] ^ v7;
    ++v8;
  }
  while ( v8 < 10 );
  v4 = 7;
  if ( sub_14005D25C(a1, v26) )
    goto LABEL_22;
  v20[0] = -118964208;
  v20[1] = 1188262227;
  v20[2] = 1256937026;
  v9 = -1984301183;
  v20[3] = 24490498;
  v10 = 0i64;
  v20[4] = -1929382198;
  v20[5] = -1512517675;
  v20[6] = -30636768;
  v20[7] = -108431960;
  v20[8] = 1891565638;
  memset(v24, 0, sizeof(v24));
  do
  {
    v9 = __ROL4__(1103515245 * v9 + 12345, 1);
    *&v24[v10 * 4] = v20[v10] ^ v9;
    ++v10;
  }
  while ( v10 < 9 );
  v4 = 15;
  if ( sub_14005D25C(a1, v24) )
    goto LABEL_22;
  v17[0] = 3165175;
  v18 = -31245;
  v11 = 44i64;
  v17[1] = -1121144195;
  v12 = 6507435;
  v13 = 0i64;
  v17[2] = -1883541818;
  v17[3] = 816617229;
  v17[4] = -1064314966;
  v17[5] = -479020808;
  v17[6] = 1481194223;
  v17[7] = 339810362;
  v17[8] = 40876637;
  v17[9] = -839960621;
  v17[10] = 1587849744;
  memset(v23, 0, sizeof(v23));
  do
  {
    *&v23[v13 * 4] = v17[v13] ^ v12;
    ++v13;
    v12 = __ROL4__(
            ((v12 ^ (v12 << 13)) >> 17) ^ v12 ^ (v12 << 13) ^ (32 * (((v12 ^ (v12 << 13)) >> 17) ^ v12 ^ (v12 << 13))),
            4);
  }
  while ( v13 < 11 );
  do
  {
    v14 = v12;
    v12 >>= 8;
    v23[v11] = *(v17 + v11) ^ v14;
    ++v11;
  }
  while ( v11 < 0x2E );
  v4 = 31;
  if ( sub_14005D25C(a1, v23) )
  {
LABEL_22:
    v15 = 1;
    if ( (v4 & 0x10) == 0 )
      goto LABEL_24;
  }
  else
  {
    v15 = 0;
  }
  v4 &= ~0x10u;
  memset(v23, 0, sizeof(v23));
LABEL_24:
  if ( (v4 & 8) != 0 )
  {
    v4 &= ~8u;
    memset(v24, 0, sizeof(v24));
  }
  if ( (v4 & 4) != 0 )
    memset(v26, 0, sizeof(v26));
  if ( (v4 & 2) != 0 )
    memset(v25, 0, sizeof(v25));
  memset(v27, 0, 0x28ui64);
  return v15 != 0;
}

//----- (0000000140041CD4) ----------------------------------------------------
__int64 sub_140041CD4()
{
  __int64 v0; // rax
  void (__fastcall *v1)(__int64, __int64, _QWORD); // r15
  __int64 v2; // rax
  void (__fastcall *v3)(__int64, _QWORD, _QWORD); // r14
  __int64 v4; // rax
  __int64 (*v5)(void); // rsi
  __int64 v6; // rbx
  __int64 ntoskrnlbase; // rdi
  int v9; // [rsp+20h] [rbp-20h] BYREF
  int v10; // [rsp+24h] [rbp-1Ch]
  int v11; // [rsp+28h] [rbp-18h]
  int v12; // [rsp+2Ch] [rbp-14h]
  int v13; // [rsp+30h] [rbp-10h]

  v9 = 0x3A37DE9A;
  v10 = 0xF03F0A58;
  v11 = 0xDAA08719;
  v12 = 0x7A0C2BC6;
  v13 = 0x660BEF78;
  v0 = (loc_14003CB4C)(&v9);
  v9 = 0x34F32869;
  v1 = v0;
  v10 = 0x6BADEBF6;
  v11 = 0xB80EF166;
  v12 = 0x19274932;
  v13 = 0x6A79BB0B;
  v2 = (loc_14003CB4C)(&v9);
  v9 = 0x842BBBE0;
  v3 = v2;
  v10 = 0x8E9C7D3;
  v11 = 0x6FF38D6B;
  v12 = 0x7CF938AE;
  v13 = 0xC8D3171B;
  v4 = (loc_14003CB4C)(&v9);
  v9 = 0x64CA5918;
  v5 = v4;
  v10 = 0x59123942;
  v11 = 0xCEF62A4D;
  v12 = 0xC4B695E2;
  v13 = 0x284EEAA6;

  v6 = (loc_14003CB4C)(&v9);
  ntoskrnlbase = Ge_ntoskrnl_base();

  *(ntoskrnlbase + 0xE40) = 0x109B948i64;
  *(ntoskrnlbase + 0xE48) = 0x31480000;
  *(ntoskrnlbase + 0xE4C) = 0x448948C0;
  *(ntoskrnlbase + 0xE50) = 0xB8482024;
  *(ntoskrnlbase + 0xE54) = v6;
  *(ntoskrnlbase + 0xE5C) = 0xE0FF006A;
  v1(ntoskrnlbase + 0xE00, ntoskrnlbase + 0xE40, 0i64);
  v3(ntoskrnlbase + 0xE00, 0i64, 0i64);

  return v5();
}

//----- (0000000140041E1C) ----------------------------------------------------
unsigned int *__fastcall sub_140041E1C(unsigned __int64 a1, unsigned int *a2)
{
  int v2; // r8d
  unsigned int v3; // r9d
  unsigned int *i; // rdx
  unsigned __int64 v5; // r11

  v2 = 0;
  if ( !a1 )
    return 0i64;
  if ( !a2 )
    return 0i64;
  v3 = *a2;
  if ( !*a2 )
    return 0i64;
  for ( i = a2 + 8; ; i += 74 )
  {
    v5 = *(i - 1);
    if ( a1 >= v5 && a1 < v5 + *i )
      break;
    if ( ++v2 >= v3 )
      return 0i64;
  }
  return i - 6;
}

//----- (0000000140041E60) ----------------------------------------------------
_DWORD *__fastcall sub_140041E60(__int64 a1, _DWORD *a2)
{
  unsigned __int64 v3; // rsi
  __int64 v4; // rdi
  _DWORD *i; // rbx
  char v7[256]; // [rsp+20h] [rbp-108h] BYREF

  if ( !a1 )
    return 0i64;
  if ( !*(a1 + 8) )
    return 0i64;
  if ( !*a1 )
    return 0i64;
  if ( !*(a1 + 2) )
    return 0i64;
  if ( !a2 )
    return 0i64;
  if ( !sub_14005D720(v7, 256i64, a1) )
    return 0i64;
  v3 = *a2;
  v4 = 0i64;
  if ( !*a2 )
    return 0i64;
  for ( i = a2 + 2; !sub_14005D784(v7, i + *(i + 19) + 40, 256i64 - *(i + 19)); i += 74 )
  {
    if ( ++v4 >= v3 )
      return 0i64;
  }
  return i;
}

//----- (0000000140041F0C) ----------------------------------------------------
char __fastcall sub_140041F0C(__int64 a1, unsigned __int64 a2)
{
  char ret; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rax

  ret = 0;
  if ( !a1 )
    return 0;

  v3 = *(a1 + 0x10);
  if ( !v3 )
    return 0;

  v4 = *(a1 + 0x18);
  if ( !v4 || !a2 )
    return 0;

  if ( a2 >= v3 && a2 < v3 + v4 )
    return 1;

  return ret;
}

//----- (000000014004223C) ----------------------------------------------------
char __fastcall sub_14004223C(__int64 a1, unsigned __int64 a2, _QWORD *a3, unsigned __int64 *a4)
{
  unsigned __int64 v7; // rbx
  void *Memory; // r8
  unsigned __int64 v9; // rdx
  __int16 v10; // cx
  __int16 v11; // di
  unsigned __int64 v12; // rax
  char result; // al

  if ( !a1 || a2 < 4 || !a3 || !a4 )
    return 0;
  v7 = a2 >> 1;
  Memory = EAC_Allocate_Memory(a2 >> 1);
  v9 = 0i64;
  memset(Memory, 0, v7);
  if ( v7 >= 2 )
  {
    do
    {
      v10 = *(a1 + 2 * v9);
      if ( (v10 - 97) > 5u )
      {
        if ( (v10 - 48) > 9u )
          goto LABEL_14;
      }
      else
      {
        LOBYTE(v10) = v10 - 87;
      }
      v11 = *(a1 + 2 * v9 + 2);
      if ( (v11 - 97) > 5u )
      {
        if ( (v11 - 48) > 9u )
        {
LABEL_14:
          Get_ExFreePool(Memory);
          *a3 = 0i64;
          *a4 = 0i64;
          return 0;
        }
      }
      else
      {
        LOBYTE(v11) = v11 - 87;
      }
      v12 = v9 >> 1;
      v9 += 2i64;
      *(Memory + v12) = v11 & 0xF | (16 * v10);
    }
    while ( v7 - v9 >= 2 );
  }
  result = 1;
  *a4 = v9 >> 1;
  *a3 = Memory;
  return result;
}

//----- (0000000140042340) ----------------------------------------------------
char __fastcall sub_140042340(HANDLE FileHandle, _UNICODE_STRING *unicode_string)
{
  char ret; // bl
  char *Memory; // rax MAPDST
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+30h] [rbp-18h] BYREF

  ret = 0;
  if ( !unicode_string || KeGetCurrentIrql() || Get_KeAreAllApcsDisabled() )
    return 0;

  Memory = EAC_Allocate_Memory(0x202ui64);
  if ( Memory )
  {
    if ( ZwQueryInformationFile(FileHandle, &IoStatusBlock, Memory, 0x200u, FileNameInformation) >= 0 )
    {
      *&Memory[2 * (*Memory >> 1) + 4] = 0;
      ret = EAC_Read_String_From_Unicode_String(unicode_string, Memory + 4);
    }
    Get_ExFreePool(Memory);
  }
  return ret;
}

//----- (00000001400423E4) ----------------------------------------------------
char __fastcall sub_1400423E4(__int16 a1, _BYTE *a2)
{
  char v4; // bl
  __int64 (*v5)(void); // rax
  int v6; // esi
  unsigned int *v7; // rax
  unsigned int v8; // edx
  _WORD *v9; // rcx

  v4 = 0;
  v5 = (loc_14005B768)(qword_140085A30, &qword_140085A30, 0i64);
  v6 = v5();
  v7 = EAC_NtQuerySystemInformation(0x10u, 0x80000u, 0x1000000u, 0i64);
  if ( v7 )
  {
    v8 = 0;
    if ( *v7 )
    {
      v9 = v7 + 7;
      while ( *(v9 - 3) != v6 || *v9 != a1 )
      {
        ++v8;
        v9 += 12;
        if ( v8 >= *v7 )
          goto LABEL_9;
      }
      v4 = 1;
      *a2 = v7[6 * v8 + 3];
    }
LABEL_9:
    Get_ExFreePool(v7);
  }
  return v4;
}
// 140085A30: using guessed type __int64 qword_140085A30;

//----- (0000000140042490) ----------------------------------------------------
char __fastcall sub_140042490(_BYTE *a1)
{
  struct _KTHREAD *CurrentThread; // rdi
  char v3; // bl
  unsigned int v4; // eax
  char v5; // si
  __int64 (__fastcall *v6)(unsigned __int64 *, __int64, _QWORD, __int64 *, int, int, _QWORD); // rbp
  int v7; // ebp
  unsigned __int64 v9; // [rsp+68h] [rbp+10h] BYREF
  __int64 v10; // [rsp+70h] [rbp+18h] BYREF

  v10 = 1i64;
  CurrentThread = KeGetCurrentThread();
  v3 = 0;
  v4 = sub_140035ED4();
  if ( CurrentThread && v4 )
    v5 = *(CurrentThread + v4);
  else
    v5 = 0;
  v6 = (loc_14005B768)(qword_1400861B8, &qword_1400861B8, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( v6 )
    v7 = v6(&v9, 983071i64, 0i64, &v10, 2, 0x4000000, 0i64);
  else
    v7 = -1073741822;
  sub_140036990(CurrentThread, v5);
  if ( v7 >= 0 )
  {
    v3 = sub_1400423E4(v9, a1);
    Get_NtClose(v9);
  }
  return v3;
}
// 1400861B8: using guessed type __int64 qword_1400861B8;

//----- (0000000140042614) ----------------------------------------------------
bool sub_140042614()
{
  char v0; // bl
  __int64 v1; // rax
  int v2; // eax

  v0 = 0;
  v1 = (loc_14004256C)();
  if ( v1 )
  {
    if ( (*v1 & 1) != 0 )
    {
      v2 = *(v1 + 4);
      if ( (v2 & 1) != 0 )
        return (v2 & 2) == 0;
    }
  }
  return v0;
}

//----- (0000000140042F30) ----------------------------------------------------
char *__fastcall sub_140042F30(__int64 a1, __int64 a2, __int64 a3)
{
  char *v4; // rbx
  char *v5; // rax
  _BYTE v7[24]; // [rsp+20h] [rbp-48h]
  __int128 v8; // [rsp+20h] [rbp-48h]

  v4 = 0i64;
  if ( a1 )
  {
    v5 = EAC_Allocate_ProcessVirtualMemory(a1, 0x1000i64, a3, 64);
    v4 = v5;
    if ( v5 )
    {
      sub_14001D338(v5, 0x1000i64);
      if ( *(a1 + 40) == 64 )
      {
        *v7 = xmmword_1400762A0;
        v7[23] = -1;
        *&v7[15] = *(a1 + 200);
        *v4 = *v7;
        *(v4 + 2) = *&v7[16];
        *(v4 + 6) = -998029104;
        *(v4 + 14) = -15576;
      }
      else
      {
        v8 = xmmword_1400762C0;
        *(&v8 + 9) = *(a1 + 200);
        *v4 = v8;
        *(v4 + 8) = 4;
      }
    }
  }
  return v4;
}
// 1400762A0: using guessed type __int128 xmmword_1400762A0;
// 1400762C0: using guessed type __int128 xmmword_1400762C0;

//----- (0000000140043010) ----------------------------------------------------
__m128 *__fastcall sub_140043010(struct_a1_1 *EAC_eData)
{
  unsigned __int16 *p_unsigned___int1640; // rbx
  __m128 *Memory; // rax
  __m128 *eData; // rdi
  __int128 v5; // xmm0
  __int128 v7; // [rsp+20h] [rbp-28h] BYREF
  int v8; // [rsp+30h] [rbp-18h]

  if ( !EAC_eData )
    return 0i64;
  p_unsigned___int1640 = &EAC_eData->unsigned___int1640;
  if ( EAC_eData == -64i64 || !EAC_eData->qword48 || !*p_unsigned___int1640 || !EAC_eData->word42 )
    return 0i64;

  v7 = 0i64;
  v8 = 0;
  (loc_14002A6C0)(&v7);
  Memory = EAC_Allocate_Memory(0x264ui64);
  eData = Memory;
  if ( Memory )
  {
    EAC_memset(Memory, 0, 0x264ui64);
    v5 = v7;
    *(eData[1].m128_u64 + 4) = EAC_eData->qwordB8;
    *(&eData[1].m128_u64[1] + 4) = EAC_eData->qwordC0;
    eData[2].m128_i32[1] = EAC_eData->dword0;
    eData[3].m128_i32[3] = EAC_eData->dwordD8;
    eData[4].m128_i32[0] = EAC_eData->dwordDC;
    *(&eData[2] + 8) = v5;
    eData[3].m128_i32[2] = EAC_eData->dword18;
    *(eData[5].m128_u64 + 4) = EAC_eData->qword1B0;
    *(eData[4].m128_u64 + 4) = EAC_eData->qword120;
    *(&eData[4].m128_u64[1] + 4) = EAC_eData->qword128;
    EAC_Compare_Unicode_Size_String(&eData[5].m128_i64[1] + 4, 260i64, p_unsigned___int1640);
  }
  return eData;
}

//----- (0000000140043120) ----------------------------------------------------
char __fastcall sub_140043120(__int64 ProcessHandle, __int64 a2, __int64 a3)
{
  unsigned __int64 ret; // rbx
  __int64 BaseAddress; // rax MAPDST
  void *Address; // rsi MAPDST

  ret = 0i64;
  BaseAddress = EAC_Allocate_ProcessVirtualMemory(ProcessHandle, 4096i64, a3, 4);
  Address = BaseAddress;
  if ( BaseAddress )
  {
    EAC_IsUsermodeValidAddress(BaseAddress, 40i64, 1);
    memset(Address, 0, 0x28ui64);
    if ( ProcessHandle )
    {
      while ( ret < 8 )
      {
        *(&Address + ret) ^= 0x90u;
        *(ProcessHandle + 4 * ret + 28) = *(&Address + ret);
        ++ret;
      }
    }
    LOBYTE(ret) = 1;
  }
  return ret;
}

//----- (0000000140043578) ----------------------------------------------------
void __fastcall sub_140043578(_QWORD *Data)
{
  __int64 CurrentProcess; // rax
  _PEB *ProcessPeb; // rax
  __int64 v4; // rax
  __int64 User_Module; // rdx
  __int64 v6; // rax
  _BYTE *v7; // rsi
  __int64 v8; // rdi
  _IMAGE_NT_HEADERS *v9; // r14
  __int64 v10; // rax
  int v11; // edi
  __int64 v12; // rax
  __int128 v13; // [rsp+20h] [rbp-88h] BYREF
  int v14; // [rsp+30h] [rbp-78h]
  int v15; // [rsp+34h] [rbp-74h]
  __int16 v16; // [rsp+38h] [rbp-70h]
  int v17[8]; // [rsp+40h] [rbp-68h] BYREF
  __int128 v18; // [rsp+60h] [rbp-48h]
  __int128 v19; // [rsp+70h] [rbp-38h]
  __int64 v20; // [rsp+B0h] [rbp+8h]

  if ( Data )
  {
    if ( Get_PsGetCurrentProcess() == Data[1] )
    {
      CurrentProcess = Get_PsGetCurrentProcess();
      ProcessPeb = Get_PsGetProcessPeb(CurrentProcess);
      if ( ProcessPeb )
      {
        if ( !ProcessPeb->BeingDebugged )
        {
          *&v13 = 0xE1B76581658EBB02ui64;
          *(&v13 + 1) = 0x81567B99B0B0BFE0ui64;

          v14 = 0xDB159DFD;
          v15 = 0xD4CAA2EF;
          v16 = 0xF065;
          v4 = sub_140043780(&v13, v17);
          User_Module = EAC_Get_User_Module(v4);
          memset(v17, 0, 0x1Aui64);
          if ( User_Module )
          {
            v17[0] = 0x501E22DB;
            v17[1] = 0xCF312833;
            v17[2] = 0x62264162;
            LOBYTE(v17[3]) = 18;
            v6 = sub_140043814(v17, &v13);
            v7 = v6;
            v8 = Data[0x17];
            v9 = Data[22];
            if ( v9 && v8 && v6 )
            {
              if ( Check_Module_Architecture(Data[0x17]) == 64 )
                sub_14002FB18(v9, v8, v7);
              else
                sub_14002F904(v9, v8, v7);
            }

            memset(&v13, 0, 0xDui64);
            EAC_IsUsermodeValidAddress(Data[44], 60i64, 1);
            v10 = Data[44];
            v18 = *v10;
            v19 = *(v10 + 16);
            v13 = *(v10 + 32);
            v20 = *(v10 + 48);
            v11 = *(v10 + 56);
            *&v19 = 0i64;
            DWORD2(v19) = 0;
            EAC_IsUsermodeValidAddress(Data[23], 4096i64, 1);
            sub_14003EEB0(Data[23], 4096i64);
            v12 = Data[44];
            *v12 = 0i64;
            *(v12 + 16) = v19;
            *(v12 + 32) = v13;
            *(v12 + 48) = v20;
            *(v12 + 56) = v11;
          }
        }
      }
    }
  }
}
// 14003EEB0: using guessed type __int64 __fastcall sub_14003EEB0(_QWORD, _QWORD);
// 140043780: using guessed type __int64 __fastcall sub_140043780(_QWORD, _QWORD);

//----- (0000000140043780) ----------------------------------------------------
__int64 __fastcall sub_140043780(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r9
  unsigned __int64 i; // r11
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 24) = 0;
  v3 = 1709947753;
  v4 = 24i64;
  for ( i = 0i64; i < 0x18; i += 4i64 )
  {
    *(a2 + i) = *(a1 + i) ^ v3;
    v3 = __ROL4__(((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13) ^ ((((v3 ^ (v3 << 13)) >> 7) ^ v3 ^ (v3 << 13)) << 17), 4);
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v4) = *(a1 + v4) ^ v6;
    ++v4;
  }
  while ( v4 < 0x1A );
  return result;
}

//----- (0000000140043814) ----------------------------------------------------
__int64 __fastcall sub_140043814(__int64 a1, __int64 a2)
{
  unsigned int v2; // r8d
  unsigned __int64 v3; // r9
  __int64 result; // rax

  *a2 = 0i64;
  v2 = 0x3E6C47B0;
  *(a2 + 8) = 0;
  v3 = 0i64;
  *(a2 + 12) = 0;
  do
  {
    *(a2 + v3) = *(a1 + v3) ^ v2;
    v3 += 4i64;
    v2 = 0xFF394E26 - 0x8FC7 * v2;
  }
  while ( v3 < 0xC );
  result = a2;
  *(a2 + 0xC) = *(a1 + 014) ^ v2;
  return result;
}

//----- (0000000140043BC8) ----------------------------------------------------
__int64 __fastcall sub_140043BC8(_QWORD *a1)
{
  ULONG64 v2; // rdi
  __int64 v3; // rdx
  unsigned __int64 i; // rcx
  __int64 result; // rax
  int v6[12]; // [rsp+60h] [rbp-F8h] BYREF
  unsigned __int64 v7; // [rsp+90h] [rbp-C8h]
  char v8[16]; // [rsp+98h] [rbp-C0h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+A8h] [rbp-B0h] BYREF
  char v10[48]; // [rsp+D8h] [rbp-80h] BYREF
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+108h] [rbp-50h] BYREF
  char ApcState[64]; // [rsp+118h] [rbp-40h] BYREF
  void *FileHandle; // [rsp+168h] [rbp+10h] BYREF
  ULONG64 v14; // [rsp+170h] [rbp+18h]

  v6[0] = 16404064;
  v6[1] = 1558998033;
  v6[2] = -569327655;
  v6[3] = 354004200;
  v6[4] = 1265439182;
  v6[5] = 1649825456;
  v6[6] = -311469106;
  v6[7] = 769940327;
  v6[8] = -365134263;
  v6[9] = 2102738394;
  v6[10] = 544682052;
  sub_140043DFC(v6, v10);
  v2 = 0i64;
  if ( a1 )
  {
    if ( !KeGetCurrentIrql() && !Get_KeAreAllApcsDisabled() )
    {
      Get_Unicode_string_Inline(v8, v10);
      ObjectAttributes.Length = 48;
      ObjectAttributes.RootDirectory = 0i64;
      ObjectAttributes.Attributes = 64;
      ObjectAttributes.ObjectName = v8;
      *&ObjectAttributes.SecurityDescriptor = 0i64;
      if ( a1[44] )
      {
        if ( Get_KeStackAttachProcess(a1[1], ApcState) )
        {
          if ( ZwCreateFile(&FileHandle, 0xC0000000, &ObjectAttributes, &IoStatusBlock, 0i64, 0, 3u, 1u, 0, 0i64, 0) >= 0 )
          {
            EAC_IsUsermodeValidAddress(a1[44], 60i64, 1);
            v3 = a1[44];
            v14 = 0i64;
            if ( v3 )
            {
              for ( i = 0i64; ; ++i )
              {
                v7 = i;
                if ( i >= 8 )
                  break;
                *(&v14 + i) = *(v3 + 4 * i + 0x1C) ^ 0x90;
                v2 = v14;
              }
            }
            EAC_IsUsermodeValidAddress(v2, 40i64, 1);
            *(v2 + 8) = FileHandle;
            a1[28] = FileHandle;
          }
          (loc_140054154)(a1[1], ApcState);     // KeUnstackDetachProcess
        }
      }
    }
  }
  result = 0i64;
  memset(v10, 0, 0x2Cui64);
  return result;
}
// 140043DFC: using guessed type __int64 __fastcall sub_140043DFC(_QWORD, _QWORD);

//----- (0000000140043DFC) ----------------------------------------------------
__int64 __fastcall sub_140043DFC(__int64 a1, __int64 a2)
{
  int v2; // r8d
  unsigned __int64 v3; // r9
  __int64 result; // rax

  *a2 = 0i64;
  v2 = 62895233;
  v3 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 32) = 0i64;
  *(a2 + 40) = 0;
  do
  {
    v2 = __ROR4__(959 * v2 + 12563585, 4);
    result = a2;
    *(a2 + v3) = *(a1 + v3) ^ v2;
    v3 += 4i64;
  }
  while ( v3 < 0x2C );
  return result;
}

//----- (0000000140043E54) ----------------------------------------------------
void __fastcall sub_140043E54(__int64 a1)
{
  void *v1; // rbx
  PVOID v2; // rbx
  void (__fastcall *v3)(PVOID); // rax
  PVOID Object; // [rsp+40h] [rbp+8h] BYREF

  if ( a1 )
  {
    v1 = _InterlockedExchange64((a1 + 224), 0i64);
    if ( v1 )
    {
      if ( ObReferenceObjectByHandle(v1, 0, 0i64, 1, &Object, 0i64) >= 0 )
      {
        ObCloseHandle(v1, 1);
        if ( qword_1400832C8 )
        {
          v2 = Object;
          v3 = (loc_14005B768)(qword_140085FF8, &qword_140085FF8, 0i64);
          if ( v3 )
            v3(v2);
        }
        else
        {
          ObfDereferenceObject(Object);
        }
      }
    }
  }
}
// 1400832C8: using guessed type __int64 qword_1400832C8;
// 140085FF8: using guessed type __int64 qword_140085FF8;

//----- (0000000140043EE4) ----------------------------------------------------
char __fastcall sub_140043EE4(struct_eData_1 *eData)
{
  void **ret; // rax
  unsigned __int64 Size; // rsi
  ULONG64 qword88; // rcx
  _OWORD *v5; // rdi
  int *Data; // r14
  int *v7; // r15
  unsigned __int64 v8; // r12
  _OWORD *v9; // rax
  int v11; // [rsp+30h] [rbp-78h] BYREF
  int v12; // [rsp+34h] [rbp-74h]
  __int64 v13; // [rsp+38h] [rbp-70h]
  int v14; // [rsp+40h] [rbp-68h]
  int v15; // [rsp+44h] [rbp-64h]
  __int16 v16; // [rsp+48h] [rbp-60h]
  int v17; // [rsp+50h] [rbp-58h] BYREF
  _BYTE v18[20]; // [rsp+54h] [rbp-54h]
  int v19; // [rsp+68h] [rbp-40h]
  int v20; // [rsp+6Ch] [rbp-3Ch]
  __int16 v21; // [rsp+70h] [rbp-38h]
  void *retaddr; // [rsp+A8h] [rbp+0h] BYREF
  int v23; // [rsp+B0h] [rbp+8h] BYREF
  __int16 v24; // [rsp+B4h] [rbp+Ch]
  int v25; // [rsp+B8h] [rbp+10h] BYREF
  int v26; // [rsp+BCh] [rbp+14h]

  ret = &retaddr;
  v23 = 4024;
  v24 = -15424;
  v25 = 4024;
  v26 = 1098432;
  v17 = 1213290326;
  *v18 = 190i64;
  *&v18[8] = 12535808i64;
  *&v18[16] = -1191182336;
  Size = 8i64;
  v19 = 8;
  v20 = 1599710707;
  v21 = -15522;
  v11 = -1101965482;
  v12 = 0;
  v13 = 0x8B900000000BFi64;
  v14 = -1510801408;
  v15 = -1034002599;
  v16 = 4;
  if ( eData )
  {
    qword88 = eData->qword88;
    if ( qword88 )
    {
      ret = eData->Argument1;
      if ( ret )
      {
        v5 = ret + 32;
        if ( eData->dword28 == 64 )
        {
          Data = &v23;
          Size = 6i64;
          v7 = &v17;
          v8 = 34i64;
          *&v18[1] = ret + 32;
          *&v18[11] = qword88;
        }
        else
        {
          Data = &v25;
          v7 = &v11;
          v8 = 26i64;
          v12 = ret + 256;
          *(&v13 + 1) = qword88;
        }
        EAC_IsUsermodeValidAddress(qword88, 0x20i64, 1);
        EAC_IsUsermodeValidAddress(eData->Argument1, 0x1000i64, 1);
        EAC_memcpy(eData->Argument1, v7, v8);
        v9 = eData->qword88;
        *v5 = *v9;
        v5[1] = v9[1];
        EAC_memcpy(eData->qword88, Data, Size);
        LOBYTE(ret) = Detect_QueueApc(eData->ThreadId, eData->Argument1, 0i64, 1, 1);
      }
    }
  }
  return ret;
}

//----- (0000000140044F08) ----------------------------------------------------
char __fastcall sub_140044F08(__int64 a1)
{
  _DWORD *v2; // rbx
  ULONG64 v3; // rcx
  __int64 v4; // rdx
  unsigned __int64 i; // rcx
  _DWORD *v7; // [rsp+40h] [rbp+8h]

  v2 = 0i64;
  if ( a1 )
  {
    v3 = *(a1 + 352);
    if ( v3 )
    {
      EAC_IsUsermodeValidAddress(v3, 60i64, 1);
      v4 = *(a1 + 352);
      v7 = 0i64;
      if ( v4 )
      {
        for ( i = 0i64; i < 8; ++i )
        {
          *(&v7 + i) = *(v4 + 4 * i + 28) ^ 0x90;
          v2 = v7;
        }
      }
      EAC_IsUsermodeValidAddress(v2, 40i64, 1);
      LOBYTE(v2) = *v2 == 1073942528;
    }
  }
  return v2;
}

//----- (0000000140045070) ----------------------------------------------------
void __fastcall sub_140045070(__int64 a1, int a2, __int64 a3, int a4)
{
  unsigned __int16 v7; // r8
  _WORD *v8; // rbx
  unsigned __int64 i; // rcx
  volatile ULONG64 TickCountQuad; // rbx

  if ( a2 && !_InterlockedCompareExchange((a1 + 0x230), 1, 0) )
  {
    if ( !*(a1 + 0x21C) )
    {
      *(a1 + 0x21C) = a2;
      if ( a3 )
      {
        if ( *(a3 + 8) )
        {
          v7 = *a3;
          if ( v7 )
          {
            if ( *(a3 + 2) )
            {
              v8 = (a1 + 0x220);
              if ( a1 != 0xFFFFFFFFFFFFFDE0ui64 )
              {
                if ( EAC_Allocate_Unicode_string((a1 + 0x220), a3, v7) )
                {
                  for ( i = 0i64; i < *v8; *(*(a1 + 0x228) + i++) += 32 )
                    ;
                }
              }
            }
          }
        }
      }
    }
    _InterlockedExchange((a1 + 560), 0);
  }
  if ( a4 )
  {
    if ( !*(a1 + 564) )
    {
      TickCountQuad = KUSER_SHARED_DATA.TickCountQuad;
      *(a1 + 568) = (10000 * a4) + TickCountQuad * KeQueryTimeIncrement();
      _InterlockedExchange((a1 + 564), 1);
    }
  }
  else
  {
    if ( a1 )
      ++*(a1 + 0x258);
    if ( !sub_1400484F4(qword_140044FA0, a1) )
      sub_14000D924(a1);
  }
}
// 140044FA0: using guessed type __int64 qword_140044FA0[19];
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140045438) ----------------------------------------------------
__int64 __fastcall sub_140045438(__int64 a1)
{
  struct _FAST_MUTEX *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rax

  if ( !a1 || KeGetCurrentIrql() > 1u )
    return 0i64;
  v2 = (a1 + 376);
  ExAcquireFastMutex((a1 + 376));
  v3 = *(a1 + 368);
  v4 = *(a1 + 360);
  *(a1 + 368) = v3 + 560;
  if ( v3 + 1120 > (v4 + 0x10000) )
    *(a1 + 368) = v4;
  ExReleaseFastMutex(v2);
  return v3;
}

//----- (0000000140045EDC) ----------------------------------------------------
__int64 __fastcall sub_140045EDC(__int64 Object)
{
  __int64 result; // rax

  if ( Object )
    return Get_KeWaitForSingleObject(Object);

  return result;
}

//----- (0000000140046678) ----------------------------------------------------
__int64 __fastcall EAC_FltReadFile(struct _FLT_CALLBACK_DATA *Callback_Data, struct_PFLT_INSTANCE *InitiatingInstance)
{
  unsigned int ret; // ebx
  PFLT_IO_PARAMETER_BLOCK Iopb; // rdx MAPDST
  LARGE_INTEGER Size; // r14
  PVOID PoolAlignedWithTag; // rbp
  FILE_STANDARD_INFORMATION FileInformation; // [rsp+50h] [rbp-38h] BYREF
  ULONG LengthReturned; // [rsp+90h] [rbp+8h] BYREF
  union _LARGE_INTEGER ByteOffset; // [rsp+A8h] [rbp+20h] BYREF

  ret = 1;
  memset(&FileInformation, 0, sizeof(FileInformation));
  if ( Callback_Data )
  {
    if ( InitiatingInstance )
    {
      if ( Callback_Data->Iopb->MajorFunction == 0xFF
        && !KeGetCurrentIrql()
        && FltGetRequestorProcess(Callback_Data) == PsInitialSystemProcess )
      {
        Iopb = Callback_Data->Iopb;
        if ( Iopb->Parameters.Read.Length == 1
          && (Iopb->Parameters.AcquireForSectionSynchronization.PageProtection & 0xF0) != 0
          && FltQueryInformationFile(
               InitiatingInstance->instance,
               Iopb->TargetFileObject,
               &FileInformation,
               0x18u,
               FileStandardInformation,
               &LengthReturned) >= 0
          && LengthReturned == 0x18
          && FileInformation.EndOfFile.QuadPart <= 0xFFFFFFFFi64 )
        {
          Size.QuadPart = 0x800000i64;
          if ( FileInformation.EndOfFile.QuadPart < 0x800000ui64 )
            Size = FileInformation.EndOfFile;
          PoolAlignedWithTag = FltAllocatePoolAlignedWithTag(
                                 InitiatingInstance->instance,
                                 NonPagedPool,
                                 Size.QuadPart,
                                 0x676F6457u);
          if ( PoolAlignedWithTag )
          {
            Iopb = Callback_Data->Iopb;
            ByteOffset.QuadPart = 0i64;
            if ( FltReadFile(
                   InitiatingInstance->instance,
                   Iopb->TargetFileObject,
                   &ByteOffset,
                   Size.LowPart,
                   PoolAlignedWithTag,
                   4u,
                   &LengthReturned,
                   0i64,
                   0i64) >= 0
              && sub_140017704(PoolAlignedWithTag, LengthReturned) )
            {
              Callback_Data->IoStatus.Status = 0xC0000022;
              ret = 4;
            }
            FltFreePoolAlignedWithTag(InitiatingInstance->instance, PoolAlignedWithTag, 0x676F6457u);
          }
        }
      }
    }
  }
  return ret;
}

//----- (0000000140046820) ----------------------------------------------------
__int64 sub_140046820()
{
  if ( Filter )
  {
    FltUnregisterFilter(Filter);
    Filter = 0i64;
  }
  return 0i64;
}

//----- (0000000140046848) ----------------------------------------------------
NTSTATUS __fastcall EAC_FltRegisterFilter(PDRIVER_OBJECT Driver)
{
  NTSTATUS result; // eax
  int v3; // edx
  unsigned __int64 v4; // rdi
  unsigned int v5; // edi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rdx
  char v8; // dl
  int v9; // edx
  unsigned __int64 v10; // rdi
  unsigned int v11; // edx
  unsigned __int64 v12; // rdi
  unsigned int v13; // edx
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // rbx
  int v16; // ecx
  unsigned __int64 v17; // rdi
  char v18; // cl
  __int64 v19; // rsi
  __int64 v20; // rax
  unsigned __int32 v21; // edx
  unsigned __int64 v22; // rdi
  __int64 v23; // r8
  unsigned int v24; // edi
  unsigned __int64 v25; // rdx
  char v26; // dl
  unsigned int v27; // edx
  unsigned __int64 v28; // rdi
  int v29; // ecx
  unsigned __int64 v30; // rdi
  char v31; // cl
  unsigned int v32; // edx
  unsigned __int64 v33; // r8
  unsigned __int64 v34; // rdi
  char v35; // cl
  unsigned int v36; // edx
  unsigned __int64 v37; // rdi
  unsigned __int64 v38; // rbx
  int v39; // ecx
  unsigned __int64 v40; // rdi
  char v41; // cl
  unsigned __int32 v42; // edx
  unsigned __int64 v43; // rdi
  unsigned __int32 v44; // edx
  unsigned __int64 v45; // rdi
  char v46; // cl
  NTSTATUS started; // edi
  int v48[3]; // [rsp+30h] [rbp-D0h] BYREF
  __int16 v49; // [rsp+3Ch] [rbp-C4h]
  int v50[4]; // [rsp+3Eh] [rbp-C2h] BYREF
  __int16 v51; // [rsp+4Eh] [rbp-B2h]
  int v52[3]; // [rsp+50h] [rbp-B0h] BYREF
  _BYTE v53[14]; // [rsp+5Ch] [rbp-A4h] BYREF
  int v54[5]; // [rsp+6Ah] [rbp-96h] BYREF
  int v55[7]; // [rsp+7Eh] [rbp-82h] BYREF
  int v56[7]; // [rsp+9Ah] [rbp-66h] BYREF
  int v57[8]; // [rsp+B6h] [rbp-4Ah] BYREF
  int v58[34]; // [rsp+D6h] [rbp-2Ah] BYREF
  __int16 v59; // [rsp+15Eh] [rbp+5Eh]
  int v60[39]; // [rsp+160h] [rbp+60h] BYREF
  __int16 v61; // [rsp+1FCh] [rbp+FCh]
  int v62[39]; // [rsp+1FEh] [rbp+FEh] BYREF
  __int16 v63; // [rsp+29Ah] [rbp+19Ah]
  int v64[46]; // [rsp+29Ch] [rbp+19Ch] BYREF
  __int16 v65; // [rsp+354h] [rbp+254h]
  int v66[46]; // [rsp+356h] [rbp+256h] BYREF
  __int16 v67; // [rsp+40Eh] [rbp+30Eh]
  _BYTE v68[12]; // [rsp+410h] [rbp+310h] BYREF
  _BYTE v69[18]; // [rsp+41Ch] [rbp+31Ch] BYREF
  _BYTE v70[20]; // [rsp+42Eh] [rbp+32Eh] BYREF
  _BYTE v71[28]; // [rsp+442h] [rbp+342h] BYREF
  _BYTE v72[28]; // [rsp+45Eh] [rbp+35Eh] BYREF
  __int128 v73[2]; // [rsp+47Ah] [rbp+37Ah] BYREF
  char v74[138]; // [rsp+49Ah] [rbp+39Ah] BYREF
  char v75[158]; // [rsp+524h] [rbp+424h] BYREF
  char v76[158]; // [rsp+5C2h] [rbp+4C2h] BYREF
  char v77[186]; // [rsp+660h] [rbp+560h] BYREF
  __m128 v78[14]; // [rsp+71Ah] [rbp+61Ah] BYREF
  int *v79; // [rsp+818h] [rbp+718h] BYREF
  __m128 *v80; // [rsp+820h] [rbp+720h]
  __m128 *v81; // [rsp+828h] [rbp+728h]

  if ( Filter )
    return -1073740008;

  v54[0] = 1974354805;
  v54[1] = 2060996750;
  v54[2] = 1959001256;
  v3 = 2096373296;
  v54[3] = 2015741671;
  v4 = 0i64;
  v54[4] = -1828343029;
  memset(v70, 0, sizeof(v70));
  v80 = v54;
  v81 = v70;
  do
  {
    v3 = __ROL4__(1140671485 * v3 + 12820163, 4);
    v81->m128_i32[v4] = v80->m128_i32[v4] ^ v3;
    ++v4;
  }
  while ( v4 < 5 );
  v58[0] = -1897494855;
  v58[1] = 917913464;
  v58[2] = 1987407914;
  v58[3] = -1676784577;
  v58[4] = -1253897885;
  v58[5] = 996227072;
  v58[6] = -738396424;
  v58[7] = 1534424039;
  v58[8] = -2086345252;
  v58[9] = 1807064500;
  v58[10] = 626492076;
  v58[11] = -317118630;
  v58[12] = -186928103;
  v58[13] = 29281967;
  v58[14] = -1365471381;
  v58[15] = -1004854999;
  v58[16] = -1951343103;
  v58[17] = 776140537;
  v58[18] = -957078484;
  v58[19] = 3340546;
  v58[20] = 1828453608;
  v58[21] = 228086899;
  v58[22] = -376084243;
  v58[23] = -1545975473;
  v58[24] = -2126700198;
  v58[25] = -1456524271;
  v58[26] = 28771222;
  v58[27] = 1119828524;
  v58[28] = 1132903378;
  v58[29] = 2082840984;
  v58[30] = 1708586253;
  v58[31] = -1614412232;
  v58[32] = 799623373;
  v58[33] = -1273945470;
  v59 = 25695;
  EAC_memset(v74, 0, 0x8Aui64);
  v5 = -1900771611;
  v80 = v58;
  v6 = 136i64;
  v7 = 0i64;
  v81 = v74;
  do
  {
    v81->m128_i32[v7] = v80->m128_i32[v7] ^ v5;
    ++v7;
    v5 = __ROL4__(((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13) ^ (32 * (((v5 ^ (v5 << 13)) >> 17) ^ v5 ^ (v5 << 13))), 4);
  }
  while ( v7 < 34 );
  v80 = v58;
  v81 = v74;
  do
  {
    v8 = v5;
    v5 >>= 8;
    v81->m128_i8[v6] = v80->m128_i8[v6] ^ v8;
    ++v6;
  }
  while ( v6 < 0x8A );
  LOBYTE(v6) = 1;
  (loc_140037810)(v74, v70, v6);
  v55[0] = -1170474950;
  memset(v74, 0, sizeof(v74));
  v55[1] = -641733029;
  v55[2] = 1684614856;
  memset(v70, 0, sizeof(v70));
  v55[3] = 314896017;
  v55[4] = -2146962303;
  v55[5] = -1129895574;
  v9 = -925206974;
  v55[6] = -574258298;
  v10 = 0i64;
  memset(v71, 0, sizeof(v71));
  v80 = v55;
  v81 = v71;
  do
  {
    v9 = __ROR4__(1140671485 * v9 + 12820163, 3);
    v81->m128_i32[v10] = v80->m128_i32[v10] ^ v9;
    ++v10;
  }
  while ( v10 < 7 );
  v57[0] = -1054214529;
  v57[1] = 1365408164;
  memset(v73, 0, sizeof(v73));
  v57[2] = 114033332;
  v11 = 361700934;
  v57[3] = 642443671;
  v12 = 0i64;
  v57[4] = -1018702742;
  v57[5] = -1868194666;
  v57[6] = -1746957540;
  v57[7] = 594818272;
  v80 = v57;
  v81 = v73;
  do
  {
    v11 = -(((v11 ^ (v11 << 13)) >> 17) ^ v11 ^ (v11 << 13) ^ (32 * (((v11 ^ (v11 << 13)) >> 17) ^ v11 ^ (v11 << 13))));
    v81->m128_i32[v12] = v80->m128_i32[v12] ^ v11;
    ++v12;
  }
  while ( v12 < 8 );
  v60[0] = 2066212357;
  v61 = -28387;
  v60[1] = 877044619;
  v60[2] = 1752496855;
  v60[3] = 1538329046;
  v60[4] = 1771364878;
  v60[5] = -2056526694;
  v60[6] = -1332624532;
  v60[7] = -1099934708;
  v60[8] = 716512512;
  v60[9] = 968034038;
  v60[10] = 258119654;
  v60[11] = 677264044;
  v60[12] = 899560670;
  v60[13] = 1117004346;
  v60[14] = -1141551993;
  v60[15] = 329069207;
  v60[16] = 268880437;
  v60[17] = 2014242230;
  v60[18] = -86437060;
  v60[19] = 2057635674;
  v60[20] = 1266579501;
  v60[21] = -402860762;
  v60[22] = 2030871024;
  v60[23] = 972297207;
  v60[24] = 96529011;
  v60[25] = -525367209;
  v60[26] = -1056397872;
  v60[27] = 462016754;
  v60[28] = 500833297;
  v60[29] = -622452224;
  v60[30] = -137346662;
  v60[31] = 973233963;
  v60[32] = 1410534978;
  v60[33] = 1295709041;
  v60[34] = -1050674890;
  v60[35] = 1150498511;
  v60[36] = 944877516;
  v60[37] = -980509816;
  v60[38] = 1147107489;
  EAC_memset(v75, 0, 0x9Eui64);
  v13 = 2071324249;
  v80 = v60;
  v14 = 0i64;
  v15 = 156i64;
  v81 = v75;
  do
  {
    v16 = v80->m128_i32[v14] ^ v13;
    v13 = __ROR4__(1140671485 * v13 + 12820163, 2);
    v81->m128_i32[v14++] = v16;
  }
  while ( v14 < 39 );
  v17 = 156i64;
  v80 = v60;
  v81 = v75;
  do
  {
    v18 = v13;
    v13 >>= 8;
    v81->m128_i8[v17] = v80->m128_i8[v17] ^ v18;
    ++v17;
  }
  while ( v17 < 0x9E );
  v19 = -1i64;
  v20 = -1i64;
  do
    ++v20;
  while ( *&v71[2 * v20] );
  (loc_14003773C)(v75, v73, 1i64, v71, 2 * v20 + 2);
  v56[0] = 189140723;
  v56[1] = -1582099432;
  memset(v75, 0, sizeof(v75));
  v56[2] = -2103209802;
  v56[3] = -554764401;
  memset(v73, 0, sizeof(v73));
  v56[4] = -771090172;
  v56[5] = -296779955;
  memset(v71, 0, sizeof(v71));
  v56[6] = 1270974150;
  v21 = -664991768;
  memset(v72, 0, sizeof(v72));
  v80 = v56;
  v22 = 0i64;
  v81 = v72;
  do
  {
    v21 = _byteswap_ulong(1140671485 * v21 + 12820163);
    v81->m128_i32[v22] = v80->m128_i32[v22] ^ v21;
    ++v22;
  }
  while ( v22 < 7 );
  v62[0] = 1600097974;
  v63 = 14270;
  v62[1] = -882936232;
  v62[2] = -2054827244;
  v62[3] = 1396651290;
  v62[4] = -1236106280;
  v62[5] = 1454800046;
  v62[6] = 1874114330;
  v62[7] = 551512182;
  v62[8] = 1145088412;
  v62[9] = 184103876;
  v62[10] = 1763939730;
  v62[11] = 495059804;
  v62[12] = -1214571636;
  v62[13] = -546861525;
  v62[14] = 1250664604;
  v62[15] = -1088609562;
  v62[16] = 61174312;
  v62[17] = 48913977;
  v62[18] = 476019408;
  v62[19] = -2142327165;
  v62[20] = 1916873333;
  v62[21] = -969700504;
  v62[22] = -934835763;
  v62[23] = -1501499487;
  v62[24] = 115471874;
  v62[25] = 1861758313;
  v62[26] = 1954214915;
  v62[27] = -1485574301;
  v62[28] = 1483415898;
  v62[29] = -2022235773;
  v62[30] = -659877061;
  v62[31] = 280720500;
  v62[32] = 1794892566;
  v62[33] = 1373333382;
  v62[34] = 135560311;
  v62[35] = -1554167626;
  v62[36] = -754697719;
  v62[37] = 249713401;
  v62[38] = 1093353636;
  EAC_memset(v76, 0, 0x9Eui64);
  v24 = 1594724074;
  v80 = v62;
  v25 = 0i64;
  v81 = v76;
  do
  {
    v81->m128_i32[v25] = v80->m128_i32[v25] ^ v24;
    ++v25;
    v24 = ~(((v24 ^ (v24 << 13)) >> 17) ^ v24 ^ (v24 << 13) ^ (32 * (((v24 ^ (v24 << 13)) >> 17) ^ v24 ^ (v24 << 13))));
  }
  while ( v25 < 39 );
  v80 = v62;
  v81 = v76;
  do
  {
    v26 = v24;
    v24 >>= 8;
    v81->m128_i8[v15] = v80->m128_i8[v15] ^ v26;
    ++v15;
  }
  while ( v15 < 0x9E );
  LOBYTE(v23) = 1;
  (loc_140037810)(v76, v72, v23);
  v48[0] = -1633395125;
  v48[1] = -1287965182;
  v48[2] = 1160778033;
  memset(v76, 0, sizeof(v76));
  v27 = -1634312584;
  memset(v72, 0, sizeof(v72));
  v28 = 0i64;
  v49 = 3899;
  memset(v53, 0, sizeof(v53));
  v80 = v48;
  v81 = v53;
  do
  {
    v29 = v80->m128_i32[v28] ^ v27;
    v27 = __ROR4__(214013 * v27 + 2531011, 4);
    v81->m128_i32[v28++] = v29;
  }
  while ( v28 < 3 );
  v30 = 12i64;
  v80 = v48;
  v81 = v53;
  do
  {
    v31 = v27;
    v27 >>= 8;
    v81->m128_i8[v30] = v80->m128_i8[v30] ^ v31;
    ++v30;
  }
  while ( v30 < 0xE );
  v50[0] = -1549351682;
  v51 = 19679;
  v50[1] = 1203504068;
  v32 = -1546992449;
  v50[2] = 226797682;
  v50[3] = 652268330;
  v33 = 0i64;
  memset(v69, 0, sizeof(v69));
  v80 = v50;
  v34 = 16i64;
  v81 = v69;
  do
  {
    v81->m128_i32[v33] = v80->m128_i32[v33] ^ v32;
    ++v33;
    v32 = ~(((v32 ^ (v32 >> 7)) << 9) ^ v32 ^ (v32 >> 7) ^ ((((v32 ^ (v32 >> 7)) << 9) ^ v32 ^ (v32 >> 7)) >> 13));
  }
  while ( v33 < 4 );
  v80 = v50;
  v81 = v69;
  do
  {
    v35 = v32;
    v32 >>= 8;
    v81->m128_i8[v34] = v80->m128_i8[v34] ^ v35;
    ++v34;
  }
  while ( v34 < 0x12 );
  v64[0] = -1894518164;
  v65 = -4901;
  v64[1] = -691682180;
  v64[2] = 37550933;
  v64[3] = -1801367821;
  v64[4] = 659736558;
  v64[5] = 1728098738;
  v64[6] = 1774920192;
  v64[7] = 1068122532;
  v64[8] = 327263947;
  v64[9] = -868749041;
  v64[10] = -204399356;
  v64[11] = 1828630810;
  v64[12] = 1155654415;
  v64[13] = 272531472;
  v64[14] = 1361082552;
  v64[15] = -183439780;
  v64[16] = -595161515;
  v64[17] = -1899960786;
  v64[18] = -1986562445;
  v64[19] = 1637826572;
  v64[20] = -301355340;
  v64[21] = 1369115508;
  v64[22] = -1477669184;
  v64[23] = 1776804636;
  v64[24] = -1317728735;
  v64[25] = -1382089331;
  v64[26] = -565801439;
  v64[27] = -919715400;
  v64[28] = 1259594480;
  v64[29] = 445807916;
  v64[30] = -97795298;
  v64[31] = 768246835;
  v64[32] = -906660716;
  v64[33] = -1675861912;
  v64[34] = 1879114004;
  v64[35] = -372384485;
  v64[36] = 1198460230;
  v64[37] = -2023038984;
  v64[38] = -723227547;
  v64[39] = -3330755;
  v64[40] = 1521249585;
  v64[41] = -939406576;
  v64[42] = 531075114;
  v64[43] = -1045954926;
  v64[44] = 1173661313;
  v64[45] = 1781876581;
  EAC_memset(v77, 0, 0xBAui64);
  v36 = -1891503568;
  v80 = v64;
  v37 = 0i64;
  v38 = 184i64;
  v81 = v77;
  do
  {
    v39 = v80->m128_i32[v37] ^ v36;
    v36 = __ROR4__(214013 * v36 + 2531011, 1);
    v81->m128_i32[v37++] = v39;
  }
  while ( v37 < 46 );
  v40 = 184i64;
  v80 = v64;
  v81 = v77;


  do
  {
    v41 = v36;
    v36 >>= 8;
    v81->m128_i8[v40] = v80->m128_i8[v40] ^ v41;
    ++v40;
  }
  while ( v40 < 0xBA );
  do
    ++v19;
  while ( *&v53[2 * v19] );

  (loc_14003773C)(v77, v69, 1i64, v53, 2 * v19 + 2);
  v52[0] = 292497669;
  memset(v68, 0, sizeof(v68));
  v52[1] = -91628674;
  memset(v77, 0, sizeof(v77));
  v52[2] = 1716120417;
  v42 = 898120678;
  memset(v69, 0, sizeof(v69));
  memset(v53, 0, sizeof(v53));
  v43 = 0i64;
  v80 = v52;
  v81 = v68;
  do
  {
    v42 = _byteswap_ulong(214013 * v42 + 2531011);
    v81->m128_i32[v43] = v80->m128_i32[v43] ^ v42;
    ++v43;
  }
  while ( v43 < 3 );
  v66[0] = -1062478846;
  v67 = 26370;
  v66[1] = -653449644;
  v66[2] = -1657651456;
  v66[3] = 465109535;
  v66[4] = -855583845;
  v66[5] = -763293683;
  v66[6] = 1220536123;
  v66[7] = 757911981;
  v66[8] = -483676040;
  v66[9] = 16518099;
  v66[10] = -1401281253;
  v66[11] = 557614596;
  v66[12] = -2105279717;
  v66[13] = 824389756;
  v66[14] = -745204444;
  v66[15] = -1802191341;
  v66[16] = -1171572924;
  v66[17] = 449530036;
  v66[18] = 2126046844;
  v66[19] = 214677574;
  v66[20] = -1019899030;
  v66[21] = 326558992;
  v66[22] = 1936875121;
  v66[23] = 1889361609;
  v66[24] = -821265608;
  v66[25] = -1969052334;
  v66[26] = -1224386280;
  v66[27] = -1523634992;
  v66[28] = 301079004;
  v66[29] = 1298923291;
  v66[30] = -11309505;
  v66[31] = 43972369;
  v66[32] = -1009193854;
  v66[33] = -100008798;
  v66[34] = -1070031941;
  v66[35] = -692911795;
  v66[36] = 1606512504;
  v66[37] = -689814769;
  v66[38] = -1686000662;
  v66[39] = 523851852;
  v66[40] = -1086126085;
  v66[41] = -1625784229;
  v66[42] = 696451902;
  v66[43] = -1543406327;
  v66[44] = 1412431064;
  v66[45] = -837929743;
  EAC_memset(v78, 0, 0xBAui64);
  v44 = -1057366946;
  v80 = v66;
  v45 = 0i64;
  v81 = v78;
  do
  {
    v81->m128_i32[v45] = v80->m128_i32[v45] ^ v44;
    ++v45;
    v44 = _byteswap_ulong(((v44 ^ (v44 >> 7)) << 9) ^ v44 ^ (v44 >> 7) ^ ((((v44 ^ (v44 >> 7)) << 9) ^ v44 ^ (v44 >> 7)) >> 13));
  }
  while ( v45 < 46 );
  v79 = v66;
  v80 = v78;
  do
  {
    v46 = v44;
    v44 >>= 8;
    v80->m128_i8[v38] = *(v79 + v38) ^ v46;
    ++v38;
  }
  while ( v38 < 0xBA );
  LODWORD(v79) = 0;
  (loc_14003773C)(v78, v68, 4i64, &v79, 4);
  memset(v78, 0, 0xBAui64);
  memset(v68, 0, sizeof(v68));
  result = FltRegisterFilter(Driver, &Registration, &Filter);
  if ( result >= 0 )
  {
    started = FltStartFiltering(Filter);
    if ( started < 0 )
    {
      FltUnregisterFilter(Filter);
      Filter = 0i64;
    }
    return started;
  }
  else
  {
    Filter = 0i64;
  }
  return result;
}
// 140047187: variable 'v23' is possibly undefined
// 140046848: using guessed type __m128 var_E6[14];

//----- (0000000140047E8C) ----------------------------------------------------
__int64 __fastcall Get_MmGetPhysicalAddress(__int64 BaseAddress)
{
  __int64 (__fastcall *g_MmGetPhysicalAddress)(__int64); // rax

  g_MmGetPhysicalAddress = (loc_14005B768)(qword_140085D08, &qword_140085D08, 0i64);
  if ( g_MmGetPhysicalAddress )
    return g_MmGetPhysicalAddress(BaseAddress);
  else
    return qword_1400832B8;
}
// 1400832B8: using guessed type __int64 qword_1400832B8;
// 140085D08: using guessed type __int64 qword_140085D08;

//----- (0000000140047EC8) ----------------------------------------------------
PVOID __stdcall Get_MmGetVirtualForPhysical(PHYSICAL_ADDRESS PhysicalAddress)
{
  __int64 (__fastcall *g_MmGetVirtualForPhysical)(PHYSICAL_ADDRESS); // r8
  PVOID result; // rax

  g_MmGetVirtualForPhysical = (loc_14005B768)(qword_140085D38, &qword_140085D38, 0i64);
  result = 0i64;

  if ( g_MmGetVirtualForPhysical )
    return (g_MmGetVirtualForPhysical)(PhysicalAddress.QuadPart);// MmGetVirtualForPhysical

  return result;
}
// 140085D38: using guessed type __int64 qword_140085D38;

//----- (0000000140047F00) ----------------------------------------------------
__int64 __fastcall Get_MmIsAddressValid(__int64 VirtualAddress)
{
  __int64 (__fastcall *g_MmIsAddressValid)(__int64); // r8
  __int64 result; // rax

  g_MmIsAddressValid = (loc_14005B768)(qword_140085D10, &qword_140085D10, 0i64);
  result = 0i64;

  if ( g_MmIsAddressValid )
    return g_MmIsAddressValid(VirtualAddress);  // MmIsAddressValid

  return result;
}
// 140085D10: using guessed type __int64 qword_140085D10;

//----- (0000000140047F38) ----------------------------------------------------
__int64 __fastcall Get_MmMapIoSpace(__int64 PhysicalAddress, __int64 NumberOfBytes, unsigned int CacheType)
{
  __int64 (__fastcall *G_MmMapIoSpace)(__int64, __int64, _QWORD); // r9
  __int64 result; // rax

  G_MmMapIoSpace = (loc_14005B768)(qword_140085D20, &qword_140085D20, 0i64);
  result = 0i64;
  if ( G_MmMapIoSpace )

    return G_MmMapIoSpace(PhysicalAddress, NumberOfBytes, CacheType);// MmMapIoSpace
  return result;
}
// 140085D20: using guessed type __int64 qword_140085D20;

//----- (0000000140047F8C) ----------------------------------------------------
__int64 (__fastcall *__fastcall Get_MmUnmapIoSpace(__int64 BaseAddress, __int64 NumberOfBytes))(__int64, __int64)
{
  __int64 (__fastcall *G_MmUnmapIoSpace)(__int64, __int64); // rax

  G_MmUnmapIoSpace = (loc_14005B768)(qword_140085D28, &qword_140085D28, 0i64);
  if ( G_MmUnmapIoSpace )
    return G_MmUnmapIoSpace(BaseAddress, NumberOfBytes);// MmUnmapIoSpace

  return G_MmUnmapIoSpace;
}
// 140085D28: using guessed type __int64 qword_140085D28;

//----- (0000000140047FCC) ----------------------------------------------------
__int64 __fastcall MmCopyMemory(
        __int64 TargetAddress,
        __int64 SourceAddress,
        __int64 NumberOfBytes,
        unsigned int Flags,
        __int64 NumberOfBytesTransferred)
{
  __int64 (__fastcall *g_MmCopyMemory)(__int64, __int64, __int64, _QWORD, __int64); // rax

  g_MmCopyMemory = (loc_14005B768)(qword_140085D40, &qword_140085D40, 0i64);
  if ( g_MmCopyMemory )
    return g_MmCopyMemory(TargetAddress, SourceAddress, NumberOfBytes, Flags, NumberOfBytesTransferred);// MmCopyMemory
  else
    return 0xC0000002i64;
}
// 140085D40: using guessed type __int64 qword_140085D40;

//----- (000000014004803C) ----------------------------------------------------
char __fastcall sub_14004803C(char a1, char **a2, int *a3, unsigned int *a4)
{
  char *v7; // r10
  int v8; // edx
  unsigned int v9; // eax
  bool v10; // r15
  int v11; // edi
  char *v12; // rsi
  char v13; // cl
  int *v14; // r10
  unsigned int v15; // r9d
  char v16; // al
  unsigned __int64 v17; // rbp
  int v18; // edx
  char v19; // cl
  unsigned int v20; // r9d
  __int64 v21; // r10
  char *v22; // rdx

  if ( a2 )
  {
    v7 = *a2;
    if ( *a2 )
    {
      if ( a3 )
      {
        v8 = *a3;
        if ( *a3 )
        {
          if ( a4 )
          {
            memset(a4, 0, 0x28ui64);
            v9 = *v7 & 0x1F;
            *a4 = v9;
            v10 = (*v7 & 0x20) == 0;
            if ( v9 < 0x1F )
            {
              v11 = v8 - 1;
              *(a4 + 3) = v7;
              *a3 = v8 - 1;
              v12 = v7 + 1;
              *a2 = v7 + 1;
              if ( v8 == 1 )
                return 1;
              v13 = 0;
              v14 = (a4 + 4);
              if ( v12 )
              {
                if ( a4 != -16i64 )
                {
                  v15 = 0;
                  *v14 = 0;
                  v16 = *v12;
                  if ( *v12 >= 0 )
                  {
                    *v14 = v16 & 0x7F;
                  }
                  else
                  {
                    if ( (v16 & 0x7F) == 0 || (v15 = v16 & 0x7F, v15 > 4) || v15 > v8 - 2 )
                    {
LABEL_19:
                      v20 = v15 + 1;
                      if ( v13 )
                      {
                        v21 = *v14;
                        if ( v21 <= v11 - v20 )
                        {
                          v22 = &v12[v20];
                          a4[8] = v20 + 1;
                          *(a4 + 1) = v22;
                          if ( v10 || !a1 )
                          {
                            *a2 = &v22[v21];
                            *a3 = v11 - v21 - v20;
                          }
                          else
                          {
                            *a2 = v22;
                            *a3 = v11 - v20;
                          }
                          return 1;
                        }
                      }
                      return 0;
                    }
                    v17 = 0i64;
                    if ( (v16 & 0x7F) != 0 )
                    {
                      do
                      {
                        v18 = v12[v17 + 1];
                        v19 = v15 - v17++;
                        *v14 += v18 << (8 * v19 - 8);
                      }
                      while ( v17 < (v16 & 0x7Fu) );
                    }
                  }
                  v13 = 1;
                  goto LABEL_19;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (00000001400481AC) ----------------------------------------------------
char __fastcall sub_1400481AC(__int64 a1, __int64 a2, __int64 a3)
{
  char v4; // cl

  v4 = 0;
  if ( a2 == *(a3 + 8) && *a3 == (*a1 & 0xFFFFFFFFFFFFFFF8ui64) + 48 )
  {
    *(a1 + 8) ^= (*(a1 + 8) ^ *(a3 + 16)) & 0x1FFFFFF;
    return 1;
  }
  return v4;
}

//----- (00000001400481E0) ----------------------------------------------------
char __fastcall sub_1400481E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v5; // bl
  _QWORD *v6; // rcx

  v5 = 0;
  v6 = (a1 + 48);
  if ( a3 == *(a4 + 8) && ((*a2 >> 16) & 0xFFFFFFFFFFF0i64 | 0xFFFF000000000000ui64) + 48 == *a4 )
  {
    v5 = 1;
    *(a2 + 8) ^= (*(a2 + 8) ^ *(a4 + 16)) & 0x1FFFFFF;
  }
  _InterlockedExchangeAdd(a2, 1u);
  if ( a1 && *v6 )
    qword_140085D88(v6, 0i64);
  return v5;
}
// 140085D88: using guessed type __int64 (__fastcall *qword_140085D88)(_QWORD, _QWORD);

//----- (00000001400484F4) ----------------------------------------------------
char __fastcall sub_1400484F4(__int64 a1, __int64 a2)
{
  char ret; // di
  __int64 Memory; // rbx
  __int64 *v6; // rsi
  __int64 *v7; // r14
  __int64 v8; // rbp
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 **v11; // rax
  __int64 v12; // rax
  __int64 *v13; // rax

  ret = 0;
  if ( !a1 || !dword_140085CBC || KeGetCurrentIrql() > 1u )
    return 0;
  Memory = EAC_Allocate_Memory(0x18ui64);
  if ( Memory )
  {
    *Memory = 0i64;
    *(Memory + 16) = 0i64;
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&stru_140085DB8);
    if ( dword_140085CBC == 1 )
    {
      v6 = qword_140085DA8;
      while ( v6 != &qword_140085DA8 )
      {
        v7 = v6;
        v8 = v6;
        v6 = *v6;
        if ( PsIsThreadTerminating(*(v7[2] + 40)) )
        {
          v9 = v7[2];
          if ( !v9 || !*(v9 + 32) )
          {
            v10 = *v7;
            v11 = v7[1];
            if ( *(*v7 + 8) != v7 || *v11 != v7 )
              __fastfail(3u);
            *v11 = v10;
            *(v10 + 8) = v11;
            (loc_140051FDC)(*(v8 + 16));
            Get_ExFreePool(v8);
          }
        }
      }
      v12 = (loc_140051D08)(a1, a2, 0i64);
      *(Memory + 16) = v12;
      if ( v12 )
      {
        v13 = qword_140085DB0;
        if ( *qword_140085DB0 != &qword_140085DA8 )
          __fastfail(3u);
        *Memory = &qword_140085DA8;
        ret = 1;
        *(Memory + 8) = v13;
        *v13 = Memory;
        qword_140085DB0 = Memory;
      }
    }
    ExReleaseFastMutexUnsafe(&stru_140085DB8);
    KeLeaveCriticalRegion();
    if ( !ret )
      Get_ExFreePool(Memory);
  }
  return ret;
}
// 140085CBC: using guessed type int dword_140085CBC;
// 140085DA8: using guessed type __int64 qword_140085DA8;
// 140085DB0: using guessed type __int64 qword_140085DB0;

//----- (0000000140048670) ----------------------------------------------------
void sub_140048670()
{
  bool v0; // zf
  bool v1; // bl
  __int64 *v2; // rbx
  struct _KEVENT *v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rbx

  if ( dword_140085CBC )
  {
    ExAcquireFastMutex(&stru_140085DB8);
    v0 = dword_140085CBC == 1;
    dword_140085CBC = 2;
    v1 = v0;
    ExReleaseFastMutex(&stru_140085DB8);
    if ( v1 )
    {
      v2 = qword_140085DA8;
      if ( qword_140085DA8 != &qword_140085DA8 )
      {
        do
        {
          v3 = v2[2];
          if ( v3 )
            KeSetEvent(v3 + 3, 0, 0);
          v2 = *v2;
        }
        while ( v2 != &qword_140085DA8 );
        while ( 1 )
        {
          v5 = qword_140085DA8;
          if ( qword_140085DA8 == &qword_140085DA8 )
            break;
          v4 = *qword_140085DA8;
          if ( *(qword_140085DA8 + 8) != &qword_140085DA8 || *(v4 + 8) != qword_140085DA8 )
            __fastfail(3u);
          qword_140085DA8 = *qword_140085DA8;
          *(v4 + 8) = &qword_140085DA8;
          (loc_140051FDC)(*(v5 + 16));
          Get_ExFreePool(v5);
        }
      }
    }
  }
}
// 140085CBC: using guessed type int dword_140085CBC;
// 140085DA8: using guessed type __int64 qword_140085DA8;

//----- (0000000140048738) ----------------------------------------------------
bool __fastcall sub_140048738(unsigned __int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx
  bool result; // al

  v3 = *a3;
  v4 = *a3 + *(a3 + 2);
  result = 0;
  if ( *a3 < v4 && a1 >= v3 && a1 < v4 )
  {
    v5 = a1 + a2;
    if ( v5 >= v3 && v5 <= v4 )
      return 1;
  }
  return result;
}

//----- (0000000140048764) ----------------------------------------------------
char __fastcall sub_140048764(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // r8
  __int64 v4; // r10
  __int64 v5; // rcx
  _QWORD *v6; // r11
  int v7; // eax

  if ( !a2 )
    return 0;
  if ( !a3 )
    return 0;
  if ( !sub_140048738(a2, 6i64, a1) )
    return 0;
  if ( *(v4 + 4) != 27502 )
    return 0;
  if ( ((*v4 >> 31) ^ *v4) == *v4 >> 31 )
    return 0;
  if ( !sub_140048738(v4 + 6, 329i64, v3) )
    return 0;
  if ( !*(v5 + 70) )
    return 0;
  v7 = *(v5 + 34);
  if ( !v7 && !*(v5 + 18) )
    return 0;
  if ( *(v5 + 18) && *(v5 + 26) == -1 || v7 && *(v5 + 38) == -1 )
    return 0;
  *v6 = v5;
  return 1;
}
// 140048793: variable 'v4' is possibly undefined
// 1400487AD: variable 'v3' is possibly undefined
// 1400487B6: variable 'v5' is possibly undefined
// 1400487DE: variable 'v6' is possibly undefined

//----- (00000001400487F0) ----------------------------------------------------
char __fastcall sub_1400487F0(char *a1, unsigned __int64 a2, int a3, __int64 a4)
{
  char v7; // di
  _OWORD *Memory; // rax

  *a4 = a3;
  *(a4 + 8) = a2;
  v7 = 0;
  Memory = EAC_Allocate_Memory(a2);
  *(a4 + 16) = Memory;
  if ( Memory )
  {
    EAC_memcpy(Memory, a1, a2);
    return 1;
  }
  return v7;
}

//----- (0000000140048850) ----------------------------------------------------
char __fastcall sub_140048850(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v8; // rcx
  int v9; // edi
  unsigned __int16 v10; // r10
  char *v11; // rcx
  unsigned __int64 v12; // rsi
  unsigned __int64 *v13; // r8
  __int16 v14; // ax

  if ( a1 )
  {
    v8 = *a1;
    if ( v8 )
    {
      if ( *(a1 + 8) )
      {
        v9 = *(a3 + 2);
        if ( v9 >= 0 )
        {
          v12 = v8 + *(a3 + 6);
          if ( sub_140048738(v12 + 4096, 6i64, a1) )
          {
            v10 = -1;
            if ( v9 <= 0xFFFF )
              v10 = v9;
            v11 = (v12 + 4100);
            if ( *(v12 + 4100) != 25188 && (*(v12 + 4096) - 6i64 >= v10 || sub_140048738(v11, v10, v13)) )
            {
              if ( (a2 - 4) <= 1 || a2 == 11 )
              {
                v14 = 8;
                if ( v10 < 8u )
                  v14 = v10;
                v10 = v14;
              }
              return sub_1400487F0(v11, v10, a2, a4);
            }
          }
        }
        else
        {
          v10 = v9;
          if ( v9 <= 4u )
          {
            v11 = (a3 + 6);
            return sub_1400487F0(v11, v10, a2, a4);
          }
        }
      }
    }
  }
  return 0;
}
// 140048900: variable 'v13' is possibly undefined
// 14004891F: variable 'v10' is possibly undefined
// 140048932: variable 'v11' is possibly undefined

//----- (0000000140048950) ----------------------------------------------------
char __fastcall sub_140048950(unsigned __int16 *a1, int *a2, __int64 a3, __int64 *a4)
{
  char v4; // bl
  __int64 Memory; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 v12; // rax
  _OWORD *v13; // rcx
  unsigned __int64 v14; // r8
  int v15; // eax
  char *v16; // rdx
  __int64 v17; // rcx

  v4 = 0;
  if ( a4 )
  {
    Memory = EAC_Allocate_Memory(0x40ui64);
    v10 = Memory;
    if ( Memory )
    {
      v11 = Memory + 24;
      if ( sub_14005D9A8(Memory + 24, a1, a1[1])
        && (v12 = EAC_Allocate_Memory(*(a2 + 1)), *(v10 + 56) = v12, (v13 = v12) != 0i64) )
      {
        v14 = *(a2 + 1);
        v15 = *a2;
        v16 = *(a2 + 2);
        *(v10 + 48) = v14;
        *(v10 + 16) = a3;
        *(v10 + 40) = v15;
        EAC_memcpy(v13, v16, v14);
        *a4 = v10;
        return 1;
      }
      else
      {
        if ( v11 )
        {
          v17 = *(v11 + 8);
          if ( v17 )
          {
            if ( *v11 && *(v11 + 2) )
            {
              Get_ExFreePool(v17);
              *v11 = 0i64;
            }
          }
        }
        Get_ExFreePool(v10);
      }
    }
  }
  return v4;
}

//----- (0000000140048A30) ----------------------------------------------------
__int64 __fastcall sub_140048A30(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 result; // rax

  if ( a1 )
  {
    v2 = *(a1 + 56);
    if ( v2 )
      Get_ExFreePool(v2);
    if ( a1 != -24 )
    {
      v3 = *(a1 + 32);
      if ( v3 )
      {
        Get_ExFreePool(v3);
        *(a1 + 24) = 0i64;
      }
    }
    return Get_ExFreePool(a1);
  }
  return result;
}

//----- (0000000140048A80) ----------------------------------------------------
char __fastcall sub_140048A80(unsigned __int64 *a1, __int64 a2, int a3, __int64 a4, __int64 a5)
{
  char v5; // r15
  char v8; // r11
  unsigned __int64 v9; // rdx
  unsigned int v10; // r13d
  int v11; // eax
  unsigned int *v12; // rcx
  unsigned __int64 *v13; // r8
  __int64 v14; // r10
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 *v17; // r8
  __int64 v18; // r14
  char *v19; // rcx
  unsigned int v20; // r10d
  _BYTE *v21; // rbx
  unsigned int v22; // r11d
  int v23; // eax
  int v24; // r10d
  unsigned int v25; // r8d
  unsigned int v26; // edx
  _DWORD *v27; // rcx
  _QWORD *v28; // r8
  _QWORD *v29; // rdx
  _QWORD *i; // rcx
  _QWORD *v31; // rax
  int v33; // [rsp+20h] [rbp-40h]
  _QWORD *v34; // [rsp+28h] [rbp-38h] BYREF
  __int128 v35; // [rsp+30h] [rbp-30h] BYREF
  int v36[4]; // [rsp+40h] [rbp-20h] BYREF
  __int64 v37; // [rsp+50h] [rbp-10h]
  char v38; // [rsp+A0h] [rbp+40h]

  v5 = 0;
  v38 = 0;
  v34 = 0i64;
  v8 = 0;
  if ( !a1 || !a2 || !a5 )
    return 0;
  if ( a3 == *a5 - 1 )
  {
    v9 = *(a5 + 112);
    if ( *&KUSER_SHARED_DATA.SystemTime.LowPart - *(a2 + 2) < v9 || !v9 )
    {
      v10 = 0;
      if ( *(a2 + 34) )
      {
        v11 = *(a2 + 38) + 4100;
        v33 = v11;
        do
        {
          if ( sub_140048738(*a1 + v11 + 4 * v10, 4i64, a1) )
          {
            v15 = *v12;
            if ( v15 )
            {
              if ( sub_140048738(v15 + v14 + 4096, 24i64, v13)
                && *(v16 + 4) == 27510
                && ((*v16 >> 31) ^ *v16) != *v16 >> 31 )
              {
                v18 = v16 + 6;
                if ( *(v16 + 6) )
                {
                  if ( sub_140048738(v16 + 24, *(v16 + 6), v17) && sub_14005D918(&v35, v19, v20) )
                  {
                    v21 = *(&v35 + 1);
                    EAC_HashCR32(*(&v35 + 1), v35);
                    v23 = EAC_CRC32(v21, v22, 0);
                    v25 = *(a5 + 104);
                    v26 = 0;
                    if ( !v25 )
                      goto LABEL_37;
                    v27 = (a5 + 28);
                    do
                    {
                      if ( v26 >= 0xA )
                        break;
                      if ( *(v27 - 1) == v24 && *v27 == v23 )
                        v5 = 1;
                      ++v26;
                      v27 += 2;
                    }
                    while ( v26 < v25 );
                    if ( v5 )
                    {
                      v5 = 0;
                      if ( sub_140048850(a1, *(v18 + 10), v18, v36) )
                      {
                        if ( sub_140048950(&v35, v36, a4, &v34) )
                        {
                          v28 = (a5 + 120);
                          if ( a5 != -120 )
                          {
                            v29 = v34;
                            if ( v34 )
                            {
                              for ( i = *v28; v28 != i; i = *i )
                              {
                                if ( *(i[2] + 2i64) <= *(v34[2] + 2i64) )
                                  break;
                              }
                              v31 = i[1];
                              *v34 = i;
                              v29[1] = v31;
                              *v31 = v29;
                              i[1] = v29;
                            }
                          }
                          v38 = 1;
                        }
                        if ( v37 )
                        {
                          Get_ExFreePool(v37);
                          v37 = 0i64;
                        }
                        v21 = *(&v35 + 1);
                      }
                    }
                    else
                    {
LABEL_37:
                      v5 = 0;
                    }
                    if ( v21 )
                    {
                      Get_ExFreePool(v21);
                      v35 = 0i64;
                    }
                  }
                }
              }
            }
          }
          v11 = v33;
          ++v10;
        }
        while ( v10 < *(a2 + 34) );
        return v38;
      }
    }
  }
  return v8;
}
// 140048B37: variable 'v12' is possibly undefined
// 140048B41: variable 'v14' is possibly undefined
// 140048B50: variable 'v13' is possibly undefined
// 140048B62: variable 'v16' is possibly undefined
// 140048B93: variable 'v17' is possibly undefined
// 140048BAA: variable 'v19' is possibly undefined
// 140048BA3: variable 'v20' is possibly undefined
// 140048BD7: variable 'v22' is possibly undefined
// 140048BFC: variable 'v24' is possibly undefined
// 140048A80: using guessed type int var_20[4];
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140048CFC) ----------------------------------------------------
__int64 __fastcall sub_140048CFC(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5)
{
  int v5; // eax
  unsigned int v6; // r13d
  __int64 v7; // r14
  unsigned int v9; // ebx
  unsigned __int64 v10; // rsi
  __int64 *v11; // r12
  __int64 *v12; // r10
  _BYTE *v14; // r15
  unsigned int v15; // r14d
  int v16; // eax
  __int64 v17; // r10
  int v18; // eax
  int v19; // r11d
  __int64 v20; // r15
  __int16 v21; // cx
  int v22; // esi
  __int16 v23; // r10
  int v24; // r11d
  unsigned __int64 v25; // r14
  int v26; // eax
  unsigned __int64 v27; // rcx
  unsigned __int64 *v28; // r8
  int v29; // r11d
  bool v30; // al
  _DWORD *v31; // rcx
  unsigned __int64 *v32; // r8
  __int16 v33; // r10
  unsigned int v34; // r11d
  unsigned int v35; // esi
  unsigned __int64 v36; // rcx
  unsigned int v37; // r14d
  __int64 *v38; // r10
  int i; // eax
  int v40; // r13d
  __int64 v41; // r11
  unsigned int v42; // ebx
  int v43; // eax
  __int64 v44; // r11
  __int64 v45; // r10
  __int64 v46[9]; // [rsp+30h] [rbp-48h] BYREF
  int v47; // [rsp+80h] [rbp+8h]

  v5 = 0;
  v6 = a3;
  v7 = a2;
  v9 = 0;
  if ( !a1 )
    return v9;
  v10 = *a1;
  if ( !*a1 || !*(a1 + 8) || !a2 || !a5 || a3 >= *a5 )
    return v9;
  v11 = (a5 + 8);
  v12 = *(a5 + 8);
  while ( 1 )
  {
    if ( v12 == v11 )
      return v9;
    if ( v5 == a3 )
      break;
    v12 = *v12;
    ++v5;
  }
  if ( *(v12 + 4) != -1 || *(v12 + 5) != -1 )
  {
    if ( *(a4 + 70) < 0xFFu )
    {
      v14 = (a4 + 74);
      v15 = *(a4 + 70);
      v16 = EAC_CRC32((a4 + 74), v15, 0);
      if ( *(v17 + 20) == v16 )
      {
        v18 = EAC_HashCR32(v14, v15);
        if ( v19 == v18 )
        {
          v7 = a2;
          goto LABEL_18;
        }
      }
    }
    return v9;
  }
LABEL_18:
  v20 = v10 + v7;
  if ( sub_140048738(v10 + v7, 8i64, a1) )
  {
    v21 = *(v20 + 4);
    if ( ((v21 - 26220) & 0xFCFF) == 0 && v21 != 26476 && *(v20 + 6) )
    {
      v22 = 0;
      v47 = 0;
      if ( *(v20 + 6) )
      {
        while ( 1 )
        {
          v23 = *(v20 + 4);
          if ( v23 )
            break;
LABEL_50:
          v47 = ++v22;
          if ( v22 >= *(v20 + 6) )
            return v9;
        }
        v24 = v7 + 8;
        v25 = *a1;
        v26 = 8;
        if ( v23 == 26988 )
          v26 = 4;
        if ( sub_140048738(v25 + (v22 * v26 + v24), 4i64, a1) && v29 )
        {
          v30 = sub_140048738(v27, 4i64, v28);
          v34 = 0;
          if ( v30 )
          {
            if ( ((v33 - 26220) & 0xFCFF) != 0 || v33 == 26476 )
              goto LABEL_49;
            v35 = *v31 + 4096;
            if ( sub_140048738(v35 + v25, 335i64, v32) )
            {
              v9 = v35;
              if ( sub_140048764(a1, v36, v46) )
              {
                v37 = v6 + 1;
                if ( v6 + 1 < *a5 )
                {
                  v38 = *v11;
                  for ( i = 0; ; ++i )
                  {
                    if ( v38 == v11 )
                      goto LABEL_38;
                    if ( i == v37 )
                      break;
                    v38 = *v38;
                  }
                  v40 = *(v38 + 4);
                  v41 = v46[0];
                  if ( v40 != -1 || *(v38 + 5) != -1 )
                  {
                    if ( *(v46[0] + 70) < 0xFFu )
                    {
                      v42 = *(v46[0] + 70);
                      v43 = EAC_CRC32((v46[0] + 74), v42, 0);
                      if ( *(v45 + 20) == v43 && v40 == EAC_HashCR32((v44 + 74), v42) )
                        goto LABEL_45;
LABEL_47:
                      v9 = v35;
                    }
                    v22 = v47;
                    v6 = a3;
                    goto LABEL_49;
                  }
LABEL_45:
                  if ( *(v41 + 18) )
                    sub_1400490EC(a1, *(v41 + 26) + 4096i64, v37, v41, a5);
                  else
                    sub_140048A80(a1, v41, v37, v41, a5);
                  goto LABEL_47;
                }
              }
LABEL_38:
              v22 = v47;
              goto LABEL_49;
            }
            v22 = v47;
          }
          v9 = v34;
        }
LABEL_49:
        LODWORD(v7) = a2;
        goto LABEL_50;
      }
      return v9;
    }
  }
  return 0i64;
}
// 140048DB9: variable 'v17' is possibly undefined
// 140048DCD: variable 'v19' is possibly undefined
// 140048E8D: variable 'v29' is possibly undefined
// 140048E93: variable 'v27' is possibly undefined
// 140048E93: variable 'v28' is possibly undefined
// 140048EAC: variable 'v33' is possibly undefined
// 140048EC4: variable 'v31' is possibly undefined
// 140048ED6: variable 'v32' is possibly undefined
// 140048EF0: variable 'v36' is possibly undefined
// 140048F65: variable 'v45' is possibly undefined
// 140048F6D: variable 'v44' is possibly undefined
// 140048F7B: variable 'v41' is possibly undefined
// 140048FED: variable 'v34' is possibly undefined
// 140048CFC: using guessed type __int64 var_48[9];

//----- (0000000140048FFC) ----------------------------------------------------
char __fastcall sub_140048FFC(__int64 a1, __int64 a2, unsigned int a3, int a4, unsigned int *a5)
{
  unsigned __int64 v8; // rax
  __int64 v9; // rbx
  int v10; // esi
  _DWORD *v11; // rcx

  if ( !a1 )
    return 0;
  v8 = *a1;
  if ( !*a1 || !*(a1 + 8) && a3 >= *a5 )
    return 0;
  v9 = v8 + a2;
  if ( !sub_140048738(v8 + a2, 8i64, a1) || *(v9 + 4) != 26994 || ((*v9 >> 31) ^ *v9) == *v9 >> 31 || !*(v9 + 6) )
    return 0;
  v10 = 0;
  if ( *(v9 + 6) )
  {
    do
    {
      if ( sub_140048738(v9 + (4 * v10 + 8), 4i64, a1) )
        sub_140048CFC(a1, *v11 + 4096, a3, a4, a5);
      ++v10;
    }
    while ( v10 < *(v9 + 6) );
  }
  return 1;
}
// 14004909E: variable 'v11' is possibly undefined
// 140048CFC: using guessed type __int64 __fastcall sub_140048CFC(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400490EC) ----------------------------------------------------
char __fastcall sub_1400490EC(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, unsigned int *a5)
{
  unsigned __int64 v5; // r14
  unsigned __int64 v8; // rbp
  char result; // al
  __int64 v10; // rcx
  __int64 v11; // r10
  int v12; // r11d
  unsigned int *v13; // rdi
  unsigned int v14; // r15d
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  __int64 v19; // [rsp+50h] [rbp+8h] BYREF

  v5 = *a1;
  v8 = *a1 + a2;
  result = sub_140048738(v8, 6i64, a1);
  if ( result )
  {
    v13 = a5;
    v14 = *a5;
    while ( a3 < v14 )
    {
      v15 = *(v10 + 4) - 26220;
      if ( !v15 )
        return sub_140048CFC(a1, v11, a3, v12, v13);
      v16 = v15 - 512;
      if ( !v16 )
        return sub_140048CFC(a1, v11, a3, v12, v13);
      v17 = v16 - 256;
      if ( !v17 )
        return sub_140048CFC(a1, v11, a3, v12, v13);
      v18 = v17 - 6;
      if ( !v18 )
        return sub_140048FFC(a1, v11, a3, v12, v13);
      if ( v18 == 508 )
      {
        if ( v5 )
        {
          if ( *(a1 + 8) )
          {
            if ( v11 )
            {
              result = sub_140048738(v8, 335i64, a1);
              if ( result )
              {
                result = sub_140048764(a1, v8, &v19);
                if ( result )
                {
                  v8 = v5 + *(v19 + 26) + 4096i64;
                  result = sub_140048738(v8, 6i64, a1);
                  if ( result )
                    continue;
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}
// 140049140: variable 'v10' is possibly undefined
// 14004918F: variable 'v11' is possibly undefined
// 1400491FC: variable 'v12' is possibly undefined
// 140048CFC: using guessed type __int64 __fastcall sub_140048CFC(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (00000001400493D8) ----------------------------------------------------
__m128 *sub_1400493D8()
{
  __m128 *result; // rax

  result = _InterlockedCompareExchange(&dword_140085F30, 1, 0);
  if ( !result )
  {
    stru_140085EF8.Owner = 0i64;
    stru_140085EF8.Contention = 0;
    stru_140085EF8.Count = 1;
    KeInitializeEvent(&stru_140085EF8.Event, SynchronizationEvent, 0);
    return EAC_memset(&unk_140085DF0, 0, 0x100ui64);
  }
  return result;
}
// 140085F30: using guessed type int dword_140085F30;

//----- (000000014004942C) ----------------------------------------------------
void sub_14004942C()
{
  unsigned __int64 v0; // rax
  unsigned __int64 v1; // rdi
  char *v2; // rbx

  ExAcquireFastMutex(&stru_140085EF8);
  v0 = qword_140085EF0;
  v1 = 0i64;
  if ( qword_140085EF0 )
  {
    v2 = &unk_140085DF8;
    do
    {
      if ( !v2[16] && *v2 )
      {
        Get_ExFreePool(*v2);
        v0 = qword_140085EF0;
      }
      ++v1;
      *(v2 - 8) = 0i64;
      *(v2 + 8) = 0i64;
      v2 += 32;
    }
    while ( v1 < v0 );
  }
  qword_140085EF0 = 0i64;
  ExReleaseFastMutex(&stru_140085EF8);
}
// 140085EF0: using guessed type __int64 qword_140085EF0;

//----- (00000001400496C8) ----------------------------------------------------
char *__fastcall sub_1400496C8(int a1)
{
  char *v1; // rbx
  unsigned __int64 v4; // rax
  _DWORD *v5; // rcx

  v1 = 0i64;
  if ( !a1 )
    return 0i64;
  ExAcquireFastMutex(&stru_140085EF8);
  v4 = 0i64;
  if ( qword_140085EF0 )
  {
    v5 = &unk_140085DF0;
    while ( *v5 != a1 )
    {
      ++v4;
      v5 += 8;
      if ( v4 >= qword_140085EF0 )
        goto LABEL_9;
    }
    v1 = &unk_140085DF0 + 32 * v4;
  }
LABEL_9:
  ExReleaseFastMutex(&stru_140085EF8);
  return v1;
}
// 140085EF0: using guessed type __int64 qword_140085EF0;

//----- (000000014004973C) ----------------------------------------------------
__int64 __fastcall sub_14004973C(unsigned __int8 *a1, __int64 a2)
{
  _BYTE *v3; // r15
  unsigned __int8 v4; // dl
  unsigned __int8 v5; // r12
  char v6; // r13
  unsigned __int8 *v7; // r9
  char v8; // r10
  unsigned int v9; // r11d
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  char v12; // al
  char v13; // cl
  int v14; // r10d
  unsigned __int8 v15; // bl
  unsigned __int64 v16; // rcx
  int v17; // ebp
  unsigned __int16 v18; // r14
  __int16 v19; // si
  char v20; // r15
  int v21; // edx
  int v22; // edx
  int v23; // r10d
  unsigned __int8 v24; // bp
  char v25; // r13
  char v26; // cl
  unsigned __int8 v27; // bp
  int v28; // eax
  __int64 v29; // rdx
  char v30; // dl
  char v31; // dl
  _BYTE *v32; // r10
  _BYTE *v33; // rcx
  _BYTE *v34; // rdx
  _BYTE *v35; // rcx
  bool v36; // zf
  unsigned __int8 v37; // dl
  unsigned __int8 *v38; // r9
  char v39; // al
  char v40; // dl
  unsigned __int8 *v41; // r9
  char v42; // bl
  __int16 v43; // ax
  int v44; // eax
  __int16 v45; // ax
  int v46; // eax
  int v47; // eax
  int v48; // eax
  char v49; // al
  unsigned __int8 v50; // al
  unsigned __int8 v51; // r9
  int v53; // eax
  char v54; // [rsp+38h] [rbp+8h]
  char v55; // [rsp+40h] [rbp+10h]

  v54 = a1;
  v3 = &unk_140076450;
  v4 = 0;
  v5 = 0;
  v6 = a1;
  v7 = a1;
  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  v8 = 16;
  *(a2 + 24) = 0;
  do
  {
    v9 = *v7++;
    if ( v9 > 0x65 )
    {
      switch ( v9 )
      {
        case 0x66u:
          *(a2 + 4) = 102;
          v12 = 8;
          break;
        case 0x67u:
          *(a2 + 5) = 103;
          v12 = 16;
          break;
        case 0xF0u:
          *(a2 + 2) = -16;
          v12 = 32;
          break;
        case 0xF2u:
          *(a2 + 1) = -14;
          v12 = 2;
          break;
        case 0xF3u:
          *(a2 + 1) = -13;
          v12 = 4;
          break;
        default:
          goto LABEL_17;
      }
      goto LABEL_16;
    }
    v10 = v9 - 38;
    if ( v10 > 0x3F )
      break;
    v11 = 0xC000000001010101ui64;
    if ( !_bittest64(&v11, v10) )
      break;
    *(a2 + 3) = v9;
    v12 = 64;
LABEL_16:
    v4 |= v12;
    --v8;
  }
  while ( v8 );
LABEL_17:
  v13 = 1;
  v14 = v4 << 23;
  *(a2 + 24) = v14;
  if ( v4 )
    v13 = v4;
  *(a2 + 6) = v9;
  v15 = v13;
  if ( v9 == 15 )
  {
    LOBYTE(v9) = *v7;
    v3 = &unk_14007649A;
    *(a2 + 7) = *v7++;
  }
  else if ( v9 >= 0xA0u && v9 <= 0xA3u )
  {
    if ( (v13 & 0x10) != 0 )
      v15 = v13 | 8;
    else
      v15 = v13 & 0xF7;
  }
  v16 = v9 >> 2;
  v17 = v9 & 3;
  LOBYTE(v18) = v3[v17 + v3[v16]];
  if ( v18 == 0xFF && (v14 |= 0x3000u, *(a2 + 24) = v14, LOBYTE(v18) = 0, (v9 & 0xFD) == 36) )
  {
    LOBYTE(v18) = 1;
    LOBYTE(v19) = 0;
  }
  else
  {
    LOBYTE(v19) = 0;
    if ( (v18 & 0x80u) != 0 )
    {
      v18 = *&v3[v18 & 0x7F];
      v19 = HIBYTE(v18);
    }
  }
  v20 = *(a2 + 7);
  v21 = v14;
  if ( v20 && (*(&unk_140076450 + v17 + *(&unk_140076450 + v16 + 304) + 304) & v15) != 0 )
  {
    v21 = v14 | 0x3000;
    *(a2 + 24) = v14 | 0x3000;
  }
  if ( (v18 & 1) == 0 )
  {
    if ( (v15 & 0x20) != 0 )
      *(a2 + 24) = v21 | 0x9000;
    goto LABEL_127;
  }
  v22 = v21 | 1;
  *(a2 + 24) = v22;
  v23 = v22;
  v24 = *v7;
  *(a2 + 8) = *v7;
  v25 = v24 >> 6;
  v26 = v24 & 7;
  v27 = (v24 >> 3) & 7;
  *(a2 + 9) = v25;
  v55 = v26;
  *(a2 + 11) = v26;
  *(a2 + 10) = v27;
  if ( v19 && ((v19 << v27) & 0x80u) != 0 )
  {
    v23 = v22 | 0x3000;
    *(a2 + 24) = v22 | 0x3000;
  }
  v28 = v23;
  if ( !v20 && v9 >= 0xD9u && v9 <= 0xDFu )
  {
    v29 = (v9 + 39);
    if ( v25 == 3 )
    {
      v30 = *(&unk_140076450 + 8 * v29 + v27 + 248);
    }
    else
    {
      v26 = v27;
      v30 = *(&unk_140076450 + v29 + 241);
    }
    v28 = v23;
    if ( ((v30 << v26) & 0x80u) != 0 )
    {
      v28 = v23 | 0x3000;
      *(a2 + 24) = v23 | 0x3000;
    }
  }
  if ( (v15 & 0x20) != 0 )
  {
    if ( v25 == 3 )
    {
      *(a2 + 24) = v28 | 0x9000;
    }
    else
    {
      v31 = v9;
      if ( !v20 )
        v31 = v9 & 0xFE;
      v32 = &unk_14007661B;
      if ( !v20 )
        v32 = &unk_140076609;
      v33 = &unk_140076609;
      if ( !v20 )
        v33 = &unk_1400765F1;
      while ( v33 != v32 )
      {
        if ( *v33 == v31 )
        {
          if ( ((v33[1] << v27) & 0x80u) == 0 )
            goto LABEL_62;
          break;
        }
        v33 += 2;
      }
      *(a2 + 24) |= 0x9000u;
    }
  }
LABEL_62:
  if ( !v20 )
  {
    if ( v9 != 140 )
    {
      if ( v9 != 142 )
        goto LABEL_74;
      if ( v27 == 1 )
        goto LABEL_96;
    }
    if ( v27 > 5u )
      goto LABEL_96;
    goto LABEL_97;
  }
  switch ( v9 )
  {
    case ' ':
      goto LABEL_69;
    case '!':
      goto LABEL_67;
    case '"':
LABEL_69:
      v25 = 3;
      if ( v27 <= 4u && v27 != 1 )
        goto LABEL_97;
      goto LABEL_96;
  }
  if ( v9 != 35 )
  {
LABEL_74:
    if ( v25 == 3 )
    {
      if ( v20 )
      {
        v34 = &unk_140076654;
        v35 = &unk_14007662A;
      }
      else
      {
        v34 = &unk_14007662A;
        v35 = &unk_14007661B;
      }
      while ( *v35 != v9 )
      {
        v35 += 3;
        if ( v35 == v34 )
          goto LABEL_97;
      }
      if ( (v15 & v35[1]) == 0 || ((v35[2] << v27) & 0x80u) != 0 )
        goto LABEL_97;
LABEL_96:
      *(a2 + 24) |= 0x11000u;
      goto LABEL_97;
    }
    if ( !v20 )
      goto LABEL_97;
    if ( v9 != 80 )
    {
      if ( v9 == 197 )
        goto LABEL_96;
      if ( v9 == 214 )
      {
        v36 = (v15 & 6) == 0;
LABEL_91:
        if ( !v36 )
          goto LABEL_96;
        goto LABEL_97;
      }
      if ( v9 != 215 && v9 != 247 )
        goto LABEL_97;
    }
    v36 = (v15 & 9) == 0;
    goto LABEL_91;
  }
LABEL_67:
  v25 = 3;
  if ( (v27 - 4) <= 1u )
    goto LABEL_96;
LABEL_97:
  v37 = v7[1];
  v38 = v7 + 2;
  if ( v27 <= 1u )
  {
    if ( v9 == 0xF6 )
    {
      LOBYTE(v18) = v18 | 2;
    }
    else if ( v9 == 0xF7 )
    {
      LOBYTE(v18) = v18 | 0x10;
    }
  }
  if ( v25 )
  {
    if ( v25 == 1 )
    {
      v5 = 1;
    }
    else if ( v25 == 2 )
    {
      v5 = 2;
      if ( (v15 & 0x10) == 0 )
        v5 = 4;
    }
  }
  else if ( (v15 & 0x10) != 0 )
  {
    v5 = v55 != 6 ? 0 : 2;
  }
  else
  {
    v5 = 0;
    if ( v55 == 5 )
      v5 = 4;
  }
  if ( v25 != 3 && v55 == 4 && (v15 & 0x10) == 0 )
  {
    *(a2 + 24) |= 2u;
    ++v38;
    *(a2 + 13) = v37 >> 6;
    v39 = (v37 >> 3) & 7;
    *(a2 + 12) = v37;
    v40 = v37 & 7;
    *(a2 + 14) = v39;
    *(a2 + 15) = v40;
    if ( v40 == 5 && (v25 & 1) == 0 )
      v5 = 4;
  }
  v41 = v38 - 1;
  switch ( v5 )
  {
    case 1u:
      *(a2 + 24) |= 0x40u;
      *(a2 + 20) = *v41;
      break;
    case 2u:
      *(a2 + 24) |= 0x80u;
      *(a2 + 20) = *v41;
      break;
    case 4u:
      *(a2 + 24) |= 0x100u;
      *(a2 + 20) = *v41;
      break;
  }
  v6 = v54;
  v7 = &v41[v5];
LABEL_127:
  if ( (v18 & 0x10) != 0 )
  {
    v42 = v15 & 8;
    if ( (v18 & 0x40) != 0 )
    {
      if ( v42 )
      {
        *(a2 + 24) |= 0x208u;
        v43 = *v7;
        LOBYTE(v7) = v7 + 2;
        *(a2 + 16) = v43;
        goto LABEL_147;
      }
LABEL_150:
      *(a2 + 24) |= 0x210u;
      v53 = *v7;
      LOBYTE(v7) = v7 + 4;
      *(a2 + 16) = v53;
      goto LABEL_147;
    }
    v44 = *(a2 + 24);
    if ( v42 )
    {
      *(a2 + 24) = v44 | 8;
      v45 = *v7;
      v7 += 2;
      *(a2 + 16) = v45;
    }
    else
    {
      *(a2 + 24) = v44 | 0x10;
      v46 = *v7;
      v7 += 4;
      *(a2 + 16) = v46;
    }
  }
  if ( (v18 & 4) != 0 )
  {
    v47 = *(a2 + 24);
    if ( (v47 & 0x10) != 0 )
    {
      v48 = v47 | 8;
      goto LABEL_139;
    }
    if ( (v47 & 8) != 0 )
    {
      v48 = v47 | 0x800;
LABEL_139:
      *(a2 + 24) = v48;
      *(a2 + 20) = *v7;
    }
    else
    {
      *(a2 + 24) = v47 | 8;
      *(a2 + 16) = *v7;
    }
    v7 += 2;
  }
  if ( (v18 & 2) != 0 )
  {
    *(a2 + 24) |= 4u;
    v49 = *v7++;
    *(a2 + 16) = v49;
  }
  if ( (v18 & 0x40) != 0 )
    goto LABEL_150;
  if ( (v18 & 0x20) != 0 )
  {
    *(a2 + 24) |= 0x204u;
    v50 = *v7;
    LOBYTE(v7) = v7 + 1;
    *(a2 + 16) = v50;
  }
LABEL_147:
  v51 = v7 - v6;
  *a2 = v51;
  if ( v51 > 0xFu )
  {
    *(a2 + 24) |= 0x5000u;
    v51 = 15;
    *a2 = 15;
  }
  return v51;
}

//----- (0000000140049E70) ----------------------------------------------------
// from @Swiftik
LONG_PTR __fastcall EAC_CheckForKernelPatches(__int64 a1, __int64 a2)
{
  unsigned int v4; // ebx
  int v5; // eax
  int v6; // edx
  unsigned __int64 idx; // rdi
  char v8; // di
  unsigned int v9; // edx
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rdx
  unsigned int v12; // edi
  unsigned __int64 v13; // r9
  int v14; // ecx
  char v15; // dl
  LONG CompareUnicodeString; // edx
  __int64 Memory; // rax
  __int64 v18; // rdi
  char v19; // al
  __int64 v20; // rcx
  __int64 v21; // rdx
  int v23[6]; // [rsp+30h] [rbp-D0h]
  __int16 v24; // [rsp+48h] [rbp-B8h]
  int v25[15]; // [rsp+4Ah] [rbp-B6h]
  int v26[16]; // [rsp+86h] [rbp-7Ah]
  _UNICODE_STRING unicode_string; // [rsp+C8h] [rbp-38h] BYREF
  __int128 v28[2]; // [rsp+D8h] [rbp-28h] BYREF
  _UNICODE_STRING unicode_string_2; // [rsp+F8h] [rbp-8h] BYREF
  _BYTE string_1[60]; // [rsp+108h] [rbp+8h] BYREF
  _BYTE string[60]; // [rsp+144h] [rbp+44h] BYREF

  v4 = 0;
  v5 = EAC_CompareToDisk() - 1;
  if ( !v5 )
  {
    v4 = -1073610745;
    goto LABEL_36;
  }
  if ( v5 == 1 )
  {
    v4 = -1073610744;
    goto LABEL_36;
  }
  if ( KUSER_SHARED_DATA.NtMajorVersion <= 6
    && (KUSER_SHARED_DATA.NtMajorVersion != 6 || KUSER_SHARED_DATA.NtMinorVersion - 2 > 1) )
  {
    goto LABEL_29;
  }
  if ( !(loc_1400522E4)(&unicode_string, &unicode_string_2) )
  {
    Memory = EAC_Allocate_Memory(0x8208ui64);
    v18 = Memory;
    if ( Memory )
    {
      EAC_memset((Memory + 8), 0, 0x8200ui64);
      *(v18 + 8) = 0xAB7B1B6F;
      *(v18 + 0xC) = 0xFF868F4A;
      *(v18 + 0x10) = 0x7AB78BD4;
      *(v18 + 0x14) = 0x16751F01;
      *(v18 + 0x18) = 0x5003E30C;
      *(v18 + 0x1C) = 0x2D64E30A;
      *v18 = 0x18i64;
      (loc_140045210)(a2, 0x644BFB41i64);
      Get_ExFreePool(v18);
    }
    goto LABEL_29;
  }
  if ( unicode_string.Buffer )
  {
    v25[0] = -2038120271;
    v6 = 265237001;
    v25[1] = 328643148;
    v25[2] = 1291583427;
    idx = 0i64;
    v25[3] = 932037941;
    v25[4] = -1435003552;
    v25[5] = 489892910;
    v25[6] = 1100756018;
    v25[7] = -1828757474;
    v25[8] = 637055803;
    v25[9] = 2052821144;
    v25[10] = 2026340269;
    v25[11] = 1546716256;
    v25[12] = 514443694;
    v25[13] = -1192070178;
    v25[14] = -41480722;
    memset(string, 0, sizeof(string));
    do
    {
      v6 = __ROL4__(1103515245 * v6 + 12345, 4);
      *&string[idx * 4] = v25[idx] ^ v6;
      ++idx;
    }
    while ( idx < 15 );
    v8 = 1;
    if ( !Get_CompareUnicodeString(&unicode_string, string) )
      goto LABEL_15;

    v26[0] = -1092867040;
    v9 = -384802411;
    v26[1] = 1141703083;
    v26[2] = 1352782229;
    v10 = 0i64;
    v26[3] = 728422944;
    v26[4] = -440827362;
    v26[5] = -94537884;
    v26[6] = 1391369617;
    v26[7] = -132219601;
    v26[8] = 1485060530;
    v26[9] = 1568417659;
    v26[10] = 956062372;
    v26[11] = -1250453123;
    v26[12] = 1601721500;
    v26[13] = -747429375;
    v26[14] = 1670733649;
    memset(string_1, 0, sizeof(string_1));
    do
    {
      v9 = -(((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13) ^ (32 * (((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13))));
      *&string_1[v10 * 4] = v26[v10] ^ v9;
      ++v10;
    }
    while ( v10 < 15 );
    v8 = 3;
    if ( Get_CompareUnicodeString(&unicode_string, string_1) )
    {
      LOBYTE(v4) = 1;
    }
    else
    {
LABEL_15:
      if ( (v8 & 2) == 0 )
      {
LABEL_17:
        memset(string, 0, sizeof(string));
        EAC_Free_UnicodeString(&unicode_string);
        v4 = v4 != 0 ? 0xC0020010 : 0;
        goto LABEL_18;
      }
    }
    memset(string_1, 0, sizeof(string_1));
    goto LABEL_17;
  }
LABEL_18:
  if ( unicode_string_2.Buffer )
  {
    v23[0] = 387321448;
    v24 = -11499;
    v23[1] = 2115200480;
    v11 = 0i64;
    v12 = 392302086;
    v23[2] = -2062462759;
    v23[3] = 476292352;
    v23[4] = 569521120;
    v13 = 24i64;
    v23[5] = 67689139;
    memset(v28, 0, 26);

    do
    {
      v14 = v23[v11] ^ v12;
      v12 = __ROL4__(214013 * v12 + 2531011, 3);
      *(v28 + v11 * 4) = v14;
      ++v11;
    }
    while ( v11 < 6 );

    do
    {
      v15 = v12;
      v12 >>= 8;
      *(v28 + v13) = *(v23 + v13) ^ v15;
      ++v13;
    }
    while ( v13 < 0x1A );

    CompareUnicodeString = Get_CompareUnicodeString(&unicode_string_2, v28);
    memset(v28, 0, 0x1Aui64);
    if ( CompareUnicodeString )
      v4 = -1073610735;
    EAC_Free_UnicodeString(&unicode_string_2);
  }
  if ( !v4 )
  {
LABEL_29:
    (loc_140060938)(a2, 1073807366i64);
    v4 = (loc_140049D44)(a1, a2);
  }
  if ( v4 != 0x40031000 )
  {
LABEL_36:
    v21 = v4;
    v20 = a2;
    goto LABEL_37;
  }
  (loc_140045D3C)(a2);
  v19 = (loc_140007594)(a2);
  v20 = a2;
  if ( !v19 )
  {
    v21 = 0xC0020019i64;
LABEL_37:
    (loc_1400451A0)(v20, v21);
    return sub_140017EE8();
  }
  sub_140060648(a2, 0x40031000);
  return sub_140017EE8();
}
// 140049E70: using guessed type char unicode_string_2[8];
// 140049E70: using guessed type char unicode_string[8];
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014004AC58) ----------------------------------------------------
// from @Swiftik
__int64 __fastcall EAC_CRC32(_BYTE *a1, unsigned int Size, unsigned int Value)
{
  __int64 idx; // r9
  __int64 v4; // rax

  if ( Size )
  {
    idx = Size;
    do
    {
      v4 = (Value ^ *a1++);
      Value = dword_140076670[v4] ^ (Value >> 8);
      --idx;
    }
    while ( idx );
  }
  return Value;
}
// 140076670: using guessed type _DWORD dword_140076670[338];

//----- (000000014004AC88) ----------------------------------------------------
char __fastcall sub_14004AC88(unsigned __int64 a1, unsigned __int64 Size, __int64 a3)
{
  __int64 BaseAddress; // r14
  char ret; // bp
  __int64 Buufer; // rdi
  __int64 Memory; // rax
  _IMAGE_NT_HEADERS *Nt_Headers; // rax MAPDST
  DWORD ImageBase; // eax

  BaseAddress = a1;
  ret = 0;
  Buufer = 0i64;
  if ( !a1 || Size < 0x1000 )
    return 0;

  if ( a1 < MmHighestUserAddress )
  {
    if ( a1 + Size >= MmHighestUserAddress )
      return 0;
    goto LABEL_10;
  }
  if ( Size >= 0xA000 )
    return 0;
  Memory = EAC_Allocate_Memory(Size);
  Buufer = Memory;
  if ( Memory )
  {
    if ( MmVirtualMemory(BaseAddress, Size, Memory) != Size )
    {
LABEL_16:
      Get_ExFreePool(Buufer);
      return ret;
    }
    BaseAddress = Buufer;
LABEL_10:
    Nt_Headers = Get_Nt_Headers(BaseAddress, Size);
    if ( Nt_Headers )
    {
      *a3 = Nt_Headers->FileHeader.TimeDateStamp;
      *(a3 + 4) = Nt_Headers->FileHeader.Machine;
      *(a3 + 6) = Nt_Headers->FileHeader.Characteristics;
      if ( Nt_Headers->OptionalHeader.Magic == 267 )
        ImageBase = Nt_Headers->OptionalHeader.ImageBase;
      else
        ImageBase = Nt_Headers->OptionalHeader.BaseOfData;
      *(a3 + 8) = ImageBase;
      ret = 1;
      *(a3 + 12) = Nt_Headers->OptionalHeader.SizeOfImage;
      *(a3 + 16) = Nt_Headers->OptionalHeader.BaseOfCode;
      *(a3 + 20) = Nt_Headers->OptionalHeader.SizeOfCode;
      *(a3 + 24) = Nt_Headers->OptionalHeader.AddressOfEntryPoint;
      *(a3 + 28) = Nt_Headers->OptionalHeader.CheckSum;
      *(a3 + 32) = 0;
    }
    if ( !Buufer )
      return ret;
    goto LABEL_16;
  }
  return ret;
}

//----- (000000014004ADA0) ----------------------------------------------------
_OWORD *__fastcall sub_14004ADA0(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        int a4,
        int a5,
        unsigned __int16 *a6,
        __int16 a7,
        _QWORD *a8)
{
  int v9; // r14d
  _OWORD *ret; // r12
  struct_eData_6 *Memory; // rax MAPDST
  struct_eData_6 *eData; // rdi
  char v14; // cl
  __int64 v15; // r9
  unsigned __int64 v16; // rdx
  unsigned __int16 v17; // ax
  _WORD *p_word20; // rcx
  int v19; // r8d
  unsigned __int64 v20; // r11
  __int64 v21; // rdx
  __int64 v22; // r10
  _WORD *v23; // rax
  _OWORD *p_oword260; // r14
  __int16 word238; // ax
  char v26; // al
  unsigned int *v27; // r13
  _QWORD *v28; // rbx
  unsigned __int16 v29; // r15
  __int64 idx; // r15
  unsigned __int64 v31; // rbx
  unsigned int v32; // r14d
  _OWORD *Buffer; // rax
  unsigned int *v36; // [rsp+48h] [rbp-F0h] BYREF
  UNICODE_STRING Unicode_string; // [rsp+50h] [rbp-E8h] BYREF
  _QWORD *v38; // [rsp+60h] [rbp-D8h]
  _OWORD *v39; // [rsp+68h] [rbp-D0h]
  char v41[184]; // [rsp+80h] [rbp-B8h] BYREF

  v9 = a2;
  ret = 0i64;
  if ( a3 > 0x8000 )
    return 0i64;
  Memory = EAC_Allocate_Memory(0x1260ui64);
  eData = Memory;
  if ( !Memory )
    return 0i64;

  EAC_memset(Memory, 0, 0x260ui64);
  *&eData->char0 = 0xA;
  eData->dword4 = 1346718061;
  eData->word8 = 2;
  eData->qwordE = a1;
  eData->dword16 = v9;
  eData->dword1A = a4;
  v14 = 0x40;
  if ( a5 )
    v14 = a5;

  eData->byte1E = v14;
  eData->word220 = a7;
  if ( a6 )
  {
    v15 = *(a6 + 1);
    if ( v15 )
    {
      v16 = *a6;
      if ( v16 )
      {
        v17 = a6[1];
        if ( v17 )
        {
          p_word20 = &eData->word20;
          v19 = 0;
          if ( (v16 & 1) != 0 || (v17 & 1) != 0 || v16 > v17 || v17 == 0xFFFF )
            v19 = 0xC000000D;

          if ( v19 < 0 )
          {
            *p_word20 = 0;
          }
          else
          {
            v20 = v16 >> 1;
            v21 = 256i64;
            v22 = v15 - p_word20;
            do
            {
              if ( !(v20 + v21 - 0x100) )
                break;

              *p_word20 = *(p_word20 + v22);
              ++p_word20;
              --v21;
            }
            while ( v21 );
            v23 = p_word20 - 1;
            if ( v21 )
              v23 = p_word20;
            *v23 = 0;
          }
          if ( EAC_Copy_Unicode_from_Unicode(a6, &Unicode_string) )
            eData->byte1F = (*a6 - *&Unicode_string.Length) >> 1;
        }
      }
    }
  }
  p_oword260 = &eData->oword260;
  if ( a1 && a2 >= 0x1000 && sub_14004AC88(a1, a2, &eData->gap222[0x12]) )
  {
    word238 = eData->word238;
    if ( word238 == 332 )
    {
      v26 = 32;
    }
    else if ( word238 == -31132 || word238 == -21916 )
    {
      v26 = 64;
    }
    else
    {
      v26 = 0;
    }
    eData->byte1E = v26;
    if ( a1 < MmHighestUserAddress )
    {
      EAC_IsUsermodeValidAddress(a1, a2, 1);
      if ( GetModuleInfo(a1, a2, 0i64, &v36) )
      {
        v27 = v36;
        sub_14005F67C(a1, eData->byte1E, v36, eData->gap222);
        v39 = &eData->oword260;
        v28 = (v27 + *(v27 + 10) + 24);
        v38 = v28;
        v29 = 0;
        while ( v29 < *(v27 + 3) )
        {
          EAC_IsUsermodeValidAddress(v28, 40i64, 1);
          *p_oword260 = *v28;
          ++eData->word254;
          ++v29;
          v28 += 5;
          v38 = v28;
          p_oword260 = (p_oword260 + 8);
          v39 = p_oword260;
        }
        if ( sub_14001E77C(a1, v41, 128) )
        {
          Unicode_string.Buffer = v41;
          idx = -1i64;

          do
            ++idx;
          while ( v41[idx] );

          v36 = idx;
          Unicode_string.Length = idx;
          Unicode_string.MaximumLength = idx + 1;
          EAC_memcpy(p_oword260, v41, idx);
          LODWORD(p_oword260) = idx + p_oword260;
          eData->word25A = idx;
        }
      }
      else
      {
        eData->dword1A |= 0x80u;
      }
    }
    v31 = a3;
  }
  else
  {
    eData->dword1A |= 0x80u;
    v31 = a3;
  }
  v32 = p_oword260 - eData;
  eData->unsigned_intA = v32;
  if ( v32 + v31 >= v32 )
  {
    Buffer = EAC_Allocate_Memory(v32 + v31);
    ret = Buffer;
    if ( Buffer )
    {
      EAC_memcpy(Buffer, &eData->char0, eData->unsigned_intA);
      if ( v31 )
      {
        if ( a8 )
          *a8 = ret + *(ret + 0xA);
      }
    }
  }
  Get_ExFreePool(eData);
  return ret;
}
// 14004AECB: conditional instruction was optimized away because r8d.4==0
// 14004ADA0: using guessed type char var_B8[184];

//----- (000000014004B198) ----------------------------------------------------
__int64 __fastcall sub_14004B198(__int64 Object, __int64 a2)
{
  unsigned int ret; // ebx
  unsigned __int64 v6; // rcx
  unsigned int v7; // eax
  __int64 Process; // rdi
  __int64 CurrentProcess; // rax
  __int64 BaseAddress; // rax
  __int128 Buffer[2]; // [rsp+30h] [rbp-19h] BYREF
  __int128 v12; // [rsp+50h] [rbp+7h]
  char ApcState[64]; // [rsp+60h] [rbp+17h] BYREF
  unsigned __int64 ThreadInfo; // [rsp+B0h] [rbp+67h] BYREF
  char Length; // [rsp+C0h] [rbp+77h] BYREF

  ret = 4;
  memset(Buffer, 0, sizeof(Buffer));
  v12 = 0i64;

  if ( !Object || !a2 )
    return 3i64;

  if ( EAC_Get_Thread_Info(Object, &ThreadInfo) < 0 )
    return ret;

  if ( ThreadInfo > MmHighestUserAddress )
    return 5i64;

  if ( !ThreadInfo )
    return 2i64;

  v6 = *(a2 + 0xB8);
  if ( ThreadInfo >= v6 && ThreadInfo < *(a2 + 0xC0) + v6 )
    return 1i64;


  if ( *a2 != 0x2D || *(a2 + 0x28) != 32 )
  {
    v7 = sub_140035F88();
    if ( v7 )
    {
      Process = *(v7 + Object);
      if ( Process )
      {
        if ( Get_KeStackAttachProcess(*(v7 + Object), ApcState) )
        {
          if ( Get_ZwQueryVirtualMemory(-1i64, ThreadInfo, 0, Buffer, 48i64, &Length) >= 0 )
          {
            ret = 0;
            if ( (DWORD2(v12) & 0x1000000) == 0 )
            {
              CurrentProcess = Get_PsGetCurrentProcess();
              BaseAddress = Get_PsGetProcessSectionBaseAddress(CurrentProcess);
              if ( BaseAddress != *(&Buffer[0] + 1) || (DWORD2(v12) & 0x40000) == 0 )
                ret = 2;
            }
          }
          (loc_140054154)(Process, ApcState);   // KeUnstackDetachProcess
        }
      }
    }
    return ret;
  }
  return 0i64;
}

//----- (000000014004B2F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_14004B2F0(_QWORD *a1)
{
  __int64 v2; // rsi
  unsigned __int64 result; // rax MAPDST
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rbp
  __int64 Memory; // rax
  __int64 v7; // rbx
  __int64 v8; // r9
  unsigned __int64 v9; // r8
  int v10; // r10d
  _BYTE *v11; // rdx
  unsigned int v12; // r10d
  char v13; // cl
  unsigned __int64 v14; // rcx

  result = a1[1];
  if ( result > 0x80000 )
    LODWORD(result) = 0x80000;
  v2 = result & 0xFF000;

  result = Get_MmGetPhysicalAddress(*a1 & 0xFFFFFFFFFFFFFFFEui64);
  v4 = 0i64;
  if ( result )
  {
    result = EAC_MmMapIoSpace(result, v2, 1u);
    v5 = result;
    if ( result )
    {
      Memory = EAC_Allocate_Memory(0x8208ui64);
      v7 = Memory;
      if ( Memory )
      {
        EAC_memset((Memory + 8), 0, 0x8200ui64);
        v8 = v7 + 8;
        *v7 = 0i64;
        *(v7 + 8) = 0x510E0F49;
        v9 = 24i64;
        *(v7 + 12) = 0x29E7D404;
        *(v7 + 16) = 0xC9018834;
        *(v7 + 24) = 0x1E995E61;
        *(v7 + 28) = 0x12C71FE8;
        v10 = (1293297367 * (v5 >> 2)) ^ 0xBE0E90C0;
        *(v7 + 20) = (1293297367 * (v5 >> 2)) ^ 0xAE25B032;
        if ( v2 )
        {
          do
          {
            if ( v4 >= 0x8000 )
              break;
            v11 = (v4 + v5);
            ++v9;
            v12 = __ROR4__(
                    ((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13) ^ (32
                                                                     * (((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13))),
                    2);
            v13 = 8 * (v4++ & 3);
            v11[v8 - v5 + 24] = *v11 ^ (v12 >> v13);
            v10 = *v11 ^ v12;
          }
          while ( v4 < v2 );
        }
        v14 = (v9 + 255) & 0xFFFFFFFFFFFFFF00ui64;
        while ( v9 < v14 )
        {
          v10 *= 0x4D1626D7;
          *(v9 + v8) = BYTE1(v10);
          ++v9;
        }
        *(v7 + 24) ^= v10;
        *(v7 + 28) ^= v4;
        *v7 = v9;
        (loc_140016B54)(768039549i64, v7 + 8);
        Get_ExFreePool(v7);
      }
      return Get_MmUnmapIoSpace(v5, v2);
    }
  }
  return result;
}
// 14004B323: mask 0xFFFFFFFFFFFFF000 is shortened because rsi.8 <= 0x80000

//----- (000000014004B5CC) ----------------------------------------------------
__int64 sub_14004B5CC()
{
  __int64 v0; // rbx
  __int64 Memory; // rbp
  __int64 v2; // r14
  struct _FAST_MUTEX *v3; // r13
  unsigned int v4; // eax
  __int64 v5; // rdi
  unsigned int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // r15d
  __int64 *v9; // r12
  __int64 v10; // rsi
  __int64 *v11; // r15
  __int64 ProcessId; // rax
  unsigned int v13; // esi
  __int64 v14; // rax
  unsigned int v15; // edx
  _QWORD *v16; // rcx
  PVOID *v17; // rsi
  PVOID Object; // [rsp+50h] [rbp+8h] BYREF

  v0 = 0i64;
  Memory = EAC_Allocate_Memory(0x1000ui64);
  if ( Memory )
  {
    v2 = EAC_Allocate_Memory(0x1000ui64);
    if ( v2 )
    {
      v3 = EAC_Allocate_KeInitializeEvent(1);
      if ( v3 )
      {
        v4 = sub_140052F70(Memory);
        v5 = v4;
        if ( v4 )
        {
          v6 = sub_140052EF4(v2, 0x200u);
          v7 = v6;
          if ( v6 )
          {
            if ( v5 != 512 && v6 != 512 )
            {
              v8 = 0;
              v9 = v2;
              while ( sub_140022EAC(v3, *v9, 0i64, 0) )
              {
                ++v8;
                ++v9;
                if ( v8 >= v7 )
                {
                  v10 = 0i64;
                  if ( v5 )
                  {
                    v11 = Memory;
                    while ( 1 )
                    {
                      ProcessId = Get_PsGetProcessId(*v11);
                      if ( Get_PsLookupProcessByProcessId(ProcessId, &Object) < 0 )
                        break;
                      ObfDereferenceObject(Object);
                      if ( !sub_14002307C(v3) )
                        break;
                      v10 = (v10 + 1);
                      ++v11;
                      if ( v10 >= v5 )
                        goto LABEL_25;
                    }
                    v0 = *(Memory + 8 * v10);
                    if ( v0 )
                    {
                      v13 = sub_140052EF4(v2, 0x200u);
                      if ( v13 )
                      {
                        v14 = Get_PsGetProcessId(v0);
                        v15 = 0;
                        v16 = v2;
                        while ( *v16 != v14 )
                        {
                          ++v15;
                          ++v16;
                          if ( v15 >= v13 )
                          {
                            if ( sub_140052928(v0) )
                              goto LABEL_25;
                            break;
                          }
                        }
                      }
                      v0 = 0i64;
                    }
                  }
                  break;
                }
              }
            }
          }
        }
LABEL_25:
        sub_140023184(v3);
      }
      else
      {
        v5 = Object;
      }
      Get_ExFreePool(v2);
    }
    else
    {
      v5 = Object;
    }
    if ( v5 )
    {
      v17 = Memory;
      do
      {
        if ( *v17 != v0 )
          ObfDereferenceObject(*v17);
        ++v17;
        --v5;
      }
      while ( v5 );
    }
    Get_ExFreePool(Memory);
  }
  return v0;
}
// 14004B66C: conditional instruction was optimized away because eax.4 is in (1..1FF|>=201u)
// 140052928: using guessed type __int64 __fastcall sub_140052928(_QWORD);

//----- (000000014004B794) ----------------------------------------------------
struct _KPROCESS *EAC_Iterate_EPROCESS()
{
  __int64 ret; // rdi
  __int64 CurEProcess; // rsi
  struct _KPROCESS *i; // rcx
  __int64 ProcessId; // rax
  __int64 CurrentEProcess; // rax
  struct _KPROCESS *EProcess; // rbx
  PVOID Object; // [rsp+30h] [rbp+8h] BYREF

  ret = 0i64;
  CurEProcess = EAC_Get_EPROCESS(0i64);
  for ( i = CurEProcess; ; i = EProcess )
  {
    CurrentEProcess = EAC_Get_EPROCESS(i);
    EProcess = CurrentEProcess;
    if ( !CurrentEProcess || CurrentEProcess == CurEProcess )
      break;

    ProcessId = Get_PsGetProcessId(CurrentEProcess);
    if ( Get_PsLookupProcessByProcessId(ProcessId, &Object) < 0 )
      return EProcess;

    ObfDereferenceObject(Object);
  }
  return ret;
}

//----- (000000014004BC54) ----------------------------------------------------
unsigned __int8 *__fastcall sub_14004BC54(_DWORD *a1, unsigned __int8 *a2, int a3)
{
  int v3; // ebp
  unsigned __int8 *v4; // rbx
  int v5; // r10d
  _DWORD *v6; // rdi
  int v7; // r9d
  int v8; // esi
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // r8d
  int v14; // r8d
  int v15; // r9d
  int v16; // r10d
  int v17; // r10d
  int v18; // ecx
  int v19; // ecx
  int v20; // edx
  int v21; // edx
  int v22; // r15d
  int v23; // r8d
  int v24; // r13d
  int v25; // r9d
  int v26; // r10d
  int v27; // r10d
  int v28; // r14d
  int v29; // r11d
  int v30; // r12d
  int v31; // ecx
  int v32; // r8d
  int v33; // esi
  int v34; // ecx
  int v35; // edx
  unsigned __int8 *v36; // r10
  int v37; // ebp
  int v38; // edx
  int v39; // r8d
  int v40; // ebx
  int v41; // r9d
  int v42; // edi
  int v43; // ecx
  int v44; // edx
  int v45; // r8d
  int v46; // r9d
  int v47; // ecx
  int v48; // edx
  int v49; // r8d
  int v50; // r9d
  int v51; // ecx
  int v52; // edx
  int v53; // r11d
  int v54; // r8d
  int v55; // r9d
  int v56; // edx
  int v57; // r8d
  int v58; // r9d
  int v59; // r11d
  int v60; // edx
  int v61; // r8d
  int v62; // r9d
  int v63; // r11d
  int v64; // r8d
  int v65; // r9d
  int v66; // edx
  int v67; // ecx
  int v68; // r8d
  int v69; // r9d
  int v70; // edx
  int v71; // ecx
  int v72; // r8d
  int v73; // r9d
  int v74; // edx
  int v75; // ecx
  int v76; // r8d
  int v77; // r9d
  int v78; // edx
  int v79; // ebp
  int v80; // esi
  int v81; // r9d
  int v82; // eax
  int v83; // r9d
  int v84; // eax
  int v86; // [rsp+0h] [rbp-78h]
  int v87; // [rsp+4h] [rbp-74h]
  int v88; // [rsp+8h] [rbp-70h]
  int v89; // [rsp+Ch] [rbp-6Ch]
  int v90; // [rsp+10h] [rbp-68h]
  int v91; // [rsp+14h] [rbp-64h]
  int v92; // [rsp+18h] [rbp-60h]
  int v93; // [rsp+1Ch] [rbp-5Ch]
  int v94; // [rsp+20h] [rbp-58h]
  int v95; // [rsp+24h] [rbp-54h]
  int v96; // [rsp+28h] [rbp-50h]
  unsigned __int8 *v98; // [rsp+88h] [rbp+10h]
  int v100; // [rsp+98h] [rbp+20h]

  v98 = a2;
  v3 = a1[2];
  v4 = a2;
  v5 = a1[3];
  v6 = a1;
  v7 = a1[4];
  v8 = a1[5];
  while ( 1 )
  {
    v95 = v7;
    v93 = v3;
    v9 = *v4 | ((v4[1] | (*(v4 + 1) << 8)) << 8);
    v94 = v5;
    v6[22] = v9;
    v100 = v9;
    v96 = v8;
    v10 = v5 + __ROL4__(v3 + (v8 ^ v5 & (v7 ^ v8)) - 680876936 + v9, 7);
    v11 = v4[4] | ((v4[5] | ((v4[6] | (v4[7] << 8)) << 8)) << 8);
    v6[23] = v11;
    v88 = v11;
    v12 = v10 + __ROL4__(v8 + (v7 ^ v10 & (v5 ^ v7)) - 389564586 + v11, 12);
    v13 = v4[8] | ((v4[9] | ((v4[10] | (v4[11] << 8)) << 8)) << 8);
    v6[24] = v13;
    v92 = v13;
    v14 = v12 + __ROR4__(v13 + (v5 ^ v12 & (v10 ^ v5)) + v7 + 606105819, 15);
    v87 = v4[12] | ((v4[13] | (*(v4 + 7) << 8)) << 8);
    v6[25] = v87;
    v15 = v14 + __ROR4__(v5 + (v10 ^ v14 & (v10 ^ v12)) - 1044525330 + v87, 10);
    v16 = v4[16] | ((v4[17] | (*(v4 + 9) << 8)) << 8);
    v6[26] = v16;
    v90 = v16;
    v17 = v15 + __ROL4__(v16 + (v12 ^ v15 & (v14 ^ v12)) + v10 - 176418897, 7);
    v18 = v4[20] | ((v4[21] | (*(v4 + 11) << 8)) << 8);
    v6[27] = v18;
    v86 = v18;
    v19 = v17 + __ROL4__(v18 + (v14 ^ v17 & (v15 ^ v14)) + v12 + 1200080426, 12);
    v20 = v4[24] | ((v4[25] | (*(v4 + 13) << 8)) << 8);
    v6[28] = v20;
    v89 = v20;
    v21 = v19 + __ROR4__(v14 + (v15 ^ v19 & (v17 ^ v15)) - 1473231341 + v20, 15);
    v22 = v4[28] | ((v4[29] | ((v4[30] | (v4[31] << 8)) << 8)) << 8);
    v6[29] = v22;
    v23 = v21 + __ROR4__(v22 + (v17 ^ v21 & (v17 ^ v19)) + v15 - 45705983, 10);
    v24 = v4[32] | ((v4[33] | (*(v4 + 17) << 8)) << 8);
    v6[30] = v24;
    v25 = v23 + __ROL4__(v24 + (v19 ^ v23 & (v21 ^ v19)) + v17 + 1770035416, 7);
    v26 = v4[36] | ((v4[37] | (*(v4 + 19) << 8)) << 8);
    v6[31] = v26;
    v91 = v26;
    v27 = v25 + __ROL4__(v19 + (v21 ^ v25 & (v23 ^ v21)) - 1958414417 + v26, 12);
    v28 = v4[40] | ((v4[41] | ((v4[42] | (v4[43] << 8)) << 8)) << 8);
    v6[32] = v28;
    v29 = v27 + __ROR4__(v21 + v28 + (v23 ^ v27 & (v25 ^ v23)) - 42063, 15);
    v30 = v4[44] | ((v4[45] | (*(v4 + 23) << 8)) << 8);
    v6[33] = v30;
    v31 = v23 + v30 + (v25 ^ v29 & (v25 ^ v27)) - 1990404162;
    v32 = v27 - 40341101;
    v33 = v4[48] | ((v4[49] | (*(v4 + 25) << 8)) << 8);
    v6[34] = v33;
    v34 = v29 + __ROR4__(v31, 10);
    v35 = v27 ^ v34 & (v29 ^ v27);
    v36 = v98;
    v37 = v4[52] | ((v4[53] | (*(v4 + 27) << 8)) << 8);
    v6[35] = v37;
    v38 = v34 + __ROL4__(v25 + v33 + v35 + 1804603682, 7);
    v39 = v38 + __ROL4__(v37 + (v29 ^ v38 & (v34 ^ v29)) + v32, 12);
    v40 = v36[56] | ((v36[57] | ((v36[58] | (v4[59] << 8)) << 8)) << 8);
    v6[36] = v40;
    v41 = v39 + __ROR4__(v29 + v40 + (v34 ^ v39 & (v38 ^ v34)) - 1502002290, 15);
    v42 = v36[60] | ((v36[61] | (*(v36 + 31) << 8)) << 8);
    a1[37] = v42;
    v43 = v41 + __ROR4__(v42 + (v38 ^ v41 & (v38 ^ v39)) + 1236535329 + v34, 10);
    v44 = v43 + __ROL4__(v88 + (v41 ^ v39 & (v43 ^ v41)) - 165796510 + v38, 5);
    v45 = v44 + __ROL4__(v89 + (v43 ^ v41 & (v44 ^ v43)) - 1069501632 + v39, 9);
    v46 = v45 + __ROL4__(v30 + (v44 ^ v43 & (v44 ^ v45)) + 643717713 + v41, 14);
    LODWORD(v36) = v46 + __ROR4__(v100 + (v45 ^ v44 & (v46 ^ v45)) + v43 - 373897302, 12);
    v47 = v36 + __ROL4__(v86 + (v46 ^ v45 & (v36 ^ v46)) + v44 - 701558691, 5);
    v48 = v47 + __ROL4__(v28 + (v36 ^ v46 & (v47 ^ v36)) + v45 + 38016083, 9);
    v49 = v48 + __ROL4__(v42 + (v47 ^ v36 & (v47 ^ v48)) + v46 - 660478335, 14);
    v50 = v49 + __ROR4__(v90 + (v48 ^ v47 & (v49 ^ v48)) + v36 - 405537848, 12);
    LODWORD(v36) = v50 + __ROL4__(v91 + (v49 ^ v48 & (v50 ^ v49)) + v47 + 568446438, 5);
    v51 = v36 + __ROL4__(v40 + (v50 ^ v49 & (v36 ^ v50)) + v48 - 1019803690, 9);
    v52 = v51 + __ROL4__(v87 + (v36 ^ v50 & (v36 ^ v51)) + v49 - 187363961, 14);
    v53 = v52 + __ROR4__(v24 + (v51 ^ v36 & (v52 ^ v51)) + v50 + 1163531501, 12);
    v54 = v53 + __ROL4__(v37 + (v52 ^ v51 & (v53 ^ v52)) + v36 - 1444681467, 5);
    v55 = v54 + __ROL4__(v92 + (v53 ^ v52 & (v54 ^ v53)) + v51 - 51403784, 9);
    LODWORD(v36) = v55 + __ROL4__(v22 + (v54 ^ v53 & (v54 ^ v55)) + v52 + 1735328473, 14);
    v56 = v36 + __ROR4__(v33 + (v55 ^ v54 & (v36 ^ v55)) + v53 - 1926607734, 12);
    v57 = v56 + __ROL4__(v86 + (v56 ^ v36 ^ v55) - 378558 + v54, 4);
    v58 = v57 + __ROL4__(v24 + (v57 ^ v56 ^ v36) - 2022574463 + v55, 11);
    LODWORD(v36) = v58 + __ROL4__(v30 + (v57 ^ v56 ^ v58) + 1839030562 + v36, 16);
    v59 = v36 + __ROR4__(v40 + (v57 ^ v36 ^ v58) + v56 - 35309556, 9);
    v60 = v59 + __ROL4__(v88 + (v59 ^ v36 ^ v58) + v57 - 1530992060, 4);
    v61 = v60 + __ROL4__(v90 + (v60 ^ v59 ^ v36) + v58 + 1272893353, 11);
    v62 = v61 + __ROL4__(v22 + (v60 ^ v59 ^ v61) + v36 - 155497632, 16);
    LODWORD(v36) = v62 + __ROR4__(v28 + (v60 ^ v62 ^ v61) + v59 - 1094730640, 9);
    v63 = v36 + __ROL4__(v37 + (v36 ^ v62 ^ v61) + v60 + 681279174, 4);
    v64 = v63 + __ROL4__(v100 + (v63 ^ v36 ^ v62) - 358537222 + v61, 11);
    v65 = v64 + __ROL4__(v87 + (v63 ^ v36 ^ v64) - 722521979 + v62, 16);
    v66 = v65 + __ROR4__(v89 + (v63 ^ v65 ^ v64) + v36 + 76029189, 9);
    LODWORD(v36) = v66 + __ROL4__(v63 + v91 + (v66 ^ v65 ^ v64) - 640364487, 4);
    v67 = v36 + __ROL4__(v33 + (v36 ^ v66 ^ v65) + v64 - 421815835, 11);
    v68 = v67 + __ROL4__(v42 + (v36 ^ v66 ^ v67) + v65 + 530742520, 16);
    v69 = v68 + __ROR4__(v92 + (v36 ^ v68 ^ v67) + v66 - 995338651, 9);
    v70 = v69 + __ROL4__(v100 + (v68 ^ (v69 | ~v67)) + v36 - 198630844, 6);
    LODWORD(v36) = v70 + __ROL4__(v22 + (v69 ^ (v70 | ~v68)) + v67 + 1126891415, 10);
    v71 = v36 + __ROL4__(v40 + (v70 ^ (v36 | ~v69)) + v68 - 1416354905, 15);
    v72 = v71 + __ROR4__(v86 + (v36 ^ (v71 | ~v70)) + v69 - 57434055, 11);
    v73 = v72 + __ROL4__(v33 + (v71 ^ (v72 | ~v36)) + v70 + 1700485571, 6);
    v74 = v73 + __ROL4__(v87 + (v72 ^ (v73 | ~v71)) + v36 - 1894986606, 10);
    LODWORD(v36) = v74 + __ROL4__(v28 + (v73 ^ (v74 | ~v72)) + v71 - 1051523, 15);
    v75 = v36 + __ROR4__(v88 + (v74 ^ (v36 | ~v73)) + v72 - 2054922799, 11);
    v76 = v75 + __ROL4__(v24 + (v36 ^ (v75 | ~v74)) + v73 + 1873313359, 6);
    v77 = v76 + __ROL4__(v42 + (v75 ^ (v76 | ~v36)) + v74 - 30611744, 10);
    v78 = v77 + __ROL4__(v89 + (v76 ^ (v77 | ~v75)) + v36 - 1560198380, 15);
    LODWORD(v36) = v78 + __ROR4__(v75 + v37 + (v77 ^ (v78 | ~v76)) + 1309151649, 11);
    v79 = v36 + __ROL4__(v76 + v90 + (v78 ^ (v36 | ~v77)) - 145523070, 6);
    v80 = v79 + __ROL4__(v30 + (v36 ^ (v79 | ~v78)) + v77 - 1120210379, 10);
    v81 = v79 ^ (v80 | ~v36);
    v82 = v79;
    v3 = v93 + v79;
    v4 = v98 + 64;
    v83 = v80 + __ROL4__(v78 + v92 + v81 + 718787259, 15);
    v98 += 64;
    v84 = v80 ^ (v83 | ~v82);
    v8 = v96 + v80;
    LODWORD(v36) = v83 + __ROR4__(v91 + v84 + v36 - 343485551, 11);
    v7 = v95 + v83;
    v5 = v94 + v36;
    a3 -= 64;
    if ( !a3 )
      break;
    v6 = a1;
  }
  a1[2] = v3;
  a1[3] = v5;
  a1[4] = v7;
  a1[5] = v8;
  return v4;
}

//----- (000000014004C6D0) ----------------------------------------------------
__m128 *__fastcall sub_14004C6D0(unsigned int *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned int v5; // edx
  unsigned __int64 v6; // rbx
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // edx
  unsigned __int64 v10; // rbp
  _OWORD *v11; // rcx
  char *v12; // rdx

  v5 = *a1;
  v6 = a3;
  v7 = (a3 + *a1) & 0x1FFFFFFF;
  *a1 = v7;
  v8 = a1[1];
  if ( v7 < v5 )
    ++v8;
  a1[1] = v8 + (a3 >> 29);
  v9 = v5 & 0x3F;
  if ( v9 )
  {
    v10 = 64 - v9;
    v11 = (a1 + v9 + 24);
    v12 = a2;
    if ( a3 < v10 )
      return EAC_memcpy(v11, v12, a3);
    EAC_memcpy(v11, a2, v10);
    a2 += v10;
    v6 -= v10;
    sub_14004BC54(a1, a1 + 24, 64);
  }
  if ( v6 >= 0x40 )
  {
    a2 = sub_14004BC54(a1, a2, v6 & 0xFFFFFFC0);
    v6 &= 0x3Fu;
  }
  v11 = a1 + 6;
  a3 = v6;
  v12 = a2;
  return EAC_memcpy(v11, v12, a3);
}

//----- (000000014004C78C) ----------------------------------------------------
__m128 *__fastcall sub_14004C78C(__m128 *a1, __int64 a2)
{
  __int64 v4; // rcx
  unsigned int v5; // ecx
  unsigned int v6; // eax
  __int32 v7; // ecx
  __int32 v8; // ecx

  v4 = a1->m128_i32[0] & 0x3F;
  a1[1].m128_i8[v4 + 8] = 0x80;
  v5 = v4 + 1;
  v6 = 64 - v5;
  if ( 64 - v5 < 8 )
  {
    EAC_memset((a1 + v5 + 24), 0, v6);
    sub_14004BC54(a1, &a1[1].m128_u8[8], 64);
    v5 = 0;
    v6 = 64;
  }
  EAC_memset((a1 + v5 + 24), 0, v6 - 8);
  a1->m128_i32[0] *= 8;
  v7 = a1->m128_i32[0];
  a1[5].m128_i16[0] = a1->m128_i32[0];
  a1[5].m128_i8[2] = BYTE2(v7);
  a1[5].m128_i8[4] = a1->m128_i8[4];
  a1[5].m128_i8[3] = HIBYTE(v7);
  v8 = a1->m128_i32[1];
  a1[5].m128_i8[5] = BYTE1(v8);
  a1[5].m128_i8[7] = HIBYTE(v8);
  a1[5].m128_i8[6] = BYTE2(v8);
  sub_14004BC54(a1, &a1[1].m128_u8[8], 64);
  *a2 = __PAIR16__(BYTE1(a1->m128_i32[2]), a1->m128_i8[8]);
  *(a2 + 2) = a1->m128_i8[10];
  *(a2 + 3) = a1->m128_i8[11];
  *(a2 + 4) = __PAIR16__(BYTE1(a1->m128_i32[3]), a1->m128_i8[12]);
  *(a2 + 6) = a1->m128_i8[14];
  *(a2 + 7) = a1->m128_i8[15];
  *(a2 + 8) = __PAIR16__(BYTE1(a1[1].m128_i32[0]), a1[1].m128_i8[0]);
  *(a2 + 10) = a1[1].m128_i8[2];
  *(a2 + 11) = a1[1].m128_i8[3];
  *(a2 + 12) = __PAIR16__(BYTE1(a1[1].m128_i32[1]), a1[1].m128_i8[4]);
  *(a2 + 14) = a1[1].m128_i8[6];
  *(a2 + 15) = a1[1].m128_i8[7];
  return EAC_memset(a1, 0, 0x98ui64);
}

//----- (000000014004CA34) ----------------------------------------------------
__int64 sub_14004CA34()
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v1; // eax
  char v2; // di
  __int64 (__fastcall *v3)(unsigned __int64 *, __int64, int *); // rsi
  int v4; // esi
  char v6[16]; // [rsp+30h] [rbp-40h] BYREF
  int v7; // [rsp+40h] [rbp-30h] BYREF
  __int64 v8; // [rsp+48h] [rbp-28h]
  char *v9; // [rsp+50h] [rbp-20h]
  int v10; // [rsp+58h] [rbp-18h]
  __int128 v11; // [rsp+60h] [rbp-10h]
  PVOID Object; // [rsp+90h] [rbp+20h] BYREF
  unsigned __int64 Handle; // [rsp+98h] [rbp+28h] BYREF

  if ( !qword_1400864F0 )
  {
    Get_Unicode_string_Inline(v6, byte_140061910);
    v8 = 0i64;
    v9 = v6;
    v11 = 0i64;
    v7 = 48;
    v10 = 512;
    CurrentThread = KeGetCurrentThread();
    v1 = sub_140035ED4();

    if ( !CurrentThread )
      goto LABEL_5;
    if ( v1 )
      v2 = *(CurrentThread + v1);
    else
LABEL_5:
      v2 = 0;
    v3 = (loc_14005B768)(qword_1400860E8, &qword_1400860E8, 0i64);
    sub_140036990(CurrentThread, 0);
    v4 = v3 ? v3(&Handle, 1i64, &v7) : 0xC0000002;
    sub_140036990(CurrentThread, v2);
    if ( v4 >= 0 )
    {
      if ( Get_ObReferenceObjectByHandle(Handle, 1u, 0i64, 0, &Object, 0i64) >= 0 )
      {
        qword_1400864F0 = sub_140050898(Object);
        ObfDereferenceObject(Object);
      }
      Get_NtClose(Handle);
    }
  }
  return qword_1400864F0;
}
// 1400860E8: using guessed type __int64 qword_1400860E8;
// 1400864F0: using guessed type __int64 qword_1400864F0;

//----- (000000014004CB58) ----------------------------------------------------
__int64 sub_14004CB58()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  int v3[8]; // [rsp+20h] [rbp-20h] BYREF

  v0 = qword_1400864E8;
  v1 = 0i64;
  if ( qword_1400864E8 )
    return *v0;
  v3[0] = 851019492;
  v3[1] = 741987913;
  v3[2] = 297465778;
  v3[3] = -2071142775;
  v3[4] = 1798769458;
  v0 = (loc_14003CB4C)(v3);
  qword_1400864E8 = v0;
  if ( v0 )
    return *v0;
  return v1;
}
// 1400864E8: using guessed type __int64 qword_1400864E8;

//----- (000000014004CBBC) ----------------------------------------------------
char __fastcall sub_14004CBBC(__int64 a1)
{
  char ret; // si
  unsigned __int64 v3; // rdi
  unsigned int v4; // edx
  unsigned __int64 v5; // r8
  char v6; // cl
  __int16 v7; // bx
  unsigned int v8; // edx
  unsigned __int64 v9; // rdi
  unsigned __int64 i; // rdi
  char v11; // cl
  int v12; // edi
  unsigned __int64 v13; // rdx
  unsigned int v14; // edx
  unsigned __int64 v15; // rdi
  char v16; // dl
  __int16 v17; // bx
  __int16 v18; // bx
  unsigned int v19; // edx
  unsigned __int64 v20; // rdi
  unsigned __int64 j; // rdi
  char v22; // cl
  int v23; // edx
  unsigned __int64 v24; // rdi
  unsigned int v25; // edx
  unsigned __int64 v26; // rdi
  unsigned __int64 k; // rdi
  char v28; // cl
  int v29; // edi
  unsigned __int64 v30; // rdx
  unsigned int v31; // edx
  unsigned __int64 v32; // rdi
  __int64 User_Module; // rax
  char v34; // dl
  int v35; // edi
  unsigned __int64 v36; // r8
  __int64 v37; // r8
  int v39[4]; // [rsp+20h] [rbp-E0h]
  __int16 v40; // [rsp+30h] [rbp-D0h]
  int v41[5]; // [rsp+32h] [rbp-CEh]
  __int16 v42; // [rsp+46h] [rbp-BAh]
  int v43[7]; // [rsp+48h] [rbp-B8h]
  __int16 v44; // [rsp+64h] [rbp-9Ch]
  int v45[8]; // [rsp+66h] [rbp-9Ah]
  __int16 v46; // [rsp+86h] [rbp-7Ah]
  int v47[6]; // [rsp+88h] [rbp-78h]
  int v48[6]; // [rsp+A0h] [rbp-60h]
  int v49[6]; // [rsp+B8h] [rbp-48h]
  int v50[7]; // [rsp+D0h] [rbp-30h]
  int v51[8]; // [rsp+ECh] [rbp-14h]
  int v52[8]; // [rsp+10Ch] [rbp+Ch]
  _BYTE v53[18]; // [rsp+12Ch] [rbp+2Ch] BYREF
  _BYTE v54[22]; // [rsp+13Eh] [rbp+3Eh] BYREF
  _BYTE v55[30]; // [rsp+154h] [rbp+54h] BYREF
  _BYTE v56[28]; // [rsp+172h] [rbp+72h] BYREF
  _BYTE v57[24]; // [rsp+18Eh] [rbp+8Eh] BYREF
  _BYTE v58[24]; // [rsp+1A6h] [rbp+A6h] BYREF
  _BYTE v59[24]; // [rsp+1BEh] [rbp+BEh] BYREF
  _BYTE v60[34]; // [rsp+1D6h] [rbp+D6h] BYREF
  __int128 v61[2]; // [rsp+1F8h] [rbp+F8h] BYREF
  __int128 v62[2]; // [rsp+218h] [rbp+118h] BYREF
  _KAPC_STATE v63; // [rsp+238h] [rbp+138h] BYREF

  ret = 0;
  if ( !Get_KeStackAttachProcess(a1, &v63) )
    return ret;

  v41[0] = -1340222385;
  v42 = 2118;
  v3 = 20i64;
  v41[1] = -1125125837;
  v4 = -1335307253;
  v41[2] = -437240526;
  v41[3] = 1617689964;
  v5 = 0i64;
  v41[4] = -393096849;
  memset(v54, 0, sizeof(v54));
  do
  {
    *&v54[v5 * 4] = v41[v5] ^ v4;
    ++v5;
    v4 = -2531011 - 214013 * v4;
  }
  while ( v5 < 5 );
  do
  {
    v6 = v4;
    v4 >>= 8;
    v54[v3] = *(v41 + v3) ^ v6;
    ++v3;
  }
  while ( v3 < 0x16 );
  v7 = 1;
  if ( EAC_Get_User_Module(v54) )
  {
    v39[0] = 1280752460;
    v40 = 29876;
    v39[1] = 36544268;
    v8 = 1278917387;
    v39[2] = 628606510;
    v39[3] = -439643334;
    v9 = 0i64;
    memset(v53, 0, sizeof(v53));
    do
    {
      *&v53[v9 * 4] = v39[v9] ^ v8;
      ++v9;
      v8 = __ROR4__(((v8 ^ (v8 >> 7)) << 9) ^ v8 ^ (v8 >> 7) ^ ((((v8 ^ (v8 >> 7)) << 9) ^ v8 ^ (v8 >> 7)) >> 13), 2);
    }
    while ( v9 < 4 );
    for ( i = 16i64; i < 0x12; ++i )
    {
      v11 = v8;
      v8 >>= 8;
      v53[i] = *(v39 + i) ^ v11;
    }
    v7 = 3;
    if ( EAC_Get_User_Module(v53) )
    {
      v47[0] = -817200625;
      v47[1] = -1613832171;
      v47[2] = -835585523;
      v12 = 455784546;
      v47[3] = 1896105993;
      v13 = 0i64;
      v47[4] = 1049899526;
      v47[5] = 943321102;
      memset(v58, 0, sizeof(v58));
      do
      {
        v12 = -2531012 - 214013 * v12;
        *&v58[v13 * 4] = v47[v13] ^ v12;
        ++v13;
      }
      while ( v13 < 6 );
      v7 = 7;
      if ( EAC_Get_User_Module(v58) )
      {
        v48[0] = -1832750820;
        v48[1] = 1751802858;
        v48[2] = 1002442451;
        v14 = 737449318;
        v48[3] = -913352754;
        v15 = 0i64;
        v48[4] = 1401826317;
        v48[5] = 661434638;
        memset(v57, 0, sizeof(v57));
        do
        {
          v14 = ~(((v14 ^ (v14 >> 7)) << 9) ^ v14 ^ (v14 >> 7) ^ ((((v14 ^ (v14 >> 7)) << 9) ^ v14 ^ (v14 >> 7)) >> 13));
          *&v57[v15 * 4] = v48[v15] ^ v14;
          ++v15;
        }
        while ( v15 < 6 );
        v7 = 15;
        if ( EAC_Get_User_Module(v57) )
        {
          v16 = 1;
LABEL_19:
          v7 &= ~8u;
          memset(v57, 0, sizeof(v57));
          goto LABEL_20;
        }
      }
    }
  }
  v16 = 0;
  if ( (v7 & 8) != 0 )
    goto LABEL_19;
LABEL_20:
  if ( (v7 & 4) != 0 )
  {
    v7 &= ~4u;
    memset(v58, 0, sizeof(v58));
  }
  if ( (v7 & 2) != 0 )
  {
    v7 &= ~2u;
    memset(v53, 0, sizeof(v53));
  }
  v17 = v7 & 0xFFFE;
  memset(v54, 0, sizeof(v54));
  if ( v16 )
    goto LABEL_54;
  v45[0] = -769308760;
  v46 = -1552;
  v45[1] = 1935492603;
  v18 = v17 | 0x10;
  v45[2] = -732586769;
  v19 = -767014946;
  v45[3] = -869520889;
  v45[4] = 338185503;
  v20 = 0i64;
  v45[5] = -1083949819;
  v45[6] = 1925597937;
  v45[7] = -1151554352;
  memset(v60, 0, sizeof(v60));
  do
  {
    *&v60[v20 * 4] = v45[v20] ^ v19;
    ++v20;
    v19 = ~(((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13) ^ (32 * (((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13))));
  }
  while ( v20 < 8 );
  for ( j = 32i64; j < 0x22; ++j )
  {
    v22 = v19;
    v19 >>= 8;
    v60[j] = *(v45 + j) ^ v22;
  }
  if ( EAC_Get_User_Module(v60) )
    goto LABEL_44;
  v18 |= 0x20u;
  v50[0] = -1993952444;
  memset(v56, 0, sizeof(v56));
  v50[1] = -197054889;
  v23 = 1743118389;
  v50[2] = 1665492100;
  v24 = 0i64;
  v50[3] = -410941366;
  v50[4] = -2011319707;
  v50[5] = 1603185073;
  v50[6] = -1799366378;
  do
  {
    v23 = __ROR4__(1103515245 * v23 + 12345, 2);
    *&v56[v24 * 4] = v50[v24] ^ v23;
    ++v24;
  }
  while ( v24 < 7 );
  if ( EAC_Get_User_Module(v56) )
    goto LABEL_44;
  v43[0] = -1984930577;
  v44 = -26769;
  v18 |= 0x40u;
  v43[1] = 344221110;
  v25 = -1982243687;
  v26 = 0i64;
  v43[2] = -288675243;
  v43[3] = 700218021;
  v43[4] = -907679911;
  v43[5] = 629363515;
  v43[6] = -1062932059;
  memset(v55, 0, sizeof(v55));
  do
  {
    *&v55[v26 * 4] = v43[v26] ^ v25;
    ++v26;
    v25 = -(((v25 ^ (v25 << 13)) >> 17) ^ v25 ^ (v25 << 13) ^ (32 * (((v25 ^ (v25 << 13)) >> 17) ^ v25 ^ (v25 << 13))));
  }
  while ( v26 < 7 );
  for ( k = 28i64; k < 0x1E; ++k )
  {
    v28 = v25;
    v25 >>= 8;
    v55[k] = *(v43 + k) ^ v28;
  }
  if ( EAC_Get_User_Module(v55) )
    goto LABEL_44;
  v51[0] = 2121396220;
  v51[1] = 1946344158;
  memset(v61, 0, sizeof(v61));
  v51[2] = -922544321;
  v18 |= 0x80u;
  v51[3] = -1853723253;
  v29 = -1348810371;
  v51[4] = 860349794;
  v30 = 0i64;
  v51[5] = 1088246537;
  v51[6] = 1454819497;
  v51[7] = 1825297;
  do
  {
    v29 = -12346 - 1103515245 * v29;
    *(v61 + v30 * 4) = v51[v30] ^ v29;
    ++v30;
  }
  while ( v30 < 8 );
  if ( EAC_Get_User_Module(v61) )
    goto LABEL_44;
  v49[0] = -450393788;
  memset(v59, 0, sizeof(v59));
  v49[1] = 664304883;
  v18 |= 0x100u;
  v49[2] = -644086900;
  v31 = -1939001439;
  v49[3] = 932718351;
  v32 = 0i64;
  v49[4] = 1737111732;
  v49[5] = 1083081469;
  do
  {
    v31 = ~(((v31 ^ (v31 << 13)) >> 17) ^ v31 ^ (v31 << 13) ^ (32 * (((v31 ^ (v31 << 13)) >> 17) ^ v31 ^ (v31 << 13))));
    *&v59[v32 * 4] = v49[v32] ^ v31;
    ++v32;
  }
  while ( v32 < 6 );
  User_Module = EAC_Get_User_Module(v59);
  v34 = 0;
  if ( User_Module )
LABEL_44:
    v34 = 1;
  if ( (v18 & 0x100) != 0 )
    memset(v59, 0, sizeof(v59));
  if ( (v18 & 0x80u) != 0 )
  {
    LOBYTE(v18) = v18 & 0x7F;
    memset(v61, 0, sizeof(v61));
  }
  if ( (v18 & 0x40) != 0 )
    memset(v55, 0, sizeof(v55));
  if ( (v18 & 0x20) != 0 )
    memset(v56, 0, sizeof(v56));
  memset(v60, 0, sizeof(v60));
  if ( v34 )
  {
LABEL_54:
    ret = 1;
  }
  else
  {
    v52[0] = 372711554;
    v52[1] = -60900725;
    memset(v62, 0, sizeof(v62));
    v52[2] = -2013902316;
    v35 = 1808359345;
    v52[3] = 156250293;
    v36 = 0i64;
    v52[4] = -479158418;
    v52[5] = -1698895076;
    v52[6] = -30974138;
    v52[7] = 1241244219;
    do
    {
      v35 = __ROR4__(214013 * v35 + 2531011, 2);
      *(v62 + v36 * 4) = v52[v36] ^ v35;
      ++v36;
    }
    while ( v36 < 8 );
    v37 = EAC_Get_User_Module(v62);
    ret = 0;
    memset(v62, 0, sizeof(v62));
    if ( v37 )
      ret = 1;
  }
  (loc_140054154)(a1, &v63);                    // KeUnstackDetachProcess

  return ret;
}
// 14004CBBC: using guessed type _KAPC_STATE var_58;

//----- (000000014004D4E8) ----------------------------------------------------
__int64 __fastcall sub_14004D4E8(volatile signed __int64 *a1)
{
  if ( *a1 != 2 )
  {
    if ( !_InterlockedCompareExchange64(a1, 1i64, 0i64) )
      return 0x103i64;

    while ( *a1 != 2 )
      _mm_pause();
  }
  return 0i64;
}

//----- (000000014004D514) ----------------------------------------------------
char sub_14004D514()
{
  sub_140060BB0();
  return 1;
}

//----- (000000014004D528) ----------------------------------------------------
bool sub_14004D528()
{
  unsigned __int64 v0; // rax

  v0 = __readmsr(0x122u);
  return (v0 & 1) == 0;
}

//----- (000000014004D540) ----------------------------------------------------
bool sub_14004D540()
{
  unsigned __int64 v0; // r9
  unsigned __int64 v1; // rax

  v0 = __readmsr(0x122u);
  _disable();
  __writemsr(0x122u, v0 & 0xFFFFFFFFFFFFFFFEui64);
  v1 = __readmsr(0x122u);
  __writemsr(0x122u, v0);
  _enable();
  return (v1 & 1) == 0;
}

//----- (000000014004EE1C) ----------------------------------------------------
__int64 sub_14004EE1C()
{
  __int64 (__fastcall *v0)(__int64); // r8
  __int64 result; // rax

  v0 = (loc_14005B768)(qword_140085F78, &qword_140085F78, 0i64);
  result = 0i64;
  if ( v0 )
    return v0(0xFFFFi64);
  return result;
}
// 140085F78: using guessed type __int64 qword_140085F78;

//----- (000000014004EE50) ----------------------------------------------------
__int64 sub_14004EE50()
{
  __int64 (__fastcall *v0)(_QWORD); // r8
  __int64 result; // rax

  v0 = (loc_14005B768)(qword_140085F80, &qword_140085F80, 0i64);
  result = 0i64;
  if ( v0 )
    return v0(0i64);
  return result;
}
// 140085F80: using guessed type __int64 qword_140085F80;

//----- (000000014004EE80) ----------------------------------------------------
__int64 __fastcall sub_14004EE80(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (loc_14005B768)(qword_140085F88, &qword_140085F88, 0i64);
  result = 0i64;
  if ( v2 )
    return v2(a1);
  return result;
}
// 140085F88: using guessed type __int64 qword_140085F88;

//----- (000000014004EEB8) ----------------------------------------------------
__int64 Get_KeAreAllApcsDisabled()
{
  __int64 (*g_KeAreAllApcsDisabled)(void); // r8
  __int64 result; // rax

  g_KeAreAllApcsDisabled = (loc_14005B768)(qword_140085F58, &qword_140085F58, 0i64);
  result = 0i64;

  if ( g_KeAreAllApcsDisabled )
    return g_KeAreAllApcsDisabled();            // KeAreAllApcsDisabled

  return result;
}
// 140085F58: using guessed type __int64 qword_140085F58;

//----- (000000014004EEE4) ----------------------------------------------------
__int64 __fastcall Get_KeWaitForSingleObject(__int64 Object)
{
  __int64 (__fastcall *g_KeWaitForSingleObject)(__int64, _QWORD, __int64, _QWORD); // rax
  __int64 v3; // r8

  g_KeWaitForSingleObject = (loc_14005B768)(qword_140085FA0, &qword_140085FA0, 0i64);
  if ( g_KeWaitForSingleObject )
    return g_KeWaitForSingleObject(Object, 0i64, v3, 0i64);
  else
    return 0xC0000002i64;
}
// 14004EF1A: variable 'v3' is possibly undefined
// 140085FA0: using guessed type __int64 qword_140085FA0;

//----- (000000014004EF28) ----------------------------------------------------
__int64 __fastcall Get_KeIpiGenericCall(__int64 Function, __int64 Context)
{
  __int64 (__fastcall *g_KeIpiGenericCall)(__int64, __int64); // r8
  __int64 result; // rax

  g_KeIpiGenericCall = (loc_14005B768)(qword_140085FD0, &qword_140085FD0, 0i64);
  result = 0i64;

  if ( g_KeIpiGenericCall )
    return g_KeIpiGenericCall(Function, Context);// KeIpiGenericCall

  return result;
}
// 140085FD0: using guessed type __int64 qword_140085FD0;

//----- (000000014004FBC4) ----------------------------------------------------
void __fastcall sub_14004FBC4(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned __int64 v3; // rdi
  __int64 v5; // r15
  _OWORD *v7; // rax
  unsigned __int64 v8; // rbx
  __int64 v9; // r14
  unsigned __int64 v10; // r13
  __int64 v11; // rsi
  unsigned __int64 v12; // rbp
  unsigned int v13; // r15d
  unsigned __int64 v14; // rbp
  __int64 Memory; // rax
  __int64 v16; // rsi
  __int64 v17; // r9
  unsigned __int64 v18; // r8
  int v19; // eax
  int v20; // r10d
  _BYTE *v21; // rdx
  unsigned int v22; // r10d
  char v23; // cl
  unsigned __int64 v24; // rdx
  __int64 v25[9]; // [rsp+40h] [rbp-48h] BYREF
  unsigned int v27; // [rsp+A8h] [rbp+20h]

  if ( a1 )
  {
    v3 = 0i64;
    v5 = a2;
    if ( *(a1 + 32) )
    {
      if ( a2 )
      {
        if ( a3 )
        {
          v7 = sub_14004ADA0(*(a1 + 16), *(a1 + 24), 0x8000ui64, 4, 64, a1, 0, v25);
          v8 = v7;
          if ( v7 )
          {
            if ( *(a1 + 28) )
              *(v7 + 26) |= 0x400u;
            v27 = 0;
            v9 = 0i64;
            v10 = 0x8000i64;
            if ( a3 )
            {
              v11 = v25[0];
              do
              {
                v12 = (*(v5 + 8) + 1);
                if ( v12 > v10 )
                  break;
                EAC_memcpy((v9 + v11), *v5, v12);
                v9 += v12;
                v10 -= v12;
                v5 += 16i64;
                ++v27;
              }
              while ( v27 < a3 );
              if ( v9 )
              {
                v13 = *(a1 + 32);
                v14 = (v9 + *(v8 + 10));
                Memory = EAC_Allocate_Memory(0x8208ui64);
                v16 = Memory;
                if ( Memory )
                {
                  EAC_memset((Memory + 8), 0, 0x8200ui64);
                  v17 = v16 + 8;
                  *v16 = 0i64;
                  *(v16 + 8) = 1232125506;
                  v18 = 24i64;
                  *(v16 + 12) = -480199867;
                  *(v16 + 16) = -1304900958;
                  *(v16 + 24) = -626647549;
                  *(v16 + 28) = -1114722072;
                  v19 = 1954601281 * (v8 >> 2);
                  v20 = v19 ^ 0x4F472264;
                  *(v16 + 20) = v19 ^ 0x5C1F9625;
                  if ( v14 )
                  {
                    do
                    {
                      if ( v3 >= 0x8000 )
                        break;
                      v21 = (v3 + v8);
                      ++v18;
                      v22 = ~(((v20 ^ (v20 << 13)) >> 17) ^ v20 ^ (v20 << 13) ^ (32
                                                                               * (((v20 ^ (v20 << 13)) >> 17) ^ v20 ^ (v20 << 13))));
                      v23 = 8 * (v3++ & 3);
                      v21[v17 - v8 + 24] = *v21 ^ (v22 >> v23);
                      v20 = *v21 ^ v22;
                    }
                    while ( v3 < v14 );
                  }
                  v24 = (v18 + 255) & 0xFFFFFFFFFFFFFF00ui64;
                  while ( v18 < v24 )
                  {
                    v20 *= 1954601281;
                    *(v18 + v17) = BYTE1(v20);
                    ++v18;
                  }
                  *(v16 + 24) ^= v20;
                  *(v16 + 28) ^= v3;
                  *v16 = v18;
                  (loc_140016B54)(v13, v16 + 8);
                  Get_ExFreePool(v16);
                }
                memset(v8, 0, (v9 + *(v8 + 10)));
              }
            }
            Get_ExFreePool(v8);
          }
        }
      }
    }
  }
}
// 14004FBC4: using guessed type __int64 var_48[9];

//----- (000000014004FE10) ----------------------------------------------------
__int64 __fastcall sub_14004FE10(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, int a5, __int64 a6)
{
  int v10; // r8d
  unsigned __int64 i; // rdx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // rbx
  unsigned int v15; // eax
  __int64 v16; // rcx
  unsigned int v17; // r14d
  __int128 v18; // xmm0
  int v20[2]; // [rsp+28h] [rbp-61h] BYREF
  __int64 v21; // [rsp+30h] [rbp-59h] BYREF
  int *v22; // [rsp+38h] [rbp-51h]
  __int64 *v23; // [rsp+40h] [rbp-49h]
  __int128 v24; // [rsp+48h] [rbp-41h] BYREF
  __int64 v25; // [rsp+58h] [rbp-31h]
  unsigned int v26; // [rsp+60h] [rbp-29h]
  char v27; // [rsp+64h] [rbp-25h]
  __int64 v29; // [rsp+70h] [rbp-19h] BYREF
  __int128 v30; // [rsp+78h] [rbp-11h]
  __int64 v31; // [rsp+88h] [rbp-1h]
  __int128 v32; // [rsp+90h] [rbp+7h]

  v20[0] = 872662526;
  v21 = 0i64;
  v20[1] = -28876120;
  v22 = v20;
  v23 = &v21;
  v10 = -2095627327;
  for ( i = 0i64; i < 2; ++i )
  {
    v10 = __ROL4__(
            ((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13) ^ (32 * (((v10 ^ (v10 << 13)) >> 17) ^ v10 ^ (v10 << 13))),
            3);
    *(v23 + i * 4) = v22[i] ^ v10;
  }
  v12 = a3;
  if ( a3 > 0x400000 )
    v12 = 0x400000i64;
  v13 = MmVirtualMemory(a2, v12, a4);
  v14 = v13;
  if ( v13 )
  {
    v29 = a4;
    v31 = v13;
    v30 = 0i64;
    v32 = 0i64;
    v15 = Check_Address(&v29, a6, 0x400);
    v17 = v15;
    if ( v15 )
    {
      if ( sub_14003D3BC(v16, 3i64, a6, v15) )
      {
        if ( a1 && *(a1 + 8) && *a1 && *(a1 + 2) )
        {
          v18 = *a1;
          v27 = 0;
          v26 = a3;
          v24 = v18;
        }
        else
        {
          Get_Unicode_string_Inline(&v24, &v21);
          v27 = 1;
          v26 = 0;
        }
        v25 = a2;
        sub_14004FBC4(&v24, a6, v17);
      }
    }
  }
  memset(&v21, 0, sizeof(v21));
  return v14;
}
// 14004FF0D: variable 'v16' is possibly undefined
// 14003D3BC: using guessed type __int64 __fastcall sub_14003D3BC(_QWORD, _QWORD, _QWORD, _QWORD);
// 14004FBC4: using guessed type __int64 __fastcall sub_14004FBC4(_QWORD, _QWORD, _QWORD);
// 14005D29C: using guessed type __int64 __fastcall sub_14005D29C(_QWORD, _QWORD);

//----- (000000014004FF9C) ----------------------------------------------------
void sub_14004FF9C()
{
  unsigned int v0; // r15d
  __int64 Memory; // r12
  __int64 v2; // r13
  unsigned int *System_Information; // rax
  unsigned int *v4; // rbx
  unsigned int i; // edi
  __int64 v6; // rsi
  unsigned __int64 v7; // rcx
  __int64 v8; // rax
  NTSTATUS RtlMultiByteToUnicodeN; // eax
  __int64 v10; // rcx
  unsigned int v11; // r8d
  __int64 v12; // rdx
  unsigned __int64 v13; // r14
  __int64 v14; // r8
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rsi
  unsigned int v17; // edi
  __int64 v18; // rax
  unsigned int v19; // edx
  int v20; // [rsp+20h] [rbp-40h]
  unsigned __int16 BytesInMultiByteString[2]; // [rsp+40h] [rbp-20h] BYREF
  unsigned __int16 Length[8]; // [rsp+50h] [rbp-10h] BYREF
  unsigned __int64 v24; // [rsp+A8h] [rbp+48h]

  v0 = 0;
  if ( qword_1400832A0 )
  {
    Memory = EAC_Allocate_Memory(0x400000ui64);
    if ( Memory )
    {
      v2 = EAC_Allocate_Memory(0x4000ui64);
      if ( v2 )
      {
        System_Information = Get_System_Information();
        v4 = System_Information;
        if ( System_Information )
        {
          if ( *System_Information )
          {
            sub_14000A36C(System_Information);
            for ( i = 0; i < *v4; ++i )
            {
              if ( byte_140083594 )
                break;
              v6 = 74i64 * i;
              v7 = *&v4[v6 + 6];
              if ( v7 >= MmSystemRangeStart && v7 != qword_140083298 )
              {
                if ( &v4[v6 + 12] )
                {
                  v8 = -1i64;
                  do
                    ++v8;
                  while ( *(&v4[v6 + 12] + v8) );
                  BytesInMultiByteString[0] = v8;
                  BytesInMultiByteString[1] = v8 + 1;
                }
                else
                {
                  *BytesInMultiByteString = 0;
                }
                RtlMultiByteToUnicodeN = Get_RtlMultiByteToUnicodeN(Length, BytesInMultiByteString);
                v10 = *&Length[4];
                v11 = v4[v6 + 8];
                v12 = *&v4[v6 + 6];
                if ( RtlMultiByteToUnicodeN < 0 )
                  v10 = 0i64;
                *&Length[4] = v10;
                sub_14004FE10(Length & -(v10 != 0), v12, v11, Memory, v20, v2);
                if ( *&Length[4] )
                {
                  Get_ExFreePool(*&Length[4]);
                  *Length = 0i64;
                }
              }
            }
            v13 = HIDWORD(qword_140083298);
            v24 = HIDWORD(qword_140083298);
            if ( *v4 != 1 )
            {
              do
              {
                if ( byte_140083594 )
                  break;
                v14 = 74i64 * v0++;
                if ( HIDWORD(*&v4[v14 + 6]) == v13 )
                {
                  v15 = *&v4[74 * v0 + 6];
                  if ( HIDWORD(v15) == v13 )
                  {
                    v16 = *&v4[v14 + 6] + v4[v14 + 8];
                    if ( v16 < v15 )
                    {
                      v17 = (v15 - v16) & 0xFFFFF000;
                      if ( v17 <= 0x1000000 )
                      {
                        do
                        {
                          if ( byte_140083594 )
                            break;
                          v18 = sub_14004FE10(0i64, v16, v17, Memory, v20, v2);
                          v19 = 4096;
                          if ( v18 )
                            v19 = (v18 + 4095) & 0xFFFFF000;
                          v17 -= v19;
                          v16 += v19;
                        }
                        while ( v16 < *&v4[74 * v0 + 6] );
                        v13 = v24;
                      }
                    }
                  }
                }
              }
              while ( v0 < *v4 - 1 );
            }
          }
          Get_ExFreePool(v4);
        }
        Get_ExFreePool(v2);
      }
      Get_ExFreePool(Memory);
    }
  }
}
// 1400500C9: variable 'v20' is possibly undefined
// 14000A36C: using guessed type __int64 __fastcall sub_14000A36C(_QWORD);
// 140083298: using guessed type __int64 qword_140083298;
// 1400832A0: using guessed type __int64 qword_1400832A0;
// 140083594: using guessed type char byte_140083594;

//----- (0000000140050740) ----------------------------------------------------
__int64 __fastcall Get_ObReferenceObjectByHandle(
        __int64 Handle,
        unsigned int DesiredAccess,
        __int64 ObjectType,
        char AccessMode,
        __int64 Object,
        __int64 HandleInformation)
{
  __int64 (__fastcall *g_ObReferenceObjectByHandle)(__int64, _QWORD, __int64, __int64, __int64, __int64); // rax
  __int64 v11; // r9

  g_ObReferenceObjectByHandle = (loc_14005B768)(qword_140086008, &qword_140086008, 0i64);
  if ( !g_ObReferenceObjectByHandle )
    return 0xC0000002i64;

  v11 = Object;
  LOBYTE(v11) = AccessMode;
  return g_ObReferenceObjectByHandle(Handle, DesiredAccess, ObjectType, v11, Object, HandleInformation);// ObReferenceObjectByHandle
}
// 140086008: using guessed type __int64 qword_140086008;

//----- (00000001400507B8) ----------------------------------------------------
__int64 __fastcall sub_1400507B8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, __int64 a6, __int64 a7)
{
  __int64 (__fastcall *v9)(__int64, __int64, _QWORD, _QWORD, int, _QWORD, __int64); // rax

  v9 = (loc_14005B768)(qword_140086030, &qword_140086030, 0i64);
  if ( v9 )
    return v9(a1, a2, 0i64, 0i64, a5, 0i64, a7);
  else
    return 3221225474i64;
}
// 140086030: using guessed type __int64 qword_140086030;

//----- (0000000140050820) ----------------------------------------------------
__int64 __fastcall Get_ObOpenObjectByPointer(
        __int64 Object,
        unsigned int HandleAttributes,
        __int64 PassedAccessState,
        unsigned int DesiredAccess,
        __int64 ObjectType,
        char AccessMode,
        __int64 Handle)
{
  __int64 (__fastcall *g_ObOpenObjectByPointer)(__int64, _QWORD, _QWORD, _QWORD, __int64, char, __int64); // rax

  g_ObOpenObjectByPointer = (loc_14005B768)(qword_140086038, &qword_140086038, 0i64);
  if ( g_ObOpenObjectByPointer )
    return g_ObOpenObjectByPointer(Object, HandleAttributes, 0i64, DesiredAccess, ObjectType, AccessMode, Handle);// ObOpenObjectByPointer
  else
    return 0xC0000002i64;
}
// 140086038: using guessed type __int64 qword_140086038;

//----- (0000000140050898) ----------------------------------------------------
__int64 __fastcall sub_140050898(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (loc_14005B768)(qword_140086020, &qword_140086020, 0i64);
  result = 0i64;
  if ( v2 )
    return v2(a1);
  return result;
}
// 140086020: using guessed type __int64 qword_140086020;

//----- (00000001400508D0) ----------------------------------------------------
__int64 __fastcall sub_1400508D0(unsigned int a1, __int64 a2, unsigned __int64 a3, unsigned int a4, char a5, char a6)
{
  unsigned __int64 v6; // rbx
  __int64 result; // rax
  char v9; // di
  unsigned int v10; // r13d
  unsigned __int64 v11; // r12
  unsigned __int64 v12; // rsi
  int v13; // r15d
  char *Memory; // rax
  char *v15; // rbp
  unsigned __int64 v16; // rax
  __int64 v17; // r14
  _OWORD *v18; // rdi
  unsigned int v19; // ebp
  __int64 v20; // rax
  __int64 v21; // r14
  __int64 v22; // rdi
  unsigned __int64 v23; // r8
  int v24; // r9d
  _BYTE *v25; // rdx
  unsigned int v26; // r9d
  char v27; // cl
  unsigned __int64 v28; // rcx
  _OWORD *v30; // [rsp+90h] [rbp+18h] BYREF

  v6 = 0i64;
  result = a1;
  if ( !a3 || (v9 = 1, a4 < 0x1000) )
    v9 = 0;
  if ( a1 && (a2 && *(a2 + 8) && *a2 && *(a2 + 2) || v9) )
  {
    v10 = a4;
    if ( a4 > 0x6000 )
      v10 = 24576;
    if ( a4 > 0xFFFFFF )
      a4 = 0xFFFFFF;
    v11 = a4;
    result = sub_14004ADA0(a3, a4, v10, 4, 64, a2, 0, &v30);
    v12 = result;
    if ( result )
    {
      if ( a5 )
        *(result + 26) |= 0x400u;
      v13 = 0;
      if ( v9 )
      {
        Memory = EAC_Allocate_Memory(v11);
        v15 = Memory;
        if ( Memory )
        {
          if ( a6 )
            v16 = MmVirtualMemory(a3, v11, Memory);
          else
            v16 = EAC_Read_VirtualMemory(a3, v11, Memory);
          v17 = v16;
          if ( v16 >= 0x1000 )
          {
            v18 = v30;
            EAC_memcpy(v30, v15, 0x1000ui64);
            v13 = sub_14006030C(v15, v17, (v18 + 0x100), v10 - 0x1000) + 0x1000;
          }
          Get_ExFreePool(v15);
        }
      }
      v19 = v13 + *(v12 + 10);
      v20 = EAC_Allocate_Memory(0x8208ui64);
      v21 = v20;
      if ( v20 )
      {
        EAC_memset((v20 + 8), 0, 0x8200ui64);
        v22 = v21 + 8;
        *v21 = 0i64;
        *(v21 + 8) = 1232125506;
        v23 = 24i64;
        *(v21 + 12) = -480199867;
        *(v21 + 16) = -1304900958;
        *(v21 + 24) = -626647549;
        *(v21 + 28) = -1114722072;
        v24 = (1954601281 * (v12 >> 2)) ^ 0x4F472264;
        *(v21 + 20) = (1954601281 * (v12 >> 2)) ^ 0x5C1F9625;
        if ( v19 )
        {
          do
          {
            if ( v6 >= 0x8000 )
              break;
            v25 = (v6 + v12);
            ++v23;
            v26 = ~(((v24 ^ (v24 << 13)) >> 17) ^ v24 ^ (v24 << 13) ^ (32
                                                                     * (((v24 ^ (v24 << 13)) >> 17) ^ v24 ^ (v24 << 13))));
            v27 = 8 * (v6++ & 3);
            v25[v22 - v12 + 24] = *v25 ^ (v26 >> v27);
            v24 = *v25 ^ v26;
          }
          while ( v6 < v19 );
        }
        v28 = (v23 + 255) & 0xFFFFFFFFFFFFFF00ui64;
        while ( v23 < v28 )
        {
          v24 *= 1954601281;
          *(v23 + v22) = BYTE1(v24);
          ++v23;
        }
        *(v21 + 24) ^= v24;
        *(v21 + 28) ^= v6;
        *v21 = v23;
        (loc_140016B54)(a1, v21 + 8);
        Get_ExFreePool(v21);
      }
      memset(v12, 0, (v13 + *(v12 + 10)));
      return Get_ExFreePool(v12);
    }
  }
  return result;
}

//----- (0000000140050B64) ----------------------------------------------------
char *__fastcall sub_140050B64(unsigned int a1, __int64 a2, _OWORD *a3, __int64 a4, char *a5, unsigned int a6)
{
  __int64 v7; // r14
  char *BaseAddress; // rax
  char *v9; // r13
  unsigned __int64 v10; // rbx
  int v11; // edi
  __int64 v12; // rax
  int ProcessWow64Process; // eax
  char *v14; // r15
  int v15; // ecx
  __int64 v16; // rax
  unsigned __int64 v17; // r14
  unsigned int v18; // ecx
  unsigned int v19; // r13d
  __int64 Memory; // rax
  __int64 v21; // r15
  __int64 v22; // rdi
  int v23; // r8d
  unsigned __int64 v24; // r9
  unsigned int v25; // r8d
  unsigned __int64 v26; // rcx
  char v27[16]; // [rsp+50h] [rbp-38h] BYREF
  _OWORD *v29; // [rsp+A0h] [rbp+18h] BYREF

  v29 = a3;
  v7 = Get_PsGetCurrentProcess();
  BaseAddress = Get_PsGetProcessSectionBaseAddress(v7);
  v9 = BaseAddress;
  if ( BaseAddress < MmHighestUserAddress )
  {
    v10 = 0i64;
    if ( !a2 || !*(a2 + 8) || !*a2 || !*(a2 + 2) )
      a2 = v27 & -(sub_140053360(v7, v27) != 0);
    v11 = Get_PsGetProcessId(v7);
    v12 = Get_PsGetCurrentProcess();
    ProcessWow64Process = Get_PsGetProcessWow64Process(v12);
    v14 = a5;
    if ( a5 && a6 )
      v15 = a6 + 4096;
    else
      v15 = 4096;
    v16 = sub_14004ADA0(v9, 4096, v15, 1, ProcessWow64Process, a2, v11, &v29);
    v17 = v16;
    if ( v16 )
    {
      *(v16 + 22) = 0;
      if ( v9 )
      {
        EAC_IsUsermodeValidAddress((v9 + 4096), 4096i64, 1);
        EAC_memcpy(v29, v9 + 4096, 0x1000ui64);
      }
      if ( !v14 )
        goto LABEL_19;
      if ( a6 && v29 )
        EAC_memcpy(v29 + 256, v14, a6);
      v18 = a6;
      if ( !a6 )
LABEL_19:
        v18 = 0;
      v19 = v18 + *(v17 + 10) + 4096;
      Memory = EAC_Allocate_Memory(0x8208ui64);
      v21 = Memory;
      if ( Memory )
      {
        EAC_memset((Memory + 8), 0, 0x8200ui64);
        *v21 = 0i64;
      }
      else
      {
        v21 = 0i64;
      }
      if ( v21 )
      {
        v22 = v21 + 8;
        *(v21 + 8) = 1232125506;
        *(v21 + 12) = -480199867;
        *(v21 + 16) = -1304900958;
        *(v21 + 20) = (1954601281 * (v17 >> 2)) ^ 0x5C1F9625;
        *(v21 + 24) = -626647549;
        *(v21 + 28) = -1114722072;
        v23 = (1954601281 * (v17 >> 2)) ^ 0x4F472264;
        v24 = 24i64;
        if ( v19 )
        {
          do
          {
            if ( v10 >= 0x8000 )
              break;
            v25 = ~(((v23 ^ (v23 << 13)) >> 17) ^ v23 ^ (v23 << 13) ^ (32
                                                                     * (((v23 ^ (v23 << 13)) >> 17) ^ v23 ^ (v23 << 13))));
            *(v22 + v10 + 24) = *(v10 + v17) ^ (v25 >> (8 * (v10 & 3)));
            v23 = *(v10 + v17) ^ v25;
            ++v10;
            ++v24;
          }
          while ( v10 < v19 );
        }
        v26 = (v24 + 255) & 0xFFFFFFFFFFFFFF00ui64;
        while ( v24 < v26 )
        {
          v23 *= 1954601281;
          *(v24 + v22) = BYTE1(v23);
          ++v24;
        }
        *(v21 + 24) ^= v23;
        *(v21 + 28) ^= v10;
        *v21 = v24;
        (loc_140016B54)(a1, v21 + 8, v24);
        Get_ExFreePool(v21);
      }
      memset(v17, 0, (*(v17 + 10) + 4096));
      Get_ExFreePool(v17);
    }
    BaseAddress = v27;
    if ( a2 == v27 )
      return EAC_Free_UnicodeString(v27);
  }
  return BaseAddress;
}
// 140050CDC: conditional instruction was optimized away because r15.8!=0
// 14004ADA0: using guessed type __int64 __fastcall sub_14004ADA0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD, __int64);

//----- (0000000140050E64) ----------------------------------------------------
void __fastcall sub_140050E64(__int64 a1, unsigned int a2, char *a3, _UNICODE_STRING *a4)
{
  _UNICODE_STRING *v4; // r14
  __int64 CurrentProcess; // rax
  __int16 ProcessId; // bx
  __int64 CurrentProcess2; // rax
  int ProcessWow64Process; // eax
  _OWORD *v11; // rax
  unsigned __int64 v12; // rsi
  unsigned int v13; // r12d
  char *i; // rax
  __int64 v15; // rdx
  unsigned int v16; // ebx
  unsigned int v17; // r15d
  __int64 Memory; // rax
  __int64 v19; // rbx
  __int64 v20; // r8
  int v21; // r9d
  unsigned __int64 v22; // r11
  unsigned __int64 j; // r10
  unsigned int v24; // r9d
  unsigned __int64 v25; // rcx
  __int64 v26[2]; // [rsp+50h] [rbp-88h] BYREF
  _UNICODE_STRING v27; // [rsp+60h] [rbp-78h] BYREF
  char *BaseAddress; // [rsp+70h] [rbp-68h] BYREF
  char *v29; // [rsp+78h] [rbp-60h]
  unsigned __int64 Size; // [rsp+88h] [rbp-50h]
  int v31; // [rsp+98h] [rbp-40h]

  if ( a1 )
  {
    v4 = a4;
    if ( a3 )
    {
      if ( !a4 || !a4->Buffer || !a4->Length || !a4->MaximumLength )
        v4 = (&v27 & -(EAC_GetMappedFilename(-1i64, a3, &v27) != 0));

      CurrentProcess = Get_PsGetCurrentProcess();
      ProcessId = Get_PsGetProcessId(CurrentProcess);
      CurrentProcess2 = Get_PsGetCurrentProcess();
      ProcessWow64Process = Get_PsGetProcessWow64Process(CurrentProcess2);
      v11 = sub_14004ADA0(a3, 0x1000ui64, 0x8000ui64, 0, ProcessWow64Process, &v4->Length, ProcessId, v26);

      v12 = v11;
      v26[1] = v11;
      if ( v11 )
      {
        *(v11 + 22) = 0;
        v13 = 0x8000;
        for ( i = a3; ; i = &BaseAddress[Size] )
        {
          BaseAddress = i;
          if ( !v13 )
            break;
          if ( !(loc_140053930)(-1i64, i, 0i64, &BaseAddress, 48i64) )
            break;
          if ( v29 != a3 )
            break;
          v15 = (Size + 4095) & 0xFFFFFFFFFFFFF000ui64;
          Size = v15;
          if ( !v15 )
            break;

          EAC_IsUsermodeValidAddress(BaseAddress, v15, 1);
          if ( v31 == 0x1000000 && BaseAddress == v29 )
          {
            *(v12 + 26) |= 2u;
            if ( !Get_Nt_Headers(BaseAddress, Size) )
              *(v12 + 0x1A) |= 0x80u;
          }
          v16 = v13;
          if ( v13 > Size )
            v16 = Size;
          EAC_memcpy((v26[0] + *(v12 + 22)), BaseAddress, v16);
          *(v12 + 22) += v16;
          v13 -= v16;
        }
        v17 = *(v12 + 10) + *(v12 + 22);
        Memory = EAC_Allocate_Memory(0x8208ui64);
        v19 = Memory;
        if ( Memory )
        {
          EAC_memset((Memory + 8), 0, 0x8200ui64);
          *v19 = 0i64;
        }
        else
        {
          v19 = 0i64;
        }
        if ( v19 )
        {
          v20 = v19 + 8;
          *(v19 + 8) = 0xAB7B1B6F;
          *(v19 + 12) = 0xFF868F4A;
          *(v19 + 16) = 0x7AB78BD4;
          *(v19 + 20) = (0x9574B57D * (v12 >> 2)) ^ 0x16751F01;
          *(v19 + 24) = 0x9655BC47;
          *(v19 + 28) = 0x2D64E30A;
          v21 = (0x9574B57D * (v12 >> 2)) ^ 0xC6565F4B;
          v22 = 0i64;
          for ( j = 24i64; v22 < v17; ++j )
          {
            if ( v22 >= 0x8000 )
              break;
            v24 = __ROR4__(
                    ((v21 ^ (v21 << 13)) >> 7) ^ v21 ^ (v21 << 13) ^ ((((v21 ^ (v21 << 13)) >> 7) ^ v21 ^ (v21 << 13)) << 17),
                    4);
            *(v20 + v22 + 24) = *(v22 + v12) ^ (v24 >> (8 * (v22 & 3)));
            v21 = *(v22 + v12) ^ v24;
            ++v22;
          }
          v25 = (j + 255) & 0xFFFFFFFFFFFFFF00ui64;
          while ( j < v25 )
          {
            v21 *= -1787513475;
            *(j + v20) = BYTE1(v21);
            ++j;
          }
          *(v19 + 24) ^= v21;
          *(v19 + 28) ^= v22;
          *v19 = j;
          (loc_140045210)(a1, a2, v20, j, 0i64);
          Get_ExFreePool(v19);
        }
        Get_ExFreePool(v12);
      }
      if ( v4 == &v27 )
        EAC_Free_UnicodeString(&v27);
    }
  }
}

//----- (00000001400511D0) ----------------------------------------------------
void __fastcall sub_1400511D0(__int64 a1)
{
  __int64 v1; // rdx
  char v2; // bl
  __int64 v4; // rsi
  void *v5; // r15
  struct _FAST_MUTEX *v6; // rcx
  __int64 v7; // rsi
  unsigned int v8; // r15d
  unsigned __int64 v9; // r12
  __int64 Memory; // rax
  __int64 v11; // rsi
  __int64 v12; // r8
  unsigned __int64 v13; // r10
  unsigned __int64 v14; // r9
  int v15; // eax
  unsigned int v16; // edi
  char *v17; // rdx
  unsigned int v18; // edi
  char v19; // cl
  unsigned __int64 v20; // rdx
  char v21; // cl
  char *v22; // rdx
  __int64 v23; // rax
  char *v24; // rdi
  _QWORD v25[2]; // [rsp+30h] [rbp-30h] BYREF
  char v26[8]; // [rsp+40h] [rbp-20h] BYREF
  __int64 v27; // [rsp+48h] [rbp-18h]
  char *v28; // [rsp+50h] [rbp-10h]
  char v29; // [rsp+5Fh] [rbp-1h]

  if ( !a1 )
    return;
  v1 = *(a1 + 528);
  v2 = 0;
  v4 = v1;
  if ( v1 )
  {
    if ( KeGetCurrentIrql() > 1u )
      goto LABEL_6;
    *(v1 + 32) = 1;
    v4 = *(a1 + 528);
  }
  if ( !v4 )
    return;
LABEL_6:
  if ( KeGetCurrentIrql() > 1u )
    return;
  ExAcquireFastMutex((v4 + 40));
  v5 = *v4;
  v6 = (v4 + 40);
  v7 = *(v4 + 8);
  ExReleaseFastMutex(v6);
  if ( !v7 )
    return;
  v25[0] = v5;
  v25[1] = v7;
  sub_140051724(v26, v25);
  memset(v5, 0, 2i64 * (v7 + 1));
  if ( v29 == -2 )
  {
    v8 = 0;
  }
  else
  {
    if ( v29 == -1 )
    {
      v8 = v27;
      v9 = v28;
      goto LABEL_14;
    }
    v8 = v29;
  }
  v9 = v26;
LABEL_14:
  Memory = EAC_Allocate_Memory(0x8208ui64);
  v11 = Memory;
  if ( Memory )
  {
    EAC_memset((Memory + 8), 0, 0x8200ui64);
    v12 = v11 + 8;
    *v11 = 0i64;
    *(v11 + 8) = -1417995409;
    v13 = 0i64;
    v14 = 24i64;
    *(v11 + 12) = -7958710;
    *(v11 + 16) = 2058849236;
    *(v11 + 24) = -1772766137;
    *(v11 + 28) = 761586442;
    v15 = -1787513475 * (v9 >> 2);
    v16 = v15 ^ 0xC6565F4B;
    *(v11 + 20) = v15 ^ 0x16751F01;
    if ( v9 )
    {
      if ( v8 )
      {
        do
        {
          if ( v13 >= 0x8000 )
            break;
          v17 = (v9 + v13);
          ++v14;
          v18 = __ROR4__(
                  ((v16 ^ (v16 << 13)) >> 7) ^ v16 ^ (v16 << 13) ^ ((((v16 ^ (v16 << 13)) >> 7) ^ v16 ^ (v16 << 13)) << 17),
                  4);
          v19 = 8 * (v13++ & 3);
          v17[v12 - v9 + 24] = *v17 ^ (v18 >> v19);
          v16 = *v17 ^ v18;
        }
        while ( v13 < v8 );
      }
      v20 = (v14 + 255) & 0xFFFFFFFFFFFFFF00ui64;
      while ( v14 < v20 )
      {
        v16 *= -1787513475;
        *(v14 + v12) = BYTE1(v16);
        ++v14;
      }
    }
    *(v11 + 24) ^= v16;
    *(v11 + 28) ^= v13;
    *v11 = v14;
    (loc_140045210)(a1, 538703984i64);
    Get_ExFreePool(v11);
  }
  v21 = v29;
  v22 = v28;
  if ( v29 == -2 )
  {
    v23 = 0i64;
LABEL_28:
    v24 = v26;
    goto LABEL_29;
  }
  if ( v29 != -1 )
  {
    v23 = v29;
    goto LABEL_28;
  }
  v23 = v27;
  v24 = v28;
LABEL_29:
  if ( v23 )
  {
    do
    {
      *v24++ = 0;
      --v23;
    }
    while ( v23 );
    v21 = v29;
    v22 = v28;
  }
  if ( v21 == -1 )
  {
    *v22 = 0;
    v22 = v28;
    v27 = 0i64;
    v2 = v29;
  }
  else
  {
    v26[0] = 0;
    v29 = 0;
  }
  if ( v2 == -1 )
    Get_ExFreePool(v22);
}
// 1400511D0: using guessed type char var_20[8];

//----- (00000001400515F0) ----------------------------------------------------
char __fastcall sub_1400515F0(__int64 a1, unsigned __int64 a2)
{
  char v2; // al
  unsigned __int64 v3; // rdi
  unsigned __int64 v5; // rsi
  char *v6; // r14
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rax
  char v9; // cl
  unsigned __int64 v10; // rcx
  __int64 v11; // rdi
  _OWORD *Memory; // rax
  _OWORD *v13; // rbp

  v2 = *(a1 + 31);
  v3 = a2;
  if ( v2 == -2 )
    return 0;
  if ( v2 == -1 )
  {
    v5 = *(a1 + 8);
    v6 = *(a1 + 16);
    v7 = v5;
    v8 = *a1;
    v9 = 1;
  }
  else
  {
    v5 = *(a1 + 31);
    v7 = v5;
    v8 = 30i64;
    v6 = a1;
    v9 = 0;
  }
  if ( a2 < v7 )
    v3 = v7;
  if ( v8 >= v3 )
    return 1;
  if ( v3 <= 0x1E )
  {
    if ( v9 )
    {
      EAC_memcpy(a1, v6, v7 + 1);
      Get_ExFreePool(v6);
      *(a1 + 31) = v5;
    }
    return 1;
  }
  if ( v3 > 0x7FFFFFF )
    return 0;
  if ( v3 >= 0x800 )
  {
    v11 = v3 | 0xFFF;
  }
  else
  {
    v10 = v3 | 0x3F | ((v3 | 0x3F) >> 1) | ((v3 | 0x3F | ((v3 | 0x3F) >> 1)) >> 2);
    v11 = v10 | (v10 >> 4);
  }
  Memory = EAC_Allocate_Memory(v11 + 1);
  v13 = Memory;
  if ( !Memory )
  {
    if ( *(a1 + 31) == 0xFF )
      Get_ExFreePool(*(a1 + 16));
    *a1 = 0;
    *(a1 + 31) = -2;
    return 0;
  }
  EAC_memcpy(Memory, v6, v5 + 1);
  *a1 = v11;
  *(a1 + 8) = v5;
  *(a1 + 16) = v13;
  *(a1 + 31) = -1;
  return 1;
}

//----- (0000000140051724) ----------------------------------------------------
__int64 __fastcall sub_140051724(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _WORD *v5; // rdx
  char v6; // al
  unsigned __int64 v7; // r11
  _BYTE *v8; // rbx
  unsigned int v9; // ecx
  _BYTE *v10; // r10
  unsigned int v11; // eax
  char v12; // r9
  unsigned int v13; // r8d
  char v14; // al
  __int64 v15; // rax
  unsigned __int64 v16; // rbx

  v2 = *(a2 + 8);
  *a1 = 0;
  *(a1 + 31) = 0;
  if ( sub_1400515F0(a1, 3 * v2) )
  {
    v5 = *a2;
    v6 = *(a1 + 31);
    v7 = *a2 + 2 * v2;
    if ( v6 == -1 )
      v8 = *(a1 + 16);
    else
      v8 = a1;
    if ( v5 < v7 )
    {
      do
      {
        v9 = *v5++;
        if ( v9 - 55296 <= 0x3FF && v5 < v7 && (*v5 + 9216) <= 0x3FFu )
          v9 = (((v9 & 0x3FF) << 10) | *v5++ & 0x3FF) + 0x10000;
        v10 = v8 + 1;
        if ( v9 > 0x7F )
        {
          v11 = v9 >> 6;
          v12 = v9 & 0x3F | 0x80;
          if ( v9 > 0x7FF )
          {
            v13 = v9 >> 12;
            v14 = v11 & 0x3F | 0x80;
            if ( v9 > 0xFFFF )
            {
              *v8 = (v9 >> 18) | 0xF0;
              *v10 = v13 & 0x3F | 0x80;
              v8 += 4;
              v10[1] = v14;
              v10[2] = v12;
            }
            else
            {
              *v8 = v13 | 0xE0;
              v8 += 3;
              *v10 = v14;
              v10[1] = v12;
            }
          }
          else
          {
            *v8 = v11 | 0xC0;
            v8 += 2;
            *v10 = v12;
          }
        }
        else
        {
          *v8++ = v9;
        }
      }
      while ( v5 < v7 );
      v6 = *(a1 + 31);
    }
    if ( v6 == -1 )
      v15 = *(a1 + 16);
    else
      v15 = a1;
    v16 = &v8[-v15];
    if ( sub_1400515F0(a1, v16) )
    {
      if ( *(a1 + 31) == 0xFF )
      {
        *(v16 + *(a1 + 16)) = 0;
        *(a1 + 8) = v16;
      }
      else
      {
        *(v16 + a1) = 0;
        *(a1 + 31) = v16;
      }
    }
  }
  return a1;
}

//----- (0000000140051B28) ----------------------------------------------------
char sub_140051B28()
{
  __int64 v0; // rax
  char v1; // bl
  __int64 v2; // rcx
  int v4; // [rsp+20h] [rbp-20h] BYREF
  int v5; // [rsp+24h] [rbp-1Ch]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]
  int v8; // [rsp+30h] [rbp-10h]

  v0 = qword_1400860A8;
  v1 = 0;
  if ( !qword_1400860A8 )
  {
    v4 = -1601668762;
    v5 = -1543586294;
    v6 = 1925835951;
    v7 = 2006321484;
    v8 = 1385167879;
    v0 = (loc_14003CB4C)(&v4);
    qword_1400860A8 = v0;
  }
  v2 = qword_1400860B0;
  if ( !qword_1400860B0 )
  {
    v4 = 928093540;
    v5 = 1914118246;
    v6 = -1025248440;
    v7 = 1214166579;
    v8 = -674635467;
    v2 = (loc_14003CB4C)(&v4);
    qword_1400860B0 = v2;
    v0 = qword_1400860A8;
  }
  if ( v0 && v2 )
    return 1;
  return v1;
}
// 1400860A8: using guessed type __int64 qword_1400860A8;
// 1400860B0: using guessed type __int64 qword_1400860B0;

//----- (00000001400520C4) ----------------------------------------------------
char __fastcall sub_1400520C4(__int64 a1)
{
  char v1; // bl
  __int64 *i; // rax

  v1 = 0;
  if ( !byte_140085FE8 || KeGetCurrentIrql() > 1u )
    return 0;
  ExAcquireFastMutex(&stru_140086070);
  for ( i = qword_140086060; i != &qword_140086060; i = *i )
  {
    if ( i[5] == a1 )
    {
      v1 = 1;
      break;
    }
  }
  ExReleaseFastMutex(&stru_140086070);
  return v1;
}
// 140085FE8: using guessed type char byte_140085FE8;
// 140086060: using guessed type __int64 qword_140086060;

//----- (0000000140052130) ----------------------------------------------------
char __fastcall sub_140052130(_OWORD *a1)
{
  char v1; // bl
  __int128 Info; // [rsp+20h] [rbp-28h] BYREF

  v1 = 0;
  if ( a1 && Get_NtQuerySystemInformation(0x5Au, &Info, 0x14u, 0i64) >= 0 )
  {
    v1 = 1;
    *a1 = Info;
  }
  return v1;
}

//----- (0000000140052174) ----------------------------------------------------
char __fastcall sub_140052174(unsigned __int8 *a1, _UNICODE_STRING *a2)
{
  char v2; // r8
  unsigned __int8 *v4; // r10
  char *v5; // rdx
  __int64 v6; // r11
  __int64 v7; // rax
  __int64 v8; // r11
  unsigned __int8 *v9; // rdx
  char *v10; // r10
  __int64 v11; // rax
  unsigned __int8 *v12; // rdx
  char *v13; // r10
  __int64 v14; // r11
  __int64 v15; // rax
  unsigned __int8 *v16; // rdx
  char *v17; // r10
  __int64 v18; // r11
  __int64 v19; // rax
  char *v20; // rdx
  unsigned __int8 *v21; // r9
  __int64 v22; // r10
  __int64 v23; // rax
  char *v24; // rcx
  __int64 v25; // r8
  __int16 v27; // [rsp+20h] [rbp-50h] BYREF
  char v28[16]; // [rsp+22h] [rbp-4Eh] BYREF
  __int16 v29; // [rsp+32h] [rbp-3Eh]
  char v30; // [rsp+34h] [rbp-3Ch] BYREF
  __int16 v31; // [rsp+3Ch] [rbp-34h]
  char v32; // [rsp+3Eh] [rbp-32h] BYREF
  __int16 v33; // [rsp+46h] [rbp-2Ah]
  char v34; // [rsp+48h] [rbp-28h] BYREF
  __int16 v35; // [rsp+50h] [rbp-20h]
  char v36; // [rsp+52h] [rbp-1Eh] BYREF
  int v37; // [rsp+6Ah] [rbp-6h]

  v2 = 0;
  if ( a1 && a2 )
  {
    v27 = 123;
    v4 = a1 + 3;
    v5 = v28;
    v6 = 4i64;
    do
    {
      v7 = *v4--;
      *v5 = *off_14007CD60[v7];
      v5 += 4;
      --v6;
    }
    while ( v6 );
    v29 = 45;
    v8 = 2i64;
    v9 = a1 + 5;
    v10 = &v30;
    do
    {
      v11 = *v9--;
      *v10 = *off_14007CD60[v11];
      v10 += 4;
      --v8;
    }
    while ( v8 );
    v31 = 45;
    v12 = a1 + 7;
    v13 = &v32;
    v14 = 2i64;
    do
    {
      v15 = *v12--;
      *v13 = *off_14007CD60[v15];
      v13 += 4;
      --v14;
    }
    while ( v14 );
    v33 = 45;
    v16 = a1 + 8;
    v17 = &v34;
    v18 = 2i64;
    do
    {
      v19 = *v16++;
      *v17 = *off_14007CD60[v19];
      v17 += 4;
      --v18;
    }
    while ( v18 );
    v35 = 45;
    v20 = &v36;
    v21 = a1 + 10;
    v22 = 6i64;
    do
    {
      v23 = *v21++;
      *v20 = *off_14007CD60[v23];
      v20 += 4;
      --v22;
    }
    while ( v22 );
    v37 = 125;
    v24 = v28;
    v25 = 36i64;
    do
    {
      if ( (*v24 - 65) <= 0x19u )
        *v24 |= 0x20u;
      v24 += 2;
      --v25;
    }
    while ( v25 );
    return EAC_Read_String_From_Unicode_String(a2, &v27);
  }
  return v2;
}
// 14007CD60: using guessed type wchar_t *off_14007CD60[256];

//----- (0000000140052928) ----------------------------------------------------
char __fastcall sub_140052928(__int64 Process)
{
  char ret; // bl
  unsigned __int8 (__fastcall *v3)(__int64); // rax

  ret = 0;
  if ( Process )
  {
    v3 = (loc_14005B768)(qword_140085A50, &qword_140085A50, 0i64);
    if ( !v3 || !v3(Process) )
      return 1;
  }
  return ret;
}
// 140085A50: using guessed type __int64 qword_140085A50;

//----- (0000000140052970) ----------------------------------------------------
bool __fastcall sub_140052970(__int64 ProcessId, void *Handle)
{
  bool ret; // bl
  __int64 (__fastcall *v5)(void *); // rax
  char PreviousMode; // bp
  __int64 v7; // rdx
  _KAPC_STATE ApcState; // [rsp+20h] [rbp-48h] BYREF
  __int16 v10; // [rsp+70h] [rbp+8h] BYREF
  PVOID Object; // [rsp+80h] [rbp+18h] BYREF

  ret = 0;
  if ( !ProcessId || !Handle || !qword_1400832C0 )
    return 0;

  v5 = (loc_14005B768)(qword_140086028, &qword_140086028, 0i64);
  if ( v5 )
    PreviousMode = v5(Handle);
  else
    PreviousMode = 0;

  if ( Get_PsLookupProcessByProcessId(ProcessId, &Object) >= 0 )
  {
    if ( Get_KeStackAttachProcess(Object, &ApcState) )
    {
      v10 = 0;
      sub_140058AFC(Handle, v7, &v10);
      ret = ObCloseHandle(Handle, PreviousMode == 0) >= 0;
      (loc_140054154)(Object, &ApcState);       // KeUnstackDetachProcess
    }
    ObfDereferenceObject(Object);
  }
  return ret;
}
// 140052A02: variable 'v7' is possibly undefined
// 1400832C0: using guessed type __int64 qword_1400832C0;
// 140086028: using guessed type __int64 qword_140086028;
// 140052970: using guessed type _KAPC_STATE ApcState;

//----- (0000000140052A50) ----------------------------------------------------
bool __fastcall sub_140052A50(__int64 a1, __int64 *a2)
{
  char v2; // bl
  __int64 (__fastcall *v5)(__int64); // rax
  __int64 v6; // rax

  v2 = 0;
  if ( a1 && a2 )
  {
    v5 = (loc_14005B768)(qword_140085A40, &qword_140085A40, 0i64);
    if ( v5 )
      v6 = v5(a1);
    else
      v6 = 0i64;
    *a2 = v6;
    return v6 != 0;
  }
  return v2;
}
// 140085A40: using guessed type __int64 qword_140085A40;

//----- (0000000140052AB4) ----------------------------------------------------
__int64 Check_Process_Architecture()
{
  __int64 Process; // rax

  Process = Get_PsGetCurrentProcess();
  return Get_PsGetProcessWow64Process(Process);
}

//----- (0000000140052ACC) ----------------------------------------------------
__int64 __fastcall Get_PsGetProcessWow64Process(__int64 Process)
{
  __int64 (__fastcall *g_PsGetProcessWow64Process)(__int64); // r8
  __int64 ret; // rax

  g_PsGetProcessWow64Process = (loc_14005B768)(qword_140085A88, &qword_140085A88, 0i64);
  ret = 0i64;
  if ( g_PsGetProcessWow64Process )
    ret = g_PsGetProcessWow64Process(Process);  // PsGetProcessWow64Process

  return ret != 0 ? 32 : 64;
}
// 140085A88: using guessed type __int64 qword_140085A88;

//----- (0000000140052C18) ----------------------------------------------------
char __fastcall sub_140052C18(PEPROCESS Process)
{
  unsigned __int64 v1; // rbx
  __int64 ImageFileName; // rdx
  __int64 v4; // rdi
  __int64 v5; // rdx
  __int128 *v6; // rcx
  char v7; // si
  char v8; // al
  __int128 *v9; // rax
  unsigned int v10; // edx
  unsigned __int64 v11; // rdi
  HANDLE ProcessId; // rax
  int v13; // edi
  int v15[3]; // [rsp+20h] [rbp-59h]
  char v16; // [rsp+2Ch] [rbp-4Dh]
  _BYTE v17[13]; // [rsp+2Dh] [rbp-4Ch] BYREF
  int v18[11]; // [rsp+3Ah] [rbp-3Fh]
  __int128 v19; // [rsp+68h] [rbp-11h] BYREF
  _UNICODE_STRING v20; // [rsp+78h] [rbp-1h] BYREF
  __int128 v21[3]; // [rsp+88h] [rbp+Fh] BYREF

  v1 = 0i64;
  v19 = 0i64;
  v20 = 0i64;
  if ( Process )
  {
    ImageFileName = Get_PsGetProcessImageFileName(Process);
    if ( ImageFileName )
    {
      v4 = 0x10i64;
      v5 = ImageFileName - &v19;
      v6 = &v19;
      v7 = 1;
      do
      {
        if ( v4 == 0xFFFFFFFF80000012ui64 )
          break;

        v8 = *(v6 + v5);
        if ( !v8 )
          break;

        *v6 = v8;
        v6 = (v6 + 1);
        --v4;
      }
      while ( v4 );
      v15[0] = 1358267472;
      v15[1] = -1429742907;
      v9 = (v6 - 1);
      if ( v4 )
        v9 = v6;
      v15[2] = 446797977;
      v16 = 115;
      v10 = 1015413813;
      v11 = 0i64;
      *v9 = 0;
      memset(v17, 0, sizeof(v17));
      do
      {
        *&v17[v11 * 4] = v15[v11] ^ v10;
        ++v11;
        v10 = __ROR4__(
                ((v10 ^ (v10 >> 7)) << 9) ^ v10 ^ (v10 >> 7) ^ ((((v10 ^ (v10 >> 7)) << 9) ^ v10 ^ (v10 >> 7)) >> 13),
                3);
      }
      while ( v11 < 3 );
      v17[12] = v16 ^ v10;
      if ( !sub_14005D784(v17, &v19, 0x10ui64)
        || (ProcessId = PsGetProcessId(Process)) == 0i64
        || !sub_140053130(ProcessId, &v20) )
      {
        v7 = 0;
      }
      memset(v17, 0, sizeof(v17));
      if ( v7 )
      {
        v13 = 1166644964;
        v18[0] = -1551115083;
        memset(v21, 0, 44);
        v18[1] = -603199548;
        v18[2] = 1081479480;
        v18[3] = -1232022533;
        v18[4] = -1374503674;
        v18[5] = 1647912713;
        v18[6] = -891482810;
        v18[7] = 1823265425;
        v18[8] = 301352174;
        v18[9] = -1523802703;
        v18[10] = -1570586870;
        do
        {
          v13 = __ROR4__(1103515245 * v13 + 12345, 3);
          *(v21 + v1) = *(v18 + v1) ^ v13;
          v1 += 4i64;
        }
        while ( v1 < 0x2C );
        LOBYTE(v1) = sub_14005D25C(&v20, v21);
        memset(v21, 0, 0x2Cui64);
        EAC_Free_UnicodeString(&v20);
      }
    }
  }
  return v1;
}

//----- (0000000140052E4C) ----------------------------------------------------
__int64 __fastcall Get_PsGetProcessPeb(__int64 Process)
{
  __int64 (__fastcall *g_PsGetProcessPeb)(__int64); // r8
  __int64 result; // rax

  g_PsGetProcessPeb = (loc_14005B768)(qword_140085A78, &qword_140085A78, 0i64);
  result = 0i64;

  if ( g_PsGetProcessPeb )
    return g_PsGetProcessPeb(Process);          // PsGetProcessPeb

  return result;
}
// 140085A78: using guessed type __int64 qword_140085A78;

//----- (0000000140052E84) ----------------------------------------------------
__int64 __fastcall Get_PsGetProcessWow64Process2(__int64 Process)
{
  __int64 (__fastcall *g_PsGetProcessWow64Process)(__int64); // r8
  __int64 result; // rax

  g_PsGetProcessWow64Process = (loc_14005B768)(qword_140085A88, &qword_140085A88, 0i64);
  result = 0i64;

  if ( g_PsGetProcessWow64Process )
    return g_PsGetProcessWow64Process(Process);

  return result;
}
// 140085A88: using guessed type __int64 qword_140085A88;

//----- (0000000140052EBC) ----------------------------------------------------
__int64 __fastcall Get_PsGetProcessSectionBaseAddress(__int64 Process)
{
  __int64 (__fastcall *g_PsGetProcessSectionBaseAddress)(__int64); // r8
  __int64 result; // rax

  g_PsGetProcessSectionBaseAddress = (loc_14005B768)(qword_140085A80, &qword_140085A80, 0i64);
  result = 0i64;

  if ( g_PsGetProcessSectionBaseAddress )
    return g_PsGetProcessSectionBaseAddress(Process);// PsGetProcessSectionBaseAddress
                                                // 

  return result;
}
// 140085A80: using guessed type __int64 qword_140085A80;

//----- (0000000140052EF4) ----------------------------------------------------
__int64 __fastcall sub_140052EF4(__int64 a1, unsigned int a2)
{
  __int64 v2; // rbx
  __int64 v5; // rax
  __int64 v6; // r8
  unsigned int *v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rax

  v2 = 0i64;
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = EAC_NtQuerySystemInformation(5u, 0x80000u, 0x1000000u, 0i64);
      v6 = v5;
      if ( v5 )
      {
        v7 = v5;
        if ( a2 )
        {
          do
          {
            v8 = *(v7 + 10);
            if ( v8 )
            {
              *(a1 + 8 * v2) = v8;
              v2 = (v2 + 1);
            }
            v9 = *v7;
            if ( !v9 )
              break;
            v7 = (v7 + v9);
          }
          while ( v2 < a2 );
        }
        Get_ExFreePool(v6);
      }
    }
  }
  return v2;
}

//----- (0000000140052F70) ----------------------------------------------------
__int64 __fastcall sub_140052F70(__int64 a1)
{
  __int64 ret; // rsi
  unsigned __int64 ThreadId; // rbx
  struct _KTHREAD *CurrentThread; // rdi
  unsigned int v5; // eax
  struct _FAST_MUTEX *Fast_Mutex; // rdi
  char *v7; // rbp
  int v8; // eax
  __int64 v9; // rbp
  void (__fastcall *v10)(__int64); // rax
  PVOID Object; // [rsp+40h] [rbp+8h] BYREF

  ret = 0i64;
  ThreadId = 4i64;
  if ( a1 )
  {
    CurrentThread = KeGetCurrentThread();
    v5 = sub_140035F88();
    if ( CurrentThread )
    {
      if ( v5 )
      {
        if ( *(CurrentThread + v5) )
        {
          Fast_Mutex = EAC_Allocate_KeInitializeEvent(1);
          if ( Fast_Mutex )
          {
            do
            {
              if ( ret >= 0x200 )
                break;

              if ( Get_PsLookupThreadByThreadId(ThreadId, &Object) >= 0 )
              {
                v7 = Object;
                v8 = sub_140035F88();
                if ( v7 && v8 )
                  v9 = *&v7[v8];
                else
                  v9 = 0i64;
                if ( !sub_14002307C(Fast_Mutex, v9) )
                {
                  v10 = (loc_14005B768)(qword_140086000, &qword_140086000, 0i64);
                  v10(v9);
                  *(a1 + 8 * ret) = v9;
                  ret = (ret + 1);
                  sub_140022EAC(Fast_Mutex, v9, 0i64, 0);
                }
                ObfDereferenceObject(Object);
              }
              ThreadId += 4i64;
            }
            while ( ThreadId < 0x10000 );

            sub_140023184(Fast_Mutex);
          }
        }
      }
    }
  }
  return ret;
}
// 140086000: using guessed type __int64 qword_140086000;

//----- (0000000140053088) ----------------------------------------------------
__int64 __fastcall sub_140053088(__int64 a1)
{
  __int64 v1; // rbx
  __int64 (__fastcall *v3)(__int64); // rax

  v1 = 0i64;
  if ( a1 )
  {
    v3 = (loc_14005B768)(qword_140085A70, &qword_140085A70, 0i64);
    if ( v3 )
      return v3(a1);
  }
  return v1;
}
// 140085A70: using guessed type __int64 qword_140085A70;

//----- (00000001400530D0) ----------------------------------------------------
char __fastcall EAC_GetProcessImageFileName(__int64 Process, _BYTE *a2)
{
  __int64 ImageFileName; // rax
  __int64 v4; // rdx
  __int64 v5; // r8
  char result; // al
  char v7; // cl

  if ( !Process )
    return 0;

  if ( !a2 )
    return 0;

  ImageFileName = Get_PsGetProcessImageFileName(Process);
  if ( !ImageFileName )
    return 0;

  v4 = 0x10i64;
  v5 = ImageFileName - a2;
  result = 1;

  while ( v4 != 0xFFFFFFFF80000012ui64 )
  {
    v7 = a2[v5];
    if ( v7 )
    {
      *a2++ = v7;
      if ( --v4 )
        continue;
    }
    if ( !v4 )
    {
      *(a2 - 1) = 0;
      return result;
    }
    break;
  }
  *a2 = 0;
  return result;
}

//----- (0000000140053130) ----------------------------------------------------
char __fastcall sub_140053130(__int64 ProcessId, _UNICODE_STRING *unicode_string)
{
  char String_From_Unicode_String; // bl
  unsigned int DesiredAccess; // edx
  __int64 ProcessHandle; // rsi
  unsigned __int16 *Allocate; // rax MAPDST
  unsigned int ReturnLength; // [rsp+50h] [rbp+8h] BYREF

  String_From_Unicode_String = 0;
  ReturnLength = 0;
  if ( !ProcessId || !unicode_string )
    return 0;

  DesiredAccess = 0x1000;
  if ( KUSER_SHARED_DATA.NtMajorVersion == 5 )
    DesiredAccess = 0x400;

  ProcessHandle = EAC_Get_Process_Handle(ProcessId, DesiredAccess);
  if ( ProcessHandle )
  {
    if ( Get_NtQueryInformationProcess(ProcessHandle, 27u, 0i64, 0, &ReturnLength) == 0xC0000004 && ReturnLength > 0x10 )
    {
      Allocate = EAC_Allocate_Memory(ReturnLength + 2i64);
      if ( Allocate )
      {
        *Allocate = 0;
        *(Allocate + 1) = Allocate + 8;
        Allocate[1] = ReturnLength - 0x10;
        if ( Get_NtQueryInformationProcess(ProcessHandle, 0x1Bu, Allocate, ReturnLength, &ReturnLength) >= 0 )
        {
          *(*(Allocate + 1) + 2 * (*Allocate >> 1)) = 0;
          String_From_Unicode_String = EAC_Read_String_From_Unicode_String(unicode_string, *(Allocate + 1));
        }
        Get_ExFreePool(Allocate);
      }
    }
    Get_NtClose(ProcessHandle);
  }
  return String_From_Unicode_String;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140053248) ----------------------------------------------------
char __fastcall EAC_Get_ProcessParameters(__int64 Process, char Flag, _UNICODE_STRING *unicode_string)
{
  char ret; // bl
  _PEB *ProcessPeb; // rax
  struct _RTL_USER_PROCESS_PARAMETERS *ProcessParameters; // rsi
  PWSTR Address; // rcx
  _UNICODE_STRING ImagePathName; // [rsp+28h] [rbp-60h] BYREF
  _KAPC_STATE ApcState; // [rsp+38h] [rbp-50h] BYREF

  ret = 0;
  if ( !Process || !unicode_string )
    return 0;

  if ( Get_KeStackAttachProcess(Process, &ApcState) )
  {
    ProcessPeb = Get_PsGetProcessPeb(Process);
    if ( ProcessPeb )
    {
      ProcessParameters = ProcessPeb->ProcessParameters;
      if ( ProcessParameters )
      {
        EAC_IsUsermodeValidAddress(ProcessPeb->ProcessParameters, 0x80i64, 1);
        if ( ProcessParameters->Length >= 0x80 )
        {
          ImagePathName = *(&ProcessParameters->ImagePathName + (Flag != 0 ? 0x10 : 0));
          if ( !sub_14005D214(&ImagePathName) )
          {
            Address = ImagePathName.Buffer;
            if ( ImagePathName.Buffer < 0x1000 )
            {
              Address = (ProcessParameters + ImagePathName.Buffer);
              ImagePathName.Buffer = (ImagePathName.Buffer + ProcessParameters);
            }
            EAC_IsUsermodeValidAddress(Address, ImagePathName.MaximumLength, 1);
            ret = EAC_Check_Unicode_string(unicode_string, &ImagePathName);
          }
        }
      }
    }
    (loc_140054154)(Process, &ApcState);        // KeUnstackDetachProcess
  }
  return ret;
}
// 140053248: using guessed type _KAPC_STATE ApcState;

//----- (0000000140053360) ----------------------------------------------------
char __fastcall sub_140053360(__int64 Process, _UNICODE_STRING *unicode_string)
{
  char ret; // bl
  __int64 BaseAddress; // rbp
  __int64 AccessState; // r8
  unsigned int DesiredAccess; // r9d
  unsigned __int64 Handle; // [rsp+50h] [rbp+8h] BYREF

  ret = 0;
  if ( Process )
  {
    if ( unicode_string )
    {
      BaseAddress = Get_PsGetProcessSectionBaseAddress(Process);
      if ( BaseAddress )
      {
        DesiredAccess = 0x1000;
        if ( KUSER_SHARED_DATA.NtMajorVersion == 5 )
          DesiredAccess = 0x400;

        if ( Get_ObOpenObjectByPointer(Process, 0x200u, AccessState, DesiredAccess, PsProcessType, 0, &Handle) >= 0 )
        {
          ret = EAC_GetMappedFilename(Handle, BaseAddress, unicode_string);
          Get_NtClose(Handle);
        }
      }
    }
  }
  return ret;
}
// 1400533D4: variable 'AccessState' is possibly undefined
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140053410) ----------------------------------------------------
char __fastcall sub_140053410(__int64 Process, _UNICODE_STRING *unicode_string)
{
  char ret; // bl
  int (__fastcall *v5)(__int64, PVOID *); // rax
  PVOID Object; // [rsp+30h] [rbp+8h] BYREF

  ret = 0;
  if ( Process )
  {
    if ( unicode_string )
    {
      v5 = (loc_14005B768)(qword_140085AC0, &qword_140085AC0, 0i64);
      if ( v5 )
      {
        if ( v5(Process, &Object) >= 0 )
        {
          ret = sub_14003F268(Object, unicode_string);
          ObfDereferenceObject(Object);
        }
      }
    }
  }
  return ret;
}
// 140085AC0: using guessed type __int64 qword_140085AC0;

//----- (0000000140053488) ----------------------------------------------------
bool __fastcall EAC_GetNtoskrnlPath(unsigned __int16 *Length, char Flag)
{
  bool ret; // bl
  __int64 System_Information; // rax
  __int64 Buffer; // rdi
  __int64 System_Modules; // rcx
  bool v9; // zf
  __int64 ImageSize; // rcx MAPDST
  __int64 Size; // rax
  int BytesInMultiByteString; // [rsp+20h] [rbp-18h] BYREF

  ret = 0;
  if ( !Length )
    return 0;

  System_Information = Get_System_Information();
  Buffer = System_Information;
  if ( System_Information )
  {
    System_Modules = System_Information + 8;
    if ( !Flag )
      System_Modules += *(System_Information + 0x2E);

    v9 = System_Modules == 0xFFFFFFFFFFFFFFD8ui64;
    ImageSize = System_Modules + 0x28;
    if ( v9 )
    {
      BytesInMultiByteString = 0;
    }
    else
    {
      Size = -1i64;

      do
        ++Size;
      while ( *(ImageSize + Size) );

      LOWORD(BytesInMultiByteString) = Size;
      HIWORD(BytesInMultiByteString) = Size + 1;
    }
    ret = Get_RtlMultiByteToUnicodeN(Length, &BytesInMultiByteString) >= 0;
    Get_ExFreePool(Buffer);
  }
  return ret;
}

//----- (0000000140053528) ----------------------------------------------------
__int64 __fastcall EAC_Get_Process_Handle(__int64 ProcessId, unsigned int DesiredAccess)
{
  __int64 CurrentProcess; // rax
  __int64 AccessState; // r8
  int Status; // eax
  __int64 Handle; // [rsp+50h] [rbp+8h] MAPDST BYREF
  PVOID Object; // [rsp+60h] [rbp+18h] BYREF

  Handle = 0i64;
  CurrentProcess = Get_PsGetCurrentProcess();

  if ( ProcessId == Get_PsGetProcessId(CurrentProcess) )
    return -1i64;

  if ( ProcessId && DesiredAccess && Get_PsLookupProcessByProcessId(ProcessId, &Object) >= 0 )
  {
    Status = Get_ObOpenObjectByPointer(Object, 0x200u, AccessState, DesiredAccess, PsProcessType, 0, &Handle);
    if ( Status < 0 )
      Handle = 0i64;

    ObfDereferenceObject(Object);
  }
  return Handle;
}
// 1400535A0: variable 'AccessState' is possibly undefined

//----- (00000001400535D8) ----------------------------------------------------
char __fastcall sub_1400535D8(__int64 ProcessId, char *Buffer, _OWORD *Address, unsigned __int64 Size)
{
  char ret; // bl
  _KAPC_STATE ApcState; // [rsp+28h] [rbp-40h] BYREF
  PVOID Process; // [rsp+70h] [rbp+8h] BYREF

  ret = 0;
  if ( !ProcessId || !Buffer || !Address || !Size )
    return 0;
  if ( Get_PsLookupProcessByProcessId(ProcessId, &Process) >= 0 )
  {
    if ( Get_KeStackAttachProcess(Process, &ApcState) )
    {
      EAC_IsUsermodeValidAddress(Buffer, Size, 1);
      EAC_memcpy(Address, Buffer, Size);
      ret = 1;
      (loc_140054154)(Process, &ApcState);      // KeUnstackDetachProcess
    }
    ObfDereferenceObject(Process);
  }
  return ret;
}
// 1400535D8: using guessed type _KAPC_STATE ApcState;

//----- (0000000140053690) ----------------------------------------------------
char __fastcall sub_140053690(__int64 ProcessId, char *Address, char *Buffer, unsigned __int64 Size)
{
  char ret; // bl
  _KAPC_STATE ApcState; // [rsp+28h] [rbp-40h] BYREF
  PVOID Object; // [rsp+70h] [rbp+8h] BYREF

  ret = 0;
  if ( !ProcessId || !Address || !Buffer || !Size )
    return 0;

  if ( Get_PsLookupProcessByProcessId(ProcessId, &Object) >= 0 )
  {
    if ( Get_KeStackAttachProcess(Object, &ApcState) )
    {
      sub_14001D338(Address, Size);
      EAC_memcpy(Address, Buffer, Size);

      ret = 1;
      (loc_140054154)(Object, &ApcState);       // KeUnstackDetachProcess
    }
    ObfDereferenceObject(Object);
  }
  return ret;
}
// 140053690: using guessed type _KAPC_STATE ApcState;

//----- (0000000140053744) ----------------------------------------------------
char __fastcall EAC_Erase_ProcessMemory(__int64 ProcessId, __m128 *Address, unsigned __int64 Size)
{
  char ret; // bl
  char ApcState[56]; // [rsp+28h] [rbp-40h] BYREF
  PVOID Object; // [rsp+70h] [rbp+8h] BYREF

  ret = 0;
  if ( !ProcessId || !Address || !Size )
    return 0;

  if ( Get_PsLookupProcessByProcessId(ProcessId, &Object) >= 0 )
  {
    if ( Get_KeStackAttachProcess(Object, ApcState) )
    {
      EAC_IsUsermodeValidAddress(Address, Size, 1);
      EAC_memset(Address, 0, Size);
      ret = 1;
      (loc_140054154)(Object, ApcState);        // KeUnstackDetachProcess
    }
    ObfDereferenceObject(Object);
  }
  return ret;
}

//----- (00000001400537E8) ----------------------------------------------------
__int64 __fastcall EAC_Allocate_ProcessVirtualMemory(__int64 ProcessHandle, __int64 Size, __int64 unknown, int Protect)
{
  __int64 ret; // rbx
  __int64 BaseAddress[3]; // [rsp+30h] [rbp-18h] BYREF
  __int64 RegionSize; // [rsp+50h] [rbp+8h] BYREF

  ret = 0i64;
  RegionSize = Size;
  BaseAddress[0] = 0i64;

  if ( !Size )
    return 0i64;

  if ( Get_NtAllocateVirtualMemory(-1i64, BaseAddress, 0i64, &RegionSize, 0x3000, Protect) >= 0 )
    return BaseAddress[0];

  return ret;
}
// 1400537E8: using guessed type __int64 BaseAddress[3];

//----- (0000000140053838) ----------------------------------------------------
bool __fastcall Get_ZwProtectVirtualMemory_2(
        __int64 Address,
        __int64 Size,
        unsigned int NewProtect,
        __int64 OldProtection)
{
  __int64 BaseAddress; // [rsp+40h] [rbp+8h] BYREF
  __int64 Length; // [rsp+48h] [rbp+10h] BYREF

  BaseAddress = Address;
  Length = Size;
  return Address
      && Size
      && NewProtect
      && OldProtection
      && Get_ZwProtectVirtualMemory(-1i64, &BaseAddress, &Length, NewProtect, OldProtection) >= 0;
}

//----- (0000000140053884) ----------------------------------------------------
bool __fastcall EAC_Free_Memory(__int64 Address)
{
  __int64 BaseAddress; // [rsp+30h] [rbp+8h] BYREF
  __int64 RegionSize; // [rsp+38h] [rbp+10h] BYREF

  BaseAddress = Address;
  RegionSize = 0i64;
  return Address && Get_NtFreeVirtualMemory(-1i64, &BaseAddress, &RegionSize, 0x8000u) >= 0;
}

//----- (00000001400538C4) ----------------------------------------------------
bool __fastcall EAC_NtFreeVirtualMemory(__int64 ProcessId, __int64 Address, __int64 Size)
{
  bool Status; // bl
  __int64 Process_Handle; // rax MAPDST
  __int64 BaseAddress; // [rsp+38h] [rbp+10h] BYREF
  __int64 RegionSize; // [rsp+40h] [rbp+18h] BYREF

  RegionSize = Size;
  BaseAddress = Address;
  Status = 0;

  if ( !ProcessId || !Address )
    return 0;

  Process_Handle = EAC_Get_Process_Handle(ProcessId, 8u);
  if ( Process_Handle )
  {
    RegionSize = 0i64;
    Status = Get_NtFreeVirtualMemory(Process_Handle, &BaseAddress, &RegionSize, 0x8000u) >= 0;
    Get_NtClose(Process_Handle);
  }
  return Status;
}

//----- (0000000140053A58) ----------------------------------------------------
// from @Swiftik
char __fastcall EAC_ScanForWorkingSet(__int64 a1, char previousMode, __int64 *outDetectionBuffer)
{
  char ret; // r12
  char v5; // di
  __int64 Memory; // rax
  unsigned __int64 *Buffer; // r14
  __int64 v8; // rax
  _DWORD *v9; // rbx
  __int64 *v10; // r13
  __int64 v11; // rbx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  bool v14; // zf
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rax
  _DWORD *v21; // rdi
  char v22; // r15
  unsigned __int64 v23; // rbx
  unsigned int v24; // eax
  unsigned __int64 v25; // rcx
  _QWORD *v26; // rax
  unsigned __int64 v27; // rbx
  unsigned int v28; // eax
  unsigned __int64 v29; // rcx
  _QWORD *v30; // rax
  __int128 v31; // xmm1
  __int128 v32; // xmm0
  int v33; // eax
  __int64 v34; // rax
  __int64 v35; // rcx
  __int128 v37; // [rsp+38h] [rbp-99h]
  __int128 v38; // [rsp+48h] [rbp-89h] BYREF
  char v39; // [rsp+58h] [rbp-79h]
  __int128 v40; // [rsp+60h] [rbp-71h]
  __int128 v41; // [rsp+70h] [rbp-61h] BYREF
  char v42; // [rsp+80h] [rbp-51h]
  _UNICODE_STRING v43; // [rsp+88h] [rbp-49h] BYREF
  _UNICODE_STRING v44; // [rsp+98h] [rbp-39h] BYREF
  unsigned __int16 v45[8]; // [rsp+A8h] [rbp-29h] BYREF
  unsigned __int16 v46[8]; // [rsp+B8h] [rbp-19h] BYREF
  unsigned __int64 v47; // [rsp+C8h] [rbp-9h] BYREF
  __int64 v48; // [rsp+D0h] [rbp-1h]
  unsigned __int64 v49; // [rsp+138h] [rbp+67h]

  ret = 0;
  v5 = previousMode;
  if ( !outDetectionBuffer )
    return 0;
  *outDetectionBuffer = 0i64;
  Memory = EAC_Allocate_Memory(0x100000ui64);
  Buffer = Memory;
  if ( !Memory )
    return ret;

  if ( !(loc_140053930)(-1i64, 0i64, 1i64, Memory, 0x100000i64) )
    goto LABEL_55;
  v8 = EAC_Allocate_Memory(0x800ui64);
  v9 = v8;
  if ( !v8 )
  {
    *outDetectionBuffer = 0i64;
    goto LABEL_55;
  }
  EAC_memset((v8 + 8), 0, 0x7F8ui64);
  v49 = 0i64;
  *v9 = 16;
  v9[1] = 2048;
  v14 = *Buffer == 0;
  *outDetectionBuffer = v9;

  if ( v14 )
    goto LABEL_53;

  v10 = (Buffer + 1);
  do
  {
    v11 = *v10;
    v12 = *v10 & 0x1F;
    if ( v12 > 0x12 )
    {
      v15 = v12 - 19;
      v14 = v15 == 0;
    }
    else
    {
      if ( v12 == 18 )
        goto LABEL_19;
      v13 = v12 - 2;
      if ( !v13 )
        goto LABEL_19;
      v15 = v13 - 1;
      v14 = v15 == 0;
    }
    if ( !v14 )
    {
      v16 = v15 - 3;
      if ( !v16 )
        goto LABEL_33;
      v17 = v16 - 1;
      if ( v17 )
      {
        v18 = v17 - 3;
        if ( v18 )
        {
          v19 = v18 - 1;
          if ( v19 )
          {
            v20 = v19 - 3;
            if ( !v20 )
            {
LABEL_33:
              v21 = *outDetectionBuffer;
              v22 = 0;
              v39 = 0;
              v27 = v11 & 0xFFFFFFFFFFFFF000ui64;
              ret = 1;
              v37 = 0i64;
              v38 = 0i64;
              if ( v21 )
              {
                v28 = v21[1];
                if ( v28 >= 0x10 )
                {
                  ++v21[2];
                  if ( v28 - *v21 >= 0x21 )
                  {
                    v47 = v27;
                    if ( (loc_140053930)(-1i64, v27, 0i64, &v47, 48i64) )
                    {
                      v29 = 0i64;
                      if ( v21[3] )
                      {
                        v30 = v21 + 4;
                        while ( *v30 != v48 )
                        {
                          ++v29;
                          v30 = (v30 + 33);
                          if ( v29 >= v21[3] )
                            goto LABEL_41;
                        }
                        goto LABEL_50;
                      }
LABEL_41:
                      *&v37 = v48;
                      DWORD2(v37) = v27 - v48;
                      if ( EAC_GetMappedFilename(-1i64, v48, &v43) )
                      {
                        if ( EAC_Copy_Unicode_from_Unicode(&v43, v45) )
                        {
                          sub_14005D720(&v38 + 1, 16i64, v45);
                          v22 = v39;
                        }
                        EAC_Free_UnicodeString(&v43);
                      }
                    }
                    else
                    {
                      *&v37 = v27;
                    }
                    LOBYTE(v38) = (*v10 & 0x100i64) != 0;
                    v31 = v38;
                    HIDWORD(v37) = *v10 & 0x1F;
                    v32 = v37;
                    goto LABEL_49;
                  }
                }
              }
LABEL_50:
              v5 = previousMode;
              goto LABEL_51;
            }
            if ( v20 != 1 )
              goto LABEL_51;
          }
        }
      }
    }
LABEL_19:
    if ( v5 && (v11 & 0x100) == 0 )
    {
      v21 = *outDetectionBuffer;
      v22 = 0;
      v42 = 0;
      v23 = v11 & 0xFFFFFFFFFFFFF000ui64;
      ret = 1;
      v40 = 0i64;
      v41 = 0i64;
      if ( v21 )
      {
        v24 = v21[1];
        if ( v24 >= 0x10 )
        {
          ++v21[2];
          if ( v24 - *v21 >= 0x21 )
          {
            v47 = v23;
            if ( (loc_140053930)(-1i64, v23, 0i64, &v47, 48i64) )
            {
              v25 = 0i64;
              if ( v21[3] )
              {
                v26 = v21 + 4;
                while ( *v26 != v48 )
                {
                  ++v25;
                  v26 = (v26 + 33);
                  if ( v25 >= v21[3] )
                    goto LABEL_29;
                }
                goto LABEL_50;
              }
LABEL_29:
              *&v40 = v48;
              DWORD2(v40) = v23 - v48;
              if ( EAC_GetMappedFilename(-1i64, v48, &v44) )
              {
                if ( EAC_Copy_Unicode_from_Unicode(&v44, v46) )
                {
                  sub_14005D720(&v41 + 1, 0x10i64, v46);
                  v22 = v42;
                }
                EAC_Free_UnicodeString(&v44);
              }
            }
            else
            {
              *&v40 = v23;
            }
            v33 = *v10;
            LOBYTE(v41) = (*v10 & 0x100i64) != 0;
            v31 = v41;
            HIDWORD(v40) = v33 & 0x1F;
            v32 = v40;
LABEL_49:
            v34 = v21[3];
            v35 = 33 * v34;
            v21[3] = v34 + 1;
            *(v21 + v35 + 16) = v32;
            *(v21 + v35 + 32) = v31;
            *(v21 + v35 + 48) = v22;
            *v21 += 33;
          }
        }
      }
      goto LABEL_50;
    }
LABEL_51:
    ++v10;
    ++v49;
  }
  while ( v49 < *Buffer );
  if ( !ret )
  {
LABEL_53:
    Get_ExFreePool(*outDetectionBuffer);
    *outDetectionBuffer = 0i64;
  }
LABEL_55:
  Get_ExFreePool(Buffer);
  return ret;
}

//----- (0000000140053E00) ----------------------------------------------------
void __fastcall sub_140053E00(__int64 ProcessId, unsigned int a2)
{
  __int64 Process_Handle; // rax MAPDST

  if ( ProcessId )
  {
    Process_Handle = EAC_Get_Process_Handle(ProcessId, 1u);
    if ( Process_Handle )
    {
      sub_1400592FC(Process_Handle, a2);
      Get_NtClose(Process_Handle);
    }
  }
}

//----- (0000000140053F88) ----------------------------------------------------
char __fastcall Get_KeStackAttachProcess(__int64 Process, _KAPC_STATE *ApcState)
{
  char ret; // bl
  int (__fastcall *v5)(__int64); // rax
  void (__fastcall *g_KeStackAttachProcess)(__int64, _KAPC_STATE *); // rax

  ret = 0;
  if ( Process && ApcState )
  {
    if ( Get_PsGetCurrentProcess() == Process )
    {
      ApcState->Process = 1;
      return 1;
    }
    else
    {
      v5 = (loc_14005B768)(qword_140085A20, &qword_140085A20, 0i64);
      if ( v5 && v5(Process) >= 0 )             // No idea ...
      {
        g_KeStackAttachProcess = (loc_14005B768)(qword_140085F60, &qword_140085F60, 0i64);
        if ( g_KeStackAttachProcess )
          g_KeStackAttachProcess(Process, ApcState);// KeStackAttachProcess

        ret = 1;

        if ( Get_PsGetCurrentProcess() != Process )
          sub_140041CD4();
      }
    }
  }
  return ret;
}
// 140085A20: using guessed type __int64 qword_140085A20;
// 140085F60: using guessed type __int64 qword_140085F60;

//----- (0000000140054414) ----------------------------------------------------
char __fastcall sub_140054414(__int64 Process, _UNICODE_STRING *unicode_string)
{
  char ret; // bl

  ret = 0;
  if ( Process
    && unicode_string
    && (sub_140053410(Process, unicode_string)
     || sub_140053360(Process, unicode_string)
     || EAC_Get_ProcessParameters(Process, 0, unicode_string)) )
  {
    return 1;
  }
  return ret;
}

//----- (0000000140054C6C) ----------------------------------------------------
unsigned __int64 __fastcall sub_140054C6C(_OWORD *a1, __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 i; // rbx
  unsigned __int64 v6; // rbx

  v2 = 0i64;
  if ( a1 && a2 )
  {
    for ( i = 0i64; i < 0x100; ++i )
    {
      if ( !*(i + a2) )
        break;
    }
    v6 = i + 1;
    if ( v6 > 0x100 )
      v6 = 256i64;
    v2 = v6 + 12;
    EAC_memcpy(a1, a2, v6);
    *(a1 + v6) = *(a2 + 256);
    *(a1 + v6 + 8) = *(a2 + 264);
  }
  return v2;
}

//----- (0000000140054CEC) ----------------------------------------------------
__int64 __fastcall sub_140054CEC(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rsi
  __int64 Memory; // rax
  unsigned int v8; // r12d
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdi
  unsigned __int64 v12; // rbx

  v3 = 0i64;
  if ( !a1 || !a2 || !a3 )
    return 0i64;
  Memory = EAC_Allocate_Memory(544 * a3);
  *a1 = Memory;
  if ( Memory )
  {
    v8 = 0;
    if ( a3 )
    {
      v9 = 0i64;
      do
      {
        v10 = *a1;
        v11 = 544 * v9;
        *(v10 + v3) = *(544 * v9 + a2);
        v12 = sub_140054C6C((v3 + v10 + 8), 544 * v9 + a2 + 8) + 8;
        ++v8;
        v3 += v12 + sub_140054C6C((v3 + v12 + *a1), v11 + a2 + 276);
        v9 = v8;
      }
      while ( v8 < a3 );
    }
  }
  return v3;
}

//----- (000000014005557C) ----------------------------------------------------
__int64 __fastcall sub_14005557C(struct _UNICODE_STRING *unicode_string, _QWORD *Handle)
{
  __int64 v3; // rdx
  int ret; // esi
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  void *Memory; // rax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+60h] [rbp-88h] BYREF
  struct _OBJECT_ATTRIBUTES unicode_string_2; // [rsp+70h] [rbp-78h] BYREF
  __int64 v12[8]; // [rsp+A0h] [rbp-48h] BYREF

  if ( unicode_string && unicode_string->Buffer && unicode_string->Length && unicode_string->MaximumLength && Handle )
  {
    unicode_string_2.Length = 48;
    unicode_string_2.ObjectName = unicode_string;
    unicode_string_2.RootDirectory = 0i64;
    memset(Handle, 0, 0x48ui64);
    unicode_string_2.Attributes = 576;
    *&unicode_string_2.SecurityDescriptor = 0i64;
    ret = ZwCreateFile(Handle, 3u, &unicode_string_2, &IoStatusBlock, 0i64, 0, 3u, 1u, 0x20u, 0i64, 0);
    if ( ret < 0 )
      goto LABEL_16;

    ret = sub_14005974C(*Handle, v3, v5, v6, &IoStatusBlock, 0x900F4, 0i64, 0, v12, 0x40);
    if ( ret < 0 )
      goto LABEL_16;

    memset(Handle + 3, 0, 0x30ui64);
    v7 = v12[0];
    *(Handle + 8) = -1;
    Handle[7] = v7;
    *(Handle + 9) = 0;
    Handle[5] = 0i64;
    *(Handle + 0x10) = 0x40002;

    Memory = EAC_Allocate_Memory_2(1i64, 0x100000i64);
    Handle[1] = Memory;
    if ( Memory )
    {
      return 0;
    }
    else
    {
LABEL_16:
      if ( *Handle )
        Get_NtClose(*Handle);
    }
  }
  else
  {
    return 0xC0000001;
  }
  return ret;
}
// 140055678: variable 'v3' is possibly undefined
// 140055678: variable 'v5' is possibly undefined
// 140055678: variable 'v6' is possibly undefined
// 14005557C: using guessed type __int64 var_48[8];

//----- (0000000140055850) ----------------------------------------------------
char __fastcall sub_140055850(__int64 a1, _WORD *a2)
{
  _WORD *v2; // rsi
  char v4; // di
  _QWORD *v5; // rdx
  unsigned __int64 v6; // rax
  _QWORD *v7; // rax

  v2 = a2;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v4 = 1;
  v5 = EAC_Allocate_Memory_2(1i64, 0x30i64);
  if ( !v5 )
    return 0;
  v6 = -1i64;
  do
    ++v6;
  while ( *(v5 + v6 + 8) );
  if ( v6 <= 0xF )
  {
    for ( ; v6 < 0xF; ++v6 )
    {
      if ( !*v2 )
        break;
      *(v5 + v6 + 8) = *v2++;
    }
    *(v5 + v6 + 8) = 0;
  }
  v7 = *(a1 + 8);
  if ( *v7 != a1 )
    __fastfail(3u);
  *v5 = a1;
  v5[1] = v7;
  *v7 = v5;
  *(a1 + 8) = v5;
  return v4;
}

//----- (0000000140055A38) ----------------------------------------------------
char __fastcall sub_140055A38(__int64 *a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  char v7; // di
  _QWORD *Memory_2; // rbx
  __m128d v9; // xmm1
  __int64 v10; // rax
  int v11; // eax
  unsigned __int64 v12; // r8
  char *v13; // rdx
  int v15; // [rsp+28h] [rbp-99h]
  int v16; // [rsp+30h] [rbp-91h]
  int v17; // [rsp+40h] [rbp-81h]
  unsigned __int16 v18; // [rsp+68h] [rbp-59h] BYREF
  char *v19; // [rsp+70h] [rbp-51h]
  int v20; // [rsp+78h] [rbp-49h] BYREF
  __int64 v21; // [rsp+80h] [rbp-41h]
  __int128 v22; // [rsp+88h] [rbp-39h] BYREF
  __int128 v23; // [rsp+98h] [rbp-29h]
  __int128 v24; // [rsp+A8h] [rbp-19h]
  char v25[24]; // [rsp+B8h] [rbp-9h]
  __int128 v26; // [rsp+D0h] [rbp+Fh] BYREF
  __int64 v27; // [rsp+E0h] [rbp+1Fh]
  char v28[16]; // [rsp+E8h] [rbp+27h] BYREF
  HANDLE FileHandle; // [rsp+128h] [rbp+67h] BYREF
  int v30; // [rsp+138h] [rbp+77h]

  v30 = 246171658;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !a4 )
    return 0;
  v7 = 1;
  Memory_2 = EAC_Allocate_Memory_2(1i64, 0x228i64);
  if ( !Memory_2 )
    return 0;
  Memory_2[2] = *(a2 + 48);
  *(Memory_2 + 136) = EAC_HashCR32((a2 + 76), *(a2 + 72));
  v9 = *(a2 + 8);
  v10 = *a1;
  *&v25[4] = 2;
  *v25 = 24;
  *&v25[8] = v9;
  v27 = *&_mm_unpackhi_pd(v9, v9);
  v26 = *v25;
  v23 = 0i64;
  DWORD2(v23) = 64;
  v22 = 0i64;
  v24 = 0i64;
  if ( v10 )
  {
    *(&v22 + 1) = v10;
    v21 = &v26 + 8;
    v20 = 524296;
    LODWORD(v22) = 48;
    *&v23 = &v20;
    v24 = 0i64;
    v11 = sub_140058660(&FileHandle, 0x80000000, &v22, v28, v15, v16, 1, v17, 8224);
    if ( v11 >= 0 )
    {
      if ( sub_140042340(FileHandle) )
      {
        v12 = v18;
        v13 = v19;
        *(Memory_2 + 7) = v18;
        EAC_memcpy(Memory_2 + 2, v13, v12);
        EAC_Free_UnicodeString(&v18);
      }
      Get_NtClose(FileHandle);
      goto LABEL_12;
    }
  }
  else
  {
    v11 = -1073741823;
  }
  *(Memory_2 + 137) = v11;
LABEL_12:
  if ( !*(Memory_2 + 7) )
  {
    EAC_memcpy(Memory_2 + 2, (a2 + 76), *(a2 + 72));
    *(Memory_2 + 7) = *(a2 + 72);
  }
  *a4 = Memory_2;
  return v7;
}
// 140055B4A: variable 'v15' is possibly undefined
// 140055B4A: variable 'v16' is possibly undefined
// 140055B4A: variable 'v17' is possibly undefined
// 140055A38: using guessed type char var_30[16];

//----- (0000000140055D40) ----------------------------------------------------
__int64 sub_140055D40()
{
  unsigned int v0; // r14d
  unsigned int v1; // ebx
  unsigned int v2; // edx
  unsigned __int64 v3; // rdi
  unsigned int v4; // edx
  unsigned __int64 i; // rdi
  char v6; // cl
  unsigned int v7; // edx
  unsigned __int64 v8; // rdi
  int v9; // ecx
  unsigned __int64 j; // rdi
  char v11; // cl
  unsigned __int64 v12; // rdx
  unsigned int v13; // edi
  unsigned int v14; // edi
  unsigned __int64 k; // r8
  char v16; // dl
  unsigned __int64 Memory_2; // rsi
  unsigned __int64 v18; // r15
  unsigned __int8 m; // r12
  char v20; // bl
  unsigned int v21; // edx
  unsigned __int64 v22; // rdi
  unsigned int v23; // edx
  unsigned __int64 n; // rdi
  char v25; // cl
  unsigned __int64 v26; // rdi
  __int64 Length; // rbx
  int v28; // eax
  __int64 v29; // rax
  bool v30; // zf
  __int64 v31; // rdi
  unsigned __int64 v32; // r14
  int v33; // r14d
  __int128 v34; // xmm0
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rbx
  __int64 Memory; // rax
  __int64 v40; // rbx
  __int64 v41; // r9
  unsigned __int64 v42; // r10
  unsigned __int64 v43; // r8
  int v44; // eax
  int v45; // edi
  unsigned int v46; // r15d
  _BYTE *v47; // rdx
  char v48; // cl
  unsigned int v49; // edi
  unsigned int v50; // edi
  unsigned __int64 v51; // rcx
  __int64 ii; // rcx
  __int64 v53; // rdx
  __int64 v54; // rax
  __int128 v56; // [rsp+30h] [rbp-D0h]
  __int64 v57[2]; // [rsp+40h] [rbp-C0h] BYREF
  unsigned int v58; // [rsp+50h] [rbp-B0h]
  unsigned int v59; // [rsp+54h] [rbp-ACh]
  __int64 v60[2]; // [rsp+58h] [rbp-A8h] BYREF
  int v61[2]; // [rsp+68h] [rbp-98h]
  __int16 v62; // [rsp+70h] [rbp-90h]
  int v63[2]; // [rsp+72h] [rbp-8Eh]
  __int16 v64; // [rsp+7Ah] [rbp-86h]
  int v65[2]; // [rsp+7Ch] [rbp-84h]
  __int16 v66; // [rsp+84h] [rbp-7Ch]
  _UNICODE_STRING unicode_string2; // [rsp+88h] [rbp-78h] BYREF
  int v68[3]; // [rsp+98h] [rbp-68h]
  __int16 v69; // [rsp+A4h] [rbp-5Ch]
  _BYTE v70[10]; // [rsp+A6h] [rbp-5Ah] BYREF
  _BYTE v71[10]; // [rsp+B0h] [rbp-50h] BYREF
  _BYTE v72[10]; // [rsp+BAh] [rbp-46h] BYREF
  __int64 v73[2]; // [rsp+C8h] [rbp-38h] BYREF
  __int64 Buffer; // [rsp+D8h] [rbp-28h] BYREF
  _QWORD unicode_string[7]; // [rsp+E0h] [rbp-20h] BYREF
  int v76; // [rsp+118h] [rbp+18h]
  __int128 v77; // [rsp+120h] [rbp+20h]
  int v78; // [rsp+130h] [rbp+30h]
  int v79[6]; // [rsp+138h] [rbp+38h] BYREF
  __m128 v80[4]; // [rsp+150h] [rbp+50h] BYREF
  int v81; // [rsp+198h] [rbp+98h]
  int v82[10]; // [rsp+1A0h] [rbp+A0h] BYREF
  char v83[88]; // [rsp+1C8h] [rbp+C8h] BYREF
  char v84; // [rsp+230h] [rbp+130h]
  int v85; // [rsp+238h] [rbp+138h] BYREF
  ULONG Size; // [rsp+240h] [rbp+140h] BYREF
  unsigned int v87; // [rsp+248h] [rbp+148h]

  v59 = 246191253;
  v87 = 0;
  v0 = 0;
  unicode_string2 = 0i64;
  if ( Get_NtQueryInformationProcess(-1i64, 0x17u, v82, 0x24u, 0i64) >= 0 )
  {
    v1 = v82[0];
    v58 = v82[0];
    if ( v82[0] )
    {
      v61[0] = 1228389701;
      v60[1] = v60;
      v61[1] = 1339469054;
      v60[0] = v60;
      v2 = 1230159211;
      v3 = 0i64;
      v57[1] = v57;
      v57[0] = v57;
      v62 = 32;
      memset(v70, 0, sizeof(v70));
      do
      {
        *&v70[v3 * 4] = v61[v3] ^ v2;
        ++v3;
        v4 = ((v2 ^ (v2 >> 7)) << 9) ^ v2 ^ (v2 >> 7);
        v2 = __ROL4__((v4 >> 13) ^ v4, 3);
      }
      while ( v3 < 2 );
      for ( i = 8i64; i < 0xA; ++i )
      {
        v6 = v2;
        v2 >>= 8;
        v70[i] = *(v61 + i) ^ v6;
      }
      sub_140055850(v57, v70);
      v63[0] = -2116736898;
      v63[1] = 767675359;
      v7 = -2119817136;
      memset(v70, 0, sizeof(v70));
      v8 = 0i64;
      v64 = -22622;
      memset(v71, 0, sizeof(v71));
      do
      {
        v9 = v63[v8] ^ v7;
        v7 = __ROL4__(214013 * v7 + 2531011, 1);
        *&v71[v8 * 4] = v9;
        ++v8;
      }
      while ( v8 < 2 );
      for ( j = 8i64; j < 0xA; ++j )
      {
        v11 = v7;
        v7 >>= 8;
        v71[j] = *(v63 + j) ^ v11;
      }
      sub_140055850(v57, v71);
      v65[0] = 1721507961;
      v65[1] = 50947266;
      v12 = 0i64;
      memset(v71, 0, sizeof(v71));
      v13 = 1727537239;
      v66 = 20583;
      memset(v72, 0, sizeof(v72));
      do
      {
        *&v72[v12 * 4] = v65[v12] ^ v13;
        ++v12;
        v14 = ((v13 ^ (v13 >> 7)) << 9) ^ v13 ^ (v13 >> 7);
        v13 = __ROR4__((v14 >> 13) ^ v14, 2);
      }
      while ( v12 < 2 );
      for ( k = 8i64; k < 0xA; ++k )
      {
        v16 = v13;
        v13 >>= 8;
        v72[k] = *(v65 + k) ^ v16;
      }
      sub_140055850(v57, v72);
      memset(v72, 0, sizeof(v72));
      if ( v57[0] != v57 )
      {
        Memory_2 = EAC_Allocate_Memory_2(1i64, 56064i64);
        v18 = Memory_2;
        if ( !Memory_2 )
          goto LABEL_65;
        for ( m = 97; m <= 0x7Au; ++m )
        {
          if ( ((v1 >> (m - 97)) & 1) != 0 )
          {
            v68[0] = 1544606469;
            v69 = -5255;
            v20 = 0;
            v68[1] = -1378515585;
            v73[0] = 0i64;
            v21 = 1546638169;
            LODWORD(v73[1]) = 0;
            v22 = 0i64;
            WORD2(v73[1]) = 0;
            v68[2] = -280348204;
            do
            {
              *(v73 + v22 * 4) = v68[v22] ^ v21;
              ++v22;
              v23 = ((v21 ^ (v21 << 13)) >> 7) ^ v21 ^ (v21 << 13);
              v21 = ~((v23 << 17) ^ v23);
            }
            while ( v22 < 3 );
            for ( n = 12i64; n < 0xE; ++n )
            {
              v25 = v21;
              v21 >>= 8;
              *(v73 + n) = *(v68 + n) ^ v25;
            }
            if ( EAC_Read_String_From_Unicode_String(&unicode_string2, v73) )
            {
              v20 = 1;
              unicode_string2.Buffer[4] = m;
            }
            memset(v73, 0, 0xEui64);
            if ( v20 )
            {
              v26 = v18 + 2;
              *v18 = unicode_string2.Length;
              EAC_memcpy((v18 + 2), unicode_string2.Buffer, unicode_string2.Length);
              Length = unicode_string2.Length;
              v85 = 0;
              *(Length + v26) = (loc_140055BEC)(&unicode_string2, v57, &v85, v60);
              v28 = v85;
              v18 += 2 + Length + 6;
              *(Length + v26 + 4) = v85;
              if ( v28 )
              {
                while ( 1 )
                {
                  v38 = v60[0];
                  if ( v60[0] == v60 )
                    break;
                  v29 = *v60[0];
                  Buffer = 0i64;
                  Size = 0;
                  v84 = 0;
                  if ( *(v60[0] + 8) != v60 || *(v29 + 8) != v60[0] )
                    __fastfail(3u);
                  v60[0] = v29;
                  *(v29 + 8) = v60;
                  if ( v0 < 0x64 )
                  {
                    v30 = *(v38 + 0x20) == 92;
                    memset(&unicode_string[2], 0, 0x14ui64);
                    if ( v30
                      && EAC_Allocate_Unicode_string(
                           unicode_string,
                           &unicode_string2.Length,
                           *(v38 + 0x1C) + unicode_string2.Length) )
                    {
                      if ( sub_14005D584(unicode_string, (v38 + 0x20)) >= 0
                        && EAC_ReadFile(unicode_string, &Buffer, &Size) )
                      {
                        v31 = Buffer;
                        v32 = Size;
                        v84 = 1;
                        if ( Buffer )
                        {
                          v79[0] = 1732584193;
                          v79[1] = -271733879;
                          v79[2] = -1732584194;
                          v79[3] = 271733878;
                          v79[4] = -1009589776;
                          EAC_memset(v80, 0, 0x48ui64);
                          v81 = 0;
                          v35 = sub_140010C68(v79, v31, v32);
                          v36 = sub_140010B2C(v35, v83);
                          v34 = *v36;
                          v33 = *(v36 + 16);
                          v76 = v33;
                        }
                        else
                        {
                          v33 = 0;
                          v34 = 0i64;
                          v77 = 0i64;
                          v78 = 0;
                          v76 = 0;
                        }
                        *&unicode_string[5] = v34;
                        v56 = v34;
                        if ( v31 )
                          Get_ExFreePool(v31);
                      }
                      else
                      {
                        v33 = unicode_string[4];
                        v56 = *&unicode_string[2];
                      }
                      EAC_Free_UnicodeString(unicode_string);
                    }
                    else
                    {
                      v33 = unicode_string[4];
                      v56 = *&unicode_string[2];
                    }
                    *v18 = *(v38 + 16);
                    *(v18 + 8) = *(v38 + 28);
                    EAC_memcpy((v18 + 10), (v38 + 0x20), *(v38 + 28));
                    v37 = v18 + 10 + *(v38 + 28);
                    *v37 = v56;
                    *(v37 + 16) = v33;
                    v18 = v37 + 21;
                    v0 = v87 + 1;
                    *(v37 + 20) = v84;
                    v87 = v0;
                  }
                  Get_ExFreePool(v38);
                }
              }
              EAC_Free_UnicodeString(&unicode_string2);
            }
            v1 = v58;
          }
        }
        if ( v18 > Memory_2 )
        {
          Memory = EAC_Allocate_Memory(0x8208ui64);
          v40 = Memory;
          if ( Memory )
          {
            EAC_memset((Memory + 8), 0, 0x8200ui64);
            v41 = v40 + 8;
            *v40 = 0i64;
            *(v40 + 8) = 183963647;
            v42 = 0i64;
            v43 = 24i64;
            *(v40 + 12) = -760211755;
            *(v40 + 16) = 1892907783;
            *(v40 + 24) = 1015727191;
            *(v40 + 28) = -1723374961;
            v44 = -901405675 * (Memory_2 >> 2);
            v45 = v44 ^ 0x5D756904;
            v46 = v18 - Memory_2;
            *(v40 + 20) = v44 ^ 0xCF947F42;
            if ( v46 )
            {
              do
              {
                if ( v42 >= 0x8000 )
                  break;
                v47 = (v42 + Memory_2);
                v48 = 8 * (v42++ & 3);
                v49 = ((v45 ^ (v45 << 13)) >> 17) ^ v45 ^ (v45 << 13);
                ++v43;
                v50 = __ROL4__((32 * v49) ^ v49, 2);
                v47[v41 - Memory_2 + 24] = *v47 ^ (v50 >> v48);
                v45 = *v47 ^ v50;
              }
              while ( v42 < v46 );
            }
            v51 = (v43 + 255) & 0xFFFFFFFFFFFFFF00ui64;
            while ( v43 < v51 )
            {
              v45 *= -901405675;
              *(v43 + v41) = BYTE1(v45);
              ++v43;
            }
            *(v40 + 24) ^= v45;
            *(v40 + 28) ^= v42;
            *v40 = v43;
            (loc_140016B54)(1424584928i64, v40 + 8);
            Get_ExFreePool(v40);
          }
        }
        for ( ii = Memory_2; ; ii = v54 )
        {
          Get_ExFreePool(ii);
LABEL_65:
          v54 = v57[0];
          if ( v57[0] == v57 )
            break;
          v53 = *v57[0];
          if ( *(v57[0] + 8) != v57 || *(v53 + 8) != v57[0] )
            __fastfail(3u);
          v57[0] = *v57[0];
          *(v53 + 8) = v57;
        }
      }
    }
  }
  return v59;
}
// 140055D40: using guessed type unsigned int var_80[10];
// 140055D40: using guessed type __m128 var_D0[4];
// 140055D40: using guessed type char var_58[88];

//----- (0000000140056544) ----------------------------------------------------
__int64 sub_140056544()
{
  int v0; // ecx
  unsigned __int64 v1; // rdi
  unsigned int v2; // ecx
  int v3; // edx
  unsigned __int64 v4; // rdi
  unsigned int v5; // edx
  unsigned __int64 Memory_2; // rsi
  unsigned __int64 v7; // r15
  __int64 v8; // r14
  __int64 v9; // rax
  bool v10; // zf
  char *p_unicode_string; // rdx
  __int64 v12; // rbx
  char *v13; // rdx
  __int64 Memory; // rax
  __int64 v15; // rbx
  __int64 v16; // rdi
  unsigned __int64 v17; // r10
  unsigned __int64 v18; // r9
  int v19; // eax
  int v20; // r8d
  unsigned int v21; // r15d
  _BYTE *v22; // rdx
  char v23; // cl
  unsigned int v24; // r8d
  unsigned __int64 v25; // rcx
  __int64 i; // rax
  __int64 v27; // rdx
  __int64 v29[2]; // [rsp+20h] [rbp-69h] BYREF
  __int64 v30[2]; // [rsp+30h] [rbp-59h] BYREF
  int v31[6]; // [rsp+40h] [rbp-49h] BYREF
  int *v32; // [rsp+58h] [rbp-31h]
  __int64 *v33; // [rsp+60h] [rbp-29h]
  _BYTE v34[24]; // [rsp+68h] [rbp-21h] BYREF
  _UNICODE_STRING unicode_string; // [rsp+80h] [rbp-9h] BYREF
  _UNICODE_STRING v36; // [rsp+90h] [rbp+7h] BYREF
  char v37[64]; // [rsp+A0h] [rbp+17h] BYREF
  int v38; // [rsp+F8h] [rbp+6Fh] BYREF
  int v39; // [rsp+100h] [rbp+77h] BYREF
  int v40; // [rsp+104h] [rbp+7Bh]
  __int64 v41; // [rsp+108h] [rbp+7Fh] BYREF

  v38 = 0;
  v30[1] = v30;
  v0 = -393240837;
  v30[0] = v30;
  v29[1] = v29;
  v29[0] = v29;
  v41 = 0i64;
  v1 = 0i64;
  v39 = 1851380488;
  v40 = 465388358;
  v32 = &v39;
  v33 = &v41;
  do
  {
    v2 = ((v0 ^ (v0 << 13)) >> 17) ^ v0 ^ (v0 << 13);
    v0 = __ROR4__((32 * v2) ^ v2, 3);
    *(v33 + v1 * 4) = v32[v1] ^ v0;
    ++v1;
  }
  while ( v1 < 2 );
  sub_140055850(v29, &v41);
  memset(&v41, 0, sizeof(v41));
  if ( v29[0] != v29 )
  {
    v31[0] = 1808655782;
    v31[1] = 831533788;
    v31[2] = 342649758;
    v3 = -1770298162;
    v31[3] = 2139084140;
    v4 = 0i64;
    v31[4] = 1134162456;
    v31[5] = -1422091066;
    memset(v34, 0, sizeof(v34));
    v33 = v31;
    v32 = v34;
    do
    {
      v5 = ((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13);
      v3 = __ROL4__((32 * v5) ^ v5, 4);
      v32[v4] = *(v33 + v4 * 4) ^ v3;
      ++v4;
    }
    while ( v4 < 6 );
    Get_Unicode_string_Inline(&v36, v34);
    Memory_2 = EAC_Allocate_Memory_2(0x220i64, 0x64i64);
    v7 = Memory_2;
    if ( Memory_2 )
    {
      if ( (loc_140055BEC)(&v36, v29, &v38, v30) >= 0 )
      {
        v8 = v30[0];
        if ( v30[0] != v30 )
        {
          do
          {
            v9 = *v8;
            if ( *(v8 + 8) != v30 || *(v9 + 8) != v8 )
              __fastfail(3u);
            v30[0] = *v8;
            *(v9 + 8) = v30;
            Get_Unicode_string_Inline(&unicode_string, (v8 + 32));
            v10 = EAC_Copy_Unicode_from_Unicode(&unicode_string.Length, v37) == 0;
            p_unicode_string = v37;
            if ( v10 )
              p_unicode_string = &unicode_string;
            *v7 = *(v8 + 16);
            v12 = *p_unicode_string;
            v13 = *(p_unicode_string + 1);
            *(v7 + 8) = v12;
            EAC_memcpy((v7 + 10), v13, v12);
            v7 += v12 + 10;
            Get_ExFreePool(v8);
            v8 = v30[0];
          }
          while ( v30[0] != v30 );
          if ( v7 > Memory_2 )
          {
            Memory = EAC_Allocate_Memory(0x8208ui64);
            v15 = Memory;
            if ( Memory )
            {
              EAC_memset((Memory + 8), 0, 0x8200ui64);
              *v15 = 0i64;
              v16 = v15 + 8;
              v17 = 0i64;
              *(v15 + 8) = 2056183364;
              *(v15 + 12) = 1026006688;
              *(v15 + 16) = 1284359027;
              v18 = 24i64;
              *(v15 + 24) = -2140254906;
              *(v15 + 28) = -1795742713;
              v19 = -118451561 * (Memory_2 >> 2);
              v20 = v19 ^ 0x2892A344;
              v21 = v7 - Memory_2;
              *(v15 + 20) = v19 ^ 0x3B997B67;
              if ( v21 )
              {
                do
                {
                  if ( v17 >= 0x8000 )
                    break;
                  v22 = (v17 + Memory_2);
                  v23 = v17++ & 3;
                  ++v18;
                  v24 = __ROL4__(2043766247 - 134787519 * v20, 2);
                  v22[v16 - Memory_2 + 24] = *v22 ^ (v24 >> (8 * v23));
                  v20 = *v22 ^ v24;
                }
                while ( v17 < v21 );
              }
              v25 = (v18 + 255) & 0xFFFFFFFFFFFFFF00ui64;
              while ( v18 < v25 )
              {
                v20 *= -118451561;
                *(v18 + v16) = BYTE1(v20);
                ++v18;
              }
              *(v15 + 24) ^= v20;
              *(v15 + 28) ^= v17;
              *v15 = v18;
              (loc_140016B54)(1778651947i64, v15 + 8, v18);
              Get_ExFreePool(v15);
            }
          }
        }
      }
      Get_ExFreePool(Memory_2);
    }
    for ( i = v29[0]; v29[0] != v29; i = v29[0] )
    {
      v27 = *i;
      if ( *(i + 8) != v29 || *(v27 + 8) != i )
        __fastfail(3u);
      v29[0] = *i;
      *(v27 + 8) = v29;
      Get_ExFreePool(i);
    }
    memset(v34, 0, sizeof(v34));
  }
  return 246204512i64;
}

//----- (00000001400569D8) ----------------------------------------------------
char __fastcall sub_1400569D8(__int64 a1, __int64 a2, _QWORD *a3, _DWORD *a4)
{
  char v7; // bl
  unsigned int v8; // eax
  _DWORD *v9; // rax
  _DWORD *v10; // rdx
  __int64 v11; // rax

  v7 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          v8 = *(a1 + 152);
          if ( v8 )
          {
            if ( *(a1 + 156) )
            {
              v9 = sub_14001D510(v8, a1);
              v10 = v9;
              if ( v9 )
              {
                v11 = v9[5];
                if ( __PAIR64__(v11, v10[4]) )
                {
                  *a3 = a2 + v11;
                  *a4 = v10[4];
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return v7;
}

//----- (0000000140056A70) ----------------------------------------------------
char __fastcall sub_140056A70(__int64 a1, unsigned int a2, _WORD *a3)
{
  __int64 v4; // r14
  char v6; // bl
  __int64 v7; // rax
  __int64 v8; // rdx
  _TBYTE v10; // [rsp+20h] [rbp-C8h] BYREF
  int v11; // [rsp+2Ah] [rbp-BEh]
  int v12; // [rsp+2Eh] [rbp-BAh]
  int v13; // [rsp+32h] [rbp-B6h]
  int v14; // [rsp+36h] [rbp-B2h]
  int v15; // [rsp+3Ah] [rbp-AEh]
  __int16 v16; // [rsp+3Eh] [rbp-AAh]
  char v17[32]; // [rsp+40h] [rbp-A8h] BYREF
  __int128 v18; // [rsp+60h] [rbp-88h] BYREF
  __int64 v19; // [rsp+70h] [rbp-78h]
  int v20; // [rsp+78h] [rbp-70h]
  __int16 v21; // [rsp+7Ch] [rbp-6Ch]

  v4 = a2;
  v6 = 0;
  LOBYTE(v10) = 0;
  *(&v10 + 2) = 0xB8D5FF907DEDB914ui64;
  v11 = -580342075;
  v12 = 1720926793;
  v13 = 1037456797;
  v14 = -1466138151;
  v15 = 31254907;
  v16 = 22969;
  v7 = sub_140056B8C(&v10 + 2, v17);
  v8 = (loc_1400327F4)(a1, v4, v7, 30i64, *&v10);
  memset(v17, 0, 0x1Eui64);
  if ( v8 )
  {
    if ( v8 + 60 < (a1 + v4) )
    {
      v18 = *(v8 + 30);
      v19 = *(v8 + 46);
      v20 = *(v8 + 54);
      v21 = 0;
      if ( EAC_Read_String_From_Unicode_String(a3, &v18) )
      {
        if ( *a3 < 0xEu )
          EAC_Free_UnicodeString(a3);
        else
          return 1;
      }
    }
  }
  return v6;
}

//----- (0000000140056B8C) ----------------------------------------------------
__int64 __fastcall sub_140056B8C(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r9
  unsigned __int64 i; // r11
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 24) = 0;
  v3 = 2107619652;
  *(a2 + 28) = 0;
  v4 = 28i64;
  for ( i = 0i64; i < 0x1C; i += 4i64 )
  {
    *(a2 + i) = *(a1 + i) ^ v3;
    v3 = __ROL4__(((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13) ^ (32 * (((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13))), 1);
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v4) = *(a1 + v4) ^ v6;
    ++v4;
  }
  while ( v4 < 0x1E );
  return result;
}

//----- (0000000140056CD0) ----------------------------------------------------
__int64 Get_BuildNumber()
{
  __int64 result; // rax
  struct _OSVERSIONINFOW VersionInformation; // [rsp+20h] [rbp-128h] BYREF

  result = dword_140086528;
  if ( !dword_140086528 )
  {
    EAC_memset(&VersionInformation.dwMajorVersion, 0, 0x118ui64);
    VersionInformation.dwOSVersionInfoSize = 284;
    RtlGetVersion(&VersionInformation);
    result = VersionInformation.dwBuildNumber;
    dword_140086528 = VersionInformation.dwBuildNumber;
  }
  return result;
}
// 140086528: using guessed type int dword_140086528;

//----- (0000000140056D18) ----------------------------------------------------
char __fastcall sub_140056D18(_OWORD *a1, _DWORD *a2)
{
  char v4; // di
  unsigned int v7; // eax
  _DWORD *v8; // rax
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rcx
  _DWORD *v12; // rax
  struct _UNICODE_STRING String[3]; // [rsp+28h] [rbp-30h] BYREF
  __int64 NtHeaders; // [rsp+60h] [rbp+8h] MAPDST BYREF
  unsigned __int64 BaseAddress; // [rsp+70h] [rbp+18h] MAPDST BYREF

  v4 = 0;
  if ( !a1 || !a2 )
    return 0;
  if ( EAC_GetNtoskrnlPath(&String[0].Length, 1) )
  {
    if ( EAC_ReadFile(String, &BaseAddress, &NtHeaders) )
    {
      NtHeaders = NtHeaders;
      if ( GetModuleInfo(BaseAddress, NtHeaders, 0i64, &NtHeaders) )
      {
        v7 = *(NtHeaders + 0xB8);
        if ( v7 )
        {
          v8 = sub_14001D56C(v7, NtHeaders, BaseAddress);
          if ( v8 )
          {
            if ( v8 >= BaseAddress && v8 + 7 > v8 )
            {
              v10 = BaseAddress + NtHeaders;
              if ( (v8 + 7) <= v10 )
              {
                v11 = v8[5];
                if ( v11 )
                {
                  if ( v8[3] == 2 )
                  {
                    v12 = sub_14001D56C(v11, NtHeaders, BaseAddress);
                    if ( v12 )
                    {
                      if ( v12 >= BaseAddress && (v12 + 25) > v12 && v12 + 25 <= v10 && *v12 == 1396986706 )
                      {
                        *a1 = *(v12 + 1);
                        *a2 = v12[5];
                        v4 = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ( BaseAddress )
        Get_ExFreePool(BaseAddress);
    }
    EAC_Free_UnicodeString(String);
  }
  return v4;
}
// 140056DE1: variable 'NtHeaders' is possibly undefined

//----- (0000000140056E5C) ----------------------------------------------------
unsigned __int64 sub_140056E5C()
{
  return __readmsr(0x40000001u);
}

//----- (0000000140056EC8) ----------------------------------------------------
__int64 __fastcall EAC_NtQuerySystemInformation(
        unsigned int SystemInformationClass,
        unsigned int SystemInformation,
        unsigned int Info,
        int *Size)
{
  __int64 Allocate; // rax MAPDST
  int Status; // r14d
  int Length; // [rsp+48h] [rbp+10h] MAPDST BYREF

  Allocate = 0i64;
  if ( SystemInformation <= Info )
  {
    do
    {
      Allocate = EAC_Allocate_Memory(SystemInformation);
      if ( !Allocate )
        break;

      Status = Get_NtQuerySystemInformation(SystemInformationClass, Allocate, SystemInformation, &Length);
      if ( Status >= 0 )
      {
        if ( !Length )
        {
          Get_ExFreePool(Allocate);
          Allocate = 0i64;
        }

        if ( Size )
          *Size = Length;
        return Allocate;
      }

      Get_ExFreePool(Allocate);
      Allocate = 0i64;
      SystemInformation *= 2;
    }
    while ( Status == 0xC0000004 && SystemInformation <= Info );
  }
  return Allocate;
}

//----- (0000000140056F70) ----------------------------------------------------
char __fastcall sub_140056F70(unsigned __int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned int v3; // edx
  int v4; // r10d
  int v6; // r11d
  int v7; // eax
  __int64 v8; // r9
  __m128 *i; // rcx
  int v11; // eax
  bool v12; // zf

  v3 = 0;
  v4 = 0;
  if ( !a1 )
    return 0;
  if ( !a3 )
    return 0;
  v6 = *a3;
  if ( !v6 )
    return 0;
  v7 = *(a3 + 5);
  if ( (v7 & 0x200) != 0 )
  {
    if ( (v7 & 4) != 0 )
    {
      v3 = 1;
    }
    else if ( (v7 & 8) != 0 )
    {
      v3 = 2;
    }
    else if ( (v7 & 0x10) != 0 )
    {
      v3 = 4;
    }
    else
    {
      v8 = 0i64;
      if ( (v7 & 0x20) == 0 )
      {
LABEL_14:
        if ( !v3 || !v4 )
          return 0;
        goto LABEL_24;
      }
      v3 = 8;
    }
    v8 = 2i64;
    v4 = 2;
    goto LABEL_14;
  }
  if ( (v7 & 0x40) != 0 )
  {
    v3 = 1;
    v8 = 1i64;
LABEL_24:
    for ( i = (a1 + v6 - v3); ; i = (i - 1) )
    {
      if ( i <= a1 )
        return 0;
      if ( v8 != 1 )
        break;
      if ( v3 == 1 && i->m128_i8[0] == a3[16] || v3 == 2 && i->m128_i16[0] == *(a3 + 8) )
      {
LABEL_41:
        EAC_memset(i, 0xAAu, v3);
        return 1;
      }
      if ( v3 == 4 )
      {
        v11 = *(a3 + 4);
        goto LABEL_33;
      }
LABEL_45:
      ;
    }
    if ( v8 != 2 )
      goto LABEL_45;
    switch ( v3 )
    {
      case 1u:
        if ( i->m128_i8[0] == a3[8] )
          goto LABEL_41;
        break;
      case 2u:
        if ( i->m128_i16[0] == *(a3 + 4) )
          goto LABEL_41;
        break;
      case 4u:
        v11 = *(a3 + 2);
LABEL_33:
        v12 = i->m128_i32[0] == v11;
LABEL_44:
        if ( v12 )
          goto LABEL_41;
        goto LABEL_45;
    }
    if ( v3 != 8 )
      goto LABEL_45;
    v12 = i->m128_u64[0] == *(a3 + 1);
    goto LABEL_44;
  }
  if ( (v7 & 0x80u) != 0 )
  {
    v3 = 2;
LABEL_23:
    v8 = 1i64;
    goto LABEL_24;
  }
  if ( (v7 & 0x100) != 0 )
  {
    v3 = 4;
    goto LABEL_23;
  }
  return 0;
}

//----- (000000014005709C) ----------------------------------------------------
_WORD *__fastcall sub_14005709C(_BYTE *a1)
{
  _WORD *v2; // rbx
  __int64 v3; // rax
  unsigned int v4; // esi
  _BYTE *v5; // r8
  __int64 v6; // rdi
  __int64 v7; // rax
  int v8; // r14d
  unsigned int v9; // edi
  unsigned __int8 *v10; // r15
  int v11; // ecx
  unsigned __int8 v12; // al
  unsigned __int8 *v13; // rsi
  char v14; // r12
  unsigned int v15; // r13d
  unsigned int v16; // edi
  unsigned int v17; // r15d
  unsigned int v18; // eax
  __int64 v19; // rdx
  unsigned __int8 v20; // cl
  char v21; // al
  unsigned __int8 v22; // cl
  unsigned __int64 v23; // r9
  _WORD *v24; // rax
  unsigned __int64 v25; // r8
  _BYTE *v26; // rdx
  int *v27; // rdi
  unsigned __int64 v28; // rcx
  bool v29; // zf
  __m128i si128; // [rsp+21h] [rbp-347h] BYREF
  int v32; // [rsp+31h] [rbp-337h]
  int v33; // [rsp+35h] [rbp-333h]
  int v34; // [rsp+39h] [rbp-32Fh]
  __int16 v35; // [rsp+3Dh] [rbp-32Bh]
  char v36; // [rsp+3Fh] [rbp-329h]
  unsigned int i; // [rsp+40h] [rbp-328h]
  unsigned int v38; // [rsp+44h] [rbp-324h]
  int v39; // [rsp+48h] [rbp-320h]
  unsigned int v40; // [rsp+4Ch] [rbp-31Ch]
  unsigned __int8 *v41; // [rsp+50h] [rbp-318h]
  unsigned __int64 v42; // [rsp+58h] [rbp-310h] BYREF
  _WORD *v43; // [rsp+60h] [rbp-308h]
  __int128 v44; // [rsp+68h] [rbp-300h] BYREF
  __int64 v45; // [rsp+78h] [rbp-2F0h]
  _WORD *v46; // [rsp+80h] [rbp-2E8h] BYREF
  unsigned __int64 v47; // [rsp+88h] [rbp-2E0h]
  _BYTE *v48; // [rsp+90h] [rbp-2D8h]
  int *v49; // [rsp+98h] [rbp-2D0h]
  char v50[21]; // [rsp+A0h] [rbp-2C8h] BYREF
  __int64 v51; // [rsp+B5h] [rbp-2B3h]
  __int64 v52; // [rsp+BDh] [rbp-2ABh]
  char v53[40]; // [rsp+C8h] [rbp-2A0h] BYREF
  _OWORD v54[4]; // [rsp+F0h] [rbp-278h] BYREF
  int v55[142]; // [rsp+130h] [rbp-238h] BYREF
  ULONG v56; // [rsp+370h] [rbp+8h] BYREF
  __int64 v57; // [rsp+378h] [rbp+10h] BYREF
  __m128 *v58; // [rsp+380h] [rbp+18h]
  unsigned __int64 v59; // [rsp+388h] [rbp+20h]

  v2 = 0i64;
  v43 = 0i64;
  v44 = 0i64;
  v45 = 0i64;
  if ( !a1 || !*a1 )
    return 0i64;
  si128 = _mm_load_si128(xmmword_14007E660);
  v32 = 2110767443;
  v33 = -844796672;
  v34 = -1824534175;
  v35 = -11326;
  v36 = -2;
  v3 = sub_1400574F4(&si128, v53);
  v4 = 0;
  if ( v3 && sub_14002BC44(v3, &v57, &v56) )
  {
    v5 = a1;
    v6 = v57;
    v7 = sub_14001E410(v57, v56, v5);
    if ( v7 )
    {
      v4 = v56 - v7;
      if ( v56 - v7 > 0x40 )
        v4 = 64;
      EAC_memcpy(v54, (v7 + v6), v4);
    }
    if ( v6 )
      Get_ExFreePool(v6);
  }
  memset(v53, 0, 0x1Fui64);
  if ( !v4 || !EAC_GetNtoskrnlSection(0x747865742Ei64, &v46, &v42) )
    return 0i64;
  v8 = 0;
  v39 = 0;
  v9 = 0;
  for ( i = 0; v9 < 0x10; i = v9 )
  {
    v10 = v54 + v9;
    v11 = sub_1400210C8(v10, v50);
    if ( (v52 & 0x100000000000i64) != 0 )
      break;
    v12 = *v10;
    if ( *v10 == 0xB8 )
    {
      v8 = *(v54 + v9 + 1);
      v39 = v8;
      break;
    }
    if ( v12 == 0xC2 || v12 == 0xC3 )
      break;
    v9 += v11;
  }
  if ( v8 )
  {
    si128.m128i_i64[0] = 0x826DE882523B7E3Dui64;
    si128.m128i_i64[1] = 0x673BFA562DC1D29Bi64;
    v32 = -1646745341;
    v13 = (loc_14003CB4C)(&si128);
    v41 = v13;
    if ( v13 )
    {
      v14 = 0;
      v15 = 0;
      v40 = 0;
      v16 = 0;
      v38 = 0;
      v17 = 0;
      for ( i = 0; v17 < 0x10; i = v17 )
      {
        v18 = sub_1400210C8(v13, v50);
        LODWORD(v57) = v18;
        if ( (v52 & 0x100000000000i64) != 0 )
          break;
        v59 = v18;
        v58 = (v55 + v16);
        EAC_memcpy(v58, v13, v18);
        v20 = *v13;
        if ( *v13 == 0xB8 )
        {
          v15 = v16 + 1;
          v40 = v16 + 1;
          *(v55 + v16 + 1) = v8;
        }
        else
        {
          if ( (v20 + 62) <= 1u )
          {
            if ( v20 == 0xC2 )
              *(v55 + v16 + 1) = -21846;
            v16 += v57;
            v38 = v16;
            v14 = 1;
            break;
          }
          if ( (v52 & 0x20000000000i64) != 0 || (v52 & 0x10000000000i64) != 0 )
          {
            LOBYTE(v44) = v50[0];
            *(&v44 + 1) = v51;
            v45 = v52;
            v21 = sub_140056F70(v58, v19, &v44);
            v22 = *v13;
            LOBYTE(v56) = *v13;
            if ( !v21 )
            {
              EAC_memset(v58, 0xAAu, v59);
              v22 = v56;
              v58->m128_i8[0] = v56;
            }
            if ( v22 == 0xE9 )
            {
              v16 += v57;
              v38 = v16;
              goto LABEL_40;
            }
          }
        }
        v16 += v57;
        v38 = v16;
        v13 += v59;
        v41 = v13;
        ++v17;
      }
      if ( !v14 )
        return v2;
LABEL_40:
      if ( v15 )
      {
        if ( v16 >= 2 )
        {
          v23 = v16;
          if ( v16 <= v42 )
          {
            v24 = v46;
            v41 = v46;
            v25 = v46 + v42 - v16;
            while ( v24 < v25 )
            {
              if ( *v24 == LOWORD(v55[0]) )
              {
                v26 = v24;
                v48 = v24;
                v27 = v55;
                v28 = 0i64;
                v47 = 0i64;
                while ( 1 )
                {
                  v49 = v27;
                  v29 = v28 == v23;
                  if ( v28 >= v23 )
                    break;
                  if ( *v26 != *v27 && *v27 != 0xAA )
                  {
                    v29 = v28 == v23;
                    break;
                  }
                  v47 = ++v28;
                  v48 = ++v26;
                  v27 = (v27 + 1);
                }
                if ( v29 )
                {
                  v2 = v24;
                  v43 = v24;
                  return v2;
                }
              }
              v24 = (v24 + 1);
              v41 = v24;
            }
          }
        }
      }
    }
  }
  return v2;
}
// 140057392: variable 'v19' is possibly undefined
// 14001E410: using guessed type __int64 __fastcall sub_14001E410(_QWORD, _QWORD, _QWORD);
// 14007E660: using guessed type __m128i xmmword_14007E660[6];

//----- (00000001400574F4) ----------------------------------------------------
__int64 __fastcall sub_1400574F4(__int64 a1, __int64 a2)
{
  unsigned int v3; // r8d
  unsigned __int64 v4; // r9
  unsigned __int64 i; // r11
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 24) = 0;
  v3 = -1740587349;
  *(a2 + 28) = 0;
  v4 = 28i64;
  *(a2 + 30) = 0;
  for ( i = 0i64; i < 0x1C; i += 4i64 )
  {
    *(a2 + i) = *(a1 + i) ^ v3;
    v3 = __ROL4__(((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13) ^ (32 * (((v3 ^ (v3 << 13)) >> 17) ^ v3 ^ (v3 << 13))), 3);
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v4) = *(a1 + v4) ^ v6;
    ++v4;
  }
  while ( v4 < 0x1F );
  return result;
}

//----- (0000000140058588) ----------------------------------------------------
__int64 __fastcall Get_NtDeviceIoControlFile(
        __int64 FileHandle,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 IoStatusBlock,
        int a6,
        __int64 InputBuffer,
        int a8,
        __int64 OutputBuffer)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v11; // eax
  char v12; // di
  __int64 (__fastcall *g_NtDeviceIoControlFile)(__int64, _QWORD, _QWORD, _QWORD, __int64, int, __int64, int, __int64, int); // rsi
  unsigned int Status; // esi

  CurrentThread = KeGetCurrentThread();
  v11 = sub_140035ED4();

  if ( CurrentThread && v11 )
    v12 = *(CurrentThread + v11);
  else
    v12 = 0;

  g_NtDeviceIoControlFile = (loc_14005B768)(qword_1400860C8, &qword_1400860C8, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_NtDeviceIoControlFile )
    Status = g_NtDeviceIoControlFile(           // NtDeviceIoControlFile
               FileHandle,
               0i64,
               0i64,
               0i64,
               IoStatusBlock,
               0x170002,
               InputBuffer,
               4,
               OutputBuffer,
               6);
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v12);

  return Status;
}
// 1400860C8: using guessed type __int64 qword_1400860C8;

//----- (0000000140058660) ----------------------------------------------------
__int64 __fastcall sub_140058660(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v14; // eax
  char v15; // si
  __int64 (__fastcall *v16)(__int64, _QWORD, __int64, __int64, _QWORD, int, int, int, int, _QWORD, _DWORD); // rdi
  unsigned int v17; // edi

  CurrentThread = KeGetCurrentThread();
  v14 = sub_140035ED4();
  if ( CurrentThread && v14 )
    v15 = *(CurrentThread + v14);
  else
    v15 = 0;
  v16 = (loc_14005B768)(qword_1400860D0, &qword_1400860D0, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( v16 )
    v17 = v16(a1, a2, a3, a4, 0i64, 128, a7, 1, a9, 0i64, 0);
  else
    v17 = -1073741822;
  sub_140036990(CurrentThread, v15);
  return v17;
}
// 1400860D0: using guessed type __int64 qword_1400860D0;

//----- (0000000140058750) ----------------------------------------------------
__int64 __fastcall sub_140058750(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        int a8,
        int a9,
        __int64 a10)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v12; // eax
  char v13; // di
  __int64 (__fastcall *v14)(__int64, _QWORD, _QWORD, _QWORD, __int64, __int64, int, int, char, __int64, char); // rsi
  unsigned int v15; // esi
  char v17; // [rsp+40h] [rbp-28h]
  char v18; // [rsp+50h] [rbp-18h]

  CurrentThread = KeGetCurrentThread();
  v12 = sub_140035ED4();
  if ( CurrentThread && v12 )
    v13 = *(CurrentThread + v12);
  else
    v13 = 0;
  v14 = (loc_14005B768)(qword_1400860D8, &qword_1400860D8, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( v14 )
  {
    v18 = 1;
    v17 = 0;
    v15 = v14(a1, 0i64, 0i64, 0i64, a5, a6, 4096, 1, v17, a10, v18);
  }
  else
  {
    v15 = -1073741822;
  }
  sub_140036990(CurrentThread, v13);
  return v15;
}
// 1400860D8: using guessed type __int64 qword_1400860D8;

//----- (000000014005882C) ----------------------------------------------------
__int64 __fastcall Get_NtClose(unsigned __int64 Handle)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v3; // eax
  char v4; // si
  __int64 (__fastcall *g_NtClose)(unsigned __int64); // rbp
  unsigned int Status; // edi

  if ( Handle > 0xFFFFFFFFFFFFFFFDui64 )
    return 0i64;

  CurrentThread = KeGetCurrentThread();

  v3 = sub_140035ED4();

  if ( CurrentThread && v3 )
    v4 = *(CurrentThread + v3);
  else
    v4 = 0;

  g_NtClose = (loc_14005B768)(qword_1400860E0, &qword_1400860E0, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_NtClose )
    Status = g_NtClose(Handle);                 // NtClose
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v4);

  return Status;
}
// 1400860E0: using guessed type __int64 qword_1400860E0;

//----- (00000001400588C8) ----------------------------------------------------
__int64 __fastcall sub_1400588C8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, __int64 a6)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v9; // eax
  char v10; // di
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64, char, __int64, _QWORD); // rsi
  __int64 v12; // r9
  unsigned int v13; // esi
  char v15; // [rsp+20h] [rbp-28h]

  CurrentThread = KeGetCurrentThread();
  v9 = sub_140035ED4();
  if ( CurrentThread && v9 )
    v10 = *(CurrentThread + v9);
  else
    v10 = 0;
  v11 = (loc_14005B768)(qword_1400860F0, &qword_1400860F0, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( v11 )
  {
    LOBYTE(v12) = 1;
    v15 = 0;
    v13 = v11(a1, a2, 0x400i64, v12, v15, a6, 0i64);
  }
  else
  {
    v13 = 0xC0000002;
  }
  sub_140036990(CurrentThread, v10);
  return v13;
}
// 140058955: variable 'v12' is possibly undefined
// 1400860F0: using guessed type __int64 qword_1400860F0;

//----- (0000000140058988) ----------------------------------------------------
__int64 __fastcall Get_NtDuplicateObject(__int64 a1, __int64 SourceHandle, __int64 a3, __int64 TargetHandle)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v7; // eax
  char v8; // di
  void (__fastcall *g_NtDuplicateObject)(__int64, __int64, __int64, __int64, int, _DWORD, _DWORD); // rsi
  unsigned int v10; // eax
  unsigned int v11; // esi

  CurrentThread = KeGetCurrentThread();
  v7 = sub_140035ED4();

  if ( CurrentThread && v7 )
    v8 = *(CurrentThread + v7);
  else
    v8 = 0;

  g_NtDuplicateObject = (loc_14005B768)(qword_1400860F8, &qword_1400860F8, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_NtDuplicateObject )
  {
    g_NtDuplicateObject(-1i64, SourceHandle, -1i64, TargetHandle, 7, 0, 0);// NtDuplicateObject
    v11 = v10;
  }
  else
  {
    v11 = 0xC0000002;
  }

  sub_140036990(CurrentThread, v8);

  return v11;
}
// 140058A12: variable 'v10' is possibly undefined
// 1400860F8: using guessed type __int64 qword_1400860F8;

//----- (0000000140058A44) ----------------------------------------------------
__int64 __fastcall Get_NtQueryInformationToken(
        __int64 TokenHandle,
        __int64 a2,
        __int64 TokenInformation,
        __int64 a4,
        __int64 ReturnLength)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v8; // eax
  char v9; // si
  __int64 (__fastcall *g_NtQueryInformationToken)(__int64, __int64, __int64, __int64, __int64); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v8 = sub_140035ED4();

  if ( CurrentThread && v8 )
    v9 = *(CurrentThread + v8);
  else
    v9 = 0;

  g_NtQueryInformationToken = (loc_14005B768)(qword_140086158, &qword_140086158, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_NtQueryInformationToken )
    Status = g_NtQueryInformationToken(TokenHandle, 1i64, TokenInformation, 256i64, ReturnLength);// NtQueryInformationToken
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v9);

  return Status;
}
// 140086158: using guessed type __int64 qword_140086158;

//----- (0000000140058AFC) ----------------------------------------------------
__int64 __fastcall sub_140058AFC(__int64 Handle, __int64 a2, __int64 a3)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v6; // eax
  char v7; // si
  __int64 (__fastcall *v8)(__int64, __int64, __int64); // rdi
  unsigned int ret; // edi

  CurrentThread = KeGetCurrentThread();
  v6 = sub_140035ED4();

  if ( CurrentThread && v6 )
    v7 = *(CurrentThread + v6);
  else
    v7 = 0;

  v8 = (loc_14005B768)(qword_140086108, &qword_140086108, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( v8 )
    ret = v8(Handle, 4i64, a3);
  else
    ret = 0xC0000002;
  sub_140036990(CurrentThread, v7);

  return ret;
}
// 140086108: using guessed type __int64 qword_140086108;

//----- (0000000140058BA8) ----------------------------------------------------
__int64 __fastcall Get_NtSetInformationProcess(
        __int64 a1,
        unsigned int ProcessInformationClass,
        __int64 ProcessInformation,
        unsigned int ProcessInformationLength)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v8; // eax
  char v9; // si
  __int64 (__fastcall *g_NtSetInformationProcess)(__int64, _QWORD, __int64, _QWORD); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v8 = sub_140035ED4();

  if ( CurrentThread && v8 )
    v9 = *(CurrentThread + v8);
  else
    v9 = 0;

  g_NtSetInformationProcess = (loc_14005B768)(qword_140086110, &qword_140086110, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_NtSetInformationProcess )
    Status = g_NtSetInformationProcess(-1i64, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
  else
    Status = 0xC0000002;
  sub_140036990(CurrentThread, v9);

  return Status;
}
// 140086110: using guessed type __int64 qword_140086110;

//----- (0000000140058C54) ----------------------------------------------------
__int64 __fastcall Get_NtAllocateVirtualMemory(
        __int64 ProcessHandle,
        __int64 BaseAddress,
        __int64 ZeroBits,
        __int64 RegionSize,
        int AllocationType,
        int Protect)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v11; // eax
  char v12; // si
  __int64 (__fastcall *g_NtAllocateVirtualMemory)(__int64, __int64, __int64, __int64, int, int); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v11 = sub_140035ED4();

  if ( CurrentThread && v11 )
    v12 = *(CurrentThread + v11);
  else
    v12 = 0;

  g_NtAllocateVirtualMemory = (loc_14005B768)(qword_140086118, &qword_140086118, 0i64);

  sub_140036990(CurrentThread, 0);

  if ( g_NtAllocateVirtualMemory )
    Status = g_NtAllocateVirtualMemory(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);// NtAllocateVirtualMemory
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v12);

  return Status;
}
// 140086118: using guessed type __int64 qword_140086118;

//----- (0000000140058D1C) ----------------------------------------------------
__int64 __fastcall Get_NtFlushVirtualMemory(
        __int64 ProcessHandle,
        __int64 BaseAddress,
        __int64 RegionSize,
        __int64 IoStatus)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v8; // eax
  char v9; // si
  __int64 (__fastcall *g_NtFlushVirtualMemory)(__int64, __int64, __int64, __int64); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v8 = sub_140035ED4();

  if ( CurrentThread && v8 )
    v9 = *(CurrentThread + v8);
  else
    v9 = 0;

  g_NtFlushVirtualMemory = (loc_14005B768)(qword_140086138, &qword_140086138, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_NtFlushVirtualMemory )
    Status = g_NtFlushVirtualMemory(-1i64, BaseAddress, RegionSize, IoStatus);
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v9);

  return Status;
}
// 140086138: using guessed type __int64 qword_140086138;

//----- (0000000140058DC8) ----------------------------------------------------
__int64 __fastcall Get_NtFreeVirtualMemory(
        __int64 ProcessHandle,
        __int64 BaseAddress,
        __int64 RegionSize,
        unsigned int FreeType)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *g_NtFreeVirtualMemory)(__int64, __int64, __int64, _QWORD); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v9 = sub_140035ED4();

  if ( CurrentThread && v9 )
    v10 = *(CurrentThread + v9);
  else
    v10 = 0;

  g_NtFreeVirtualMemory = (loc_14005B768)(qword_140086130, &qword_140086130, 0i64);

  sub_140036990(CurrentThread, 0);

  if ( g_NtFreeVirtualMemory )
    Status = g_NtFreeVirtualMemory(ProcessHandle, BaseAddress, RegionSize, FreeType);// NtFreeVirtualMemory
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v10);

  return Status;
}
// 140086130: using guessed type __int64 qword_140086130;

//----- (0000000140058E80) ----------------------------------------------------
__int64 __fastcall Get_ZwProtectVirtualMemory(
        __int64 ProcessHandle,
        __int64 BaseAddress,
        __int64 NumberOfBytesToProtect,
        unsigned int NewAccessProtection,
        __int64 OldAccessProtection)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v10; // eax
  char v11; // si
  __int64 (__fastcall *ZwProtectVirtualMemory)(__int64, __int64, __int64, _QWORD, __int64); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v10 = sub_140035ED4();

  if ( CurrentThread && v10 )
    v11 = *(CurrentThread + v10);
  else
    v11 = 0;

  ZwProtectVirtualMemory = (loc_14005B768)(qword_140086148, &qword_140086148, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( ZwProtectVirtualMemory )
    Status = ZwProtectVirtualMemory(
               ProcessHandle,
               BaseAddress,
               NumberOfBytesToProtect,
               NewAccessProtection,
               OldAccessProtection);            // ZwProtectVirtualMemory
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v11);

  return Status;
}
// 140086148: using guessed type __int64 qword_140086148;

//----- (0000000140058F40) ----------------------------------------------------
__int64 __fastcall sub_140058F40(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, int a6)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v10; // eax
  char v11; // si
  __int64 (__fastcall *v12)(__int64, _QWORD, __int64, __int64, __int64, int); // rdi
  unsigned int v13; // edi

  CurrentThread = KeGetCurrentThread();
  v10 = sub_140035ED4();
  if ( CurrentThread && v10 )
    v11 = *(CurrentThread + v10);
  else
    v11 = 0;
  v12 = (loc_14005B768)(qword_140086140, &qword_140086140, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( v12 )
    v13 = v12(-1i64, a2, a3, a4, a5, a6);
  else
    v13 = -1073741822;
  sub_140036990(CurrentThread, v11);
  return v13;
}
// 140086140: using guessed type __int64 qword_140086140;

//----- (0000000140058FFC) ----------------------------------------------------
__int64 __fastcall Get_NtQueryInformationProcess(
        __int64 ProcessHandle,
        unsigned int ProcessInformationClass,
        __int64 ProcessInformation,
        unsigned int ProcessInformationLength,
        __int64 ReturnLength)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v10; // eax
  char v11; // si
  __int64 (__fastcall *g_NtQueryInformationProcess)(__int64, _QWORD, __int64, _QWORD, __int64); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v10 = sub_140035ED4();

  if ( CurrentThread && v10 )
    v11 = *(CurrentThread + v10);
  else
    v11 = 0;

  g_NtQueryInformationProcess = (loc_14005B768)(qword_140086150, &qword_140086150, 0i64);

  sub_140036990(CurrentThread, 0);

  if ( g_NtQueryInformationProcess )
    Status = g_NtQueryInformationProcess(
               ProcessHandle,
               ProcessInformationClass,
               ProcessInformation,
               ProcessInformationLength,
               ReturnLength);                   // NtQueryInformationProcess
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v11);

  return Status;
}
// 140086150: using guessed type __int64 qword_140086150;

//----- (00000001400590BC) ----------------------------------------------------
__int64 __fastcall Get_NtQuerySystemInformation(
        unsigned int SystemInformationClass,
        __int64 SystemInformation,
        unsigned int SystemInformationLength,
        __int64 ReturnLength)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *g_NtQuerySystemInformation)(_QWORD, __int64, _QWORD, __int64); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v9 = sub_140035ED4();
  if ( CurrentThread && v9 )
    v10 = *(CurrentThread + v9);
  else
    v10 = 0;
  g_NtQuerySystemInformation = (loc_14005B768)(qword_140086170, &qword_140086170, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( g_NtQuerySystemInformation )
    Status = g_NtQuerySystemInformation(
               SystemInformationClass,
               SystemInformation,
               SystemInformationLength,
               ReturnLength);                   // NtQuerySystemInformation
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v10);

  return Status;
}
// 140086170: using guessed type __int64 qword_140086170;

//----- (0000000140059174) ----------------------------------------------------
__int64 __fastcall Get_ZwQueryVirtualMemory(
        __int64 ProcessHandle,
        __int64 BaseAddress,
        unsigned int MemoryInformationClass,
        __int64 Buffer,
        __int64 Length,
        __int64 ResultLength)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v11; // eax
  char v12; // si
  __int64 (__fastcall *g_ZwQueryVirtualMemory)(__int64, __int64, _QWORD, __int64, __int64, __int64); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v11 = sub_140035ED4();

  if ( CurrentThread && v11 )
    v12 = *(CurrentThread + v11);
  else
    v12 = 0;

  g_ZwQueryVirtualMemory = (loc_14005B768)(qword_140086180, &qword_140086180, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_ZwQueryVirtualMemory )
    Status = g_ZwQueryVirtualMemory(ProcessHandle, BaseAddress, MemoryInformationClass, Buffer, Length, ResultLength);// ZwQueryVirtualMemory
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v12);

  return Status;
}
// 140086180: using guessed type __int64 qword_140086180;

//----- (0000000140059240) ----------------------------------------------------
__int64 __fastcall Get_NtQueryInformationThread(
        __int64 Handle,
        unsigned int ThreadInformationClass,
        __int64 ThreadInformation,
        unsigned int ThreadInformationLength)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *g_NtQueryInformationThread)(__int64, _QWORD, __int64, _QWORD, _QWORD); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();

  v9 = sub_140035ED4();

  if ( CurrentThread && v9 )
    v10 = *(CurrentThread + v9);
  else
    v10 = 0;

  g_NtQueryInformationThread = (loc_14005B768)(qword_140086188, &qword_140086188, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_NtQueryInformationThread )
    Status = g_NtQueryInformationThread(
               Handle,
               ThreadInformationClass,
               ThreadInformation,
               ThreadInformationLength,
               0i64);                           // NtQueryInformationThread
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v10);

  return Status;
}
// 140086188: using guessed type __int64 qword_140086188;

//----- (00000001400592FC) ----------------------------------------------------
__int64 __fastcall sub_1400592FC(__int64 Handle, unsigned int a2)
{
  __int64 v4; // rax
  struct _KTHREAD *CurrentThread; // rbx
  __int64 (__fastcall *v6)(__int64, _QWORD); // rdi
  unsigned int v7; // eax
  char v8; // si
  unsigned int v9; // edi
  int v11[8]; // [rsp+20h] [rbp-20h] BYREF

  v11[0] = 0x26D090BB;
  v11[1] = 0x1DC2621;
  v11[2] = 0x265F75F1;
  v11[3] = 0xB6B111EE;
  v11[4] = 0x8778572B;

  v4 = (loc_14003CB4C)(v11);
  CurrentThread = KeGetCurrentThread();
  v6 = v4;

  v7 = sub_140035ED4();

  if ( CurrentThread && v7 )
    v8 = *(CurrentThread + v7);
  else
    v8 = 0;

  sub_140036990(CurrentThread, 0);

  if ( v6 )
    v9 = v6(Handle, a2);
  else
    v9 = 0xC0000002;

  sub_140036990(CurrentThread, v8);

  return v9;
}

//----- (00000001400593B4) ----------------------------------------------------
__int64 __fastcall sub_1400593B4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64, __int64); // rdi
  unsigned int v12; // edi

  CurrentThread = KeGetCurrentThread();
  v9 = sub_140035ED4();
  if ( CurrentThread && v9 )
    v10 = *(CurrentThread + v9);
  else
    v10 = 0;
  v11 = (loc_14005B768)(qword_140086160, &qword_140086160, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, 4i64, a5);
  else
    v12 = -1073741822;
  sub_140036990(CurrentThread, v10);
  return v12;
}
// 140086160: using guessed type __int64 qword_140086160;

//----- (000000014005946C) ----------------------------------------------------
__int64 __fastcall sub_14005946C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v10; // eax
  char v11; // si
  __int64 (__fastcall *v12)(__int64, __int64, __int64, __int64, __int64); // rdi
  unsigned int v13; // edi

  CurrentThread = KeGetCurrentThread();
  v10 = sub_140035ED4();
  if ( CurrentThread && v10 )
    v11 = *(CurrentThread + v10);
  else
    v11 = 0;
  v12 = (loc_14005B768)(qword_140086168, &qword_140086168, 0i64);
  sub_140036990(CurrentThread, 0);
  if ( v12 )
    v13 = v12(a1, a2, a3, a4, a5);
  else
    v13 = 0xC0000002;
  sub_140036990(CurrentThread, v11);
  return v13;
}
// 140086168: using guessed type __int64 qword_140086168;

//----- (000000014005952C) ----------------------------------------------------
__int64 __fastcall Get_ZwQuerySection(__int64 SectionHandle, __int64 a2, __int64 InformationBuffer)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v6; // eax
  char v7; // si
  __int64 (__fastcall *g_ZwQuerySection)(__int64, _QWORD, __int64, __int64, _QWORD); // rdi
  unsigned int Status; // edi

  CurrentThread = KeGetCurrentThread();
  v6 = sub_140035ED4();
  if ( CurrentThread && v6 )
    v7 = *(CurrentThread + v6);
  else
    v7 = 0;
  g_ZwQuerySection = (loc_14005B768)(qword_140086178, &qword_140086178, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( g_ZwQuerySection )
    Status = g_ZwQuerySection(SectionHandle, 0i64, InformationBuffer, 0x18i64, 0i64);// ZwQuerySection
  else
    Status = 0xC0000002;
  sub_140036990(CurrentThread, v7);

  return Status;
}
// 140086178: using guessed type __int64 qword_140086178;

//----- (00000001400595DC) ----------------------------------------------------
__int64 __fastcall Get_ZwMapViewOfSection(
        __int64 SectionHandle,
        __int64 a2,
        __int64 BaseAddress,
        __int64 a4,
        int a5,
        int a6,
        __int64 ViewSize)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v10; // eax
  char v11; // di
  __int64 (__fastcall *g_ZwMapViewOfSection)(__int64, __int64, __int64, _QWORD, _QWORD, _QWORD, __int64, int, _DWORD, int); // rsi
  unsigned int Status; // esi

  CurrentThread = KeGetCurrentThread();

  v10 = sub_140035ED4();

  if ( CurrentThread && v10 )
    v11 = *(CurrentThread + v10);
  else
    v11 = 0;
  g_ZwMapViewOfSection = (loc_14005B768)(qword_1400861A8, &qword_1400861A8, 0i64);

  sub_140036990(CurrentThread, 0);

  if ( g_ZwMapViewOfSection )
    Status = g_ZwMapViewOfSection(SectionHandle, -1i64, BaseAddress, 0i64, 0i64, 0i64, ViewSize, 1, 0, 2);// ZwMapViewOfSection
  else
    Status = 0xC0000002;

  sub_140036990(CurrentThread, v11);

  return Status;
}
// 1400861A8: using guessed type __int64 qword_1400861A8;

//----- (00000001400596B4) ----------------------------------------------------
__int64 __fastcall sub_1400596B4(__int64 ProcessHandle, __int64 a2)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v4; // eax
  char v5; // si
  __int64 (__fastcall *v6)(__int64, __int64); // rdi
  unsigned int v7; // edi

  CurrentThread = KeGetCurrentThread();
  v4 = sub_140035ED4();

  if ( CurrentThread && v4 )
    v5 = *(CurrentThread + v4);
  else
    v5 = 0;

  v6 = (loc_14005B768)(qword_1400861B0, &qword_1400861B0, 0i64);
  sub_140036990(CurrentThread, 0);

  if ( v6 )
    v7 = v6(-1i64, a2);
  else
    v7 = 0xC0000002;

  sub_140036990(CurrentThread, v5);

  return v7;
}
// 1400861B0: using guessed type __int64 qword_1400861B0;

//----- (000000014005974C) ----------------------------------------------------
__int64 __fastcall sub_14005974C(
        __int64 Handle,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 IoStatusBlock,
        int a6,
        __int64 a7,
        int a8,
        __int64 a9,
        int a10)
{
  struct _KTHREAD *CurrentThread; // rbx
  unsigned int v12; // eax
  char v13; // di
  __int64 (__fastcall *v14)(__int64, _QWORD, _QWORD, _QWORD, __int64, int, __int64, int, __int64, int); // rsi
  unsigned int ret; // esi

  CurrentThread = KeGetCurrentThread();
  v12 = sub_140035ED4();

  if ( CurrentThread && v12 )
    v13 = *(CurrentThread + v12);
  else
    v13 = 0;

  v14 = (loc_14005B768)(qword_1400861C0, &qword_1400861C0, 0i64);

  sub_140036990(CurrentThread, 0);

  if ( v14 )
    ret = v14(Handle, 0i64, 0i64, 0i64, IoStatusBlock, a6, a7, a8, a9, a10);
  else
    ret = 0xC0000002;

  sub_140036990(CurrentThread, v13);
  return ret;
}
// 1400861C0: using guessed type __int64 qword_1400861C0;

//----- (0000000140059830) ----------------------------------------------------
void sub_140059830()
{
  unsigned int v0; // edx
  __int64 i; // rbx
  __int64 v2; // rcx

  if ( KeGetCurrentIrql() <= 1u )
  {
    ExAcquireFastMutex(&stru_1400831A0);
    if ( byte_140085FE9 )
    {
      v0 = dword_1400861D0;
      for ( i = 0i64; i < v0; i = (i + 1) )
      {
        v2 = *(qword_1400861D8 + 24 * i + 16);
        if ( v2 )
        {
          Get_ExFreePool(v2);
          v0 = dword_1400861D0;
        }
      }
      Get_ExFreePool(qword_1400861D8);
      qword_1400861D8 = 0i64;
      byte_140085FE9 = 0;
    }
    byte_140085FEA = 1;
    ExReleaseFastMutex(&stru_1400831A0);
  }
}
// 140085FE9: using guessed type char byte_140085FE9;
// 140085FEA: using guessed type char byte_140085FEA;
// 1400861D0: using guessed type int dword_1400861D0;
// 1400861D8: using guessed type __int64 qword_1400861D8;

//----- (00000001400598BC) ----------------------------------------------------
__int64 __fastcall EAC_Get_File_Size(__int64 BaseAddress)
{
  DWORD SectionAlignment; // ebx
  _IMAGE_NT_HEADERS *NtHeader; // [rsp+30h] [rbp+8h] BYREF

  SectionAlignment = 0x1000;
  if ( BaseAddress
    && GetModuleInfo(BaseAddress, 0x1000ui64, 0i64, &NtHeader)
    && NtHeader->OptionalHeader.SectionAlignment )
  {
    SectionAlignment = NtHeader->OptionalHeader.SectionAlignment;
  }

  if ( SectionAlignment > 0x1000 )
    return 0x1000;

  return SectionAlignment;
}

//----- (0000000140059904) ----------------------------------------------------
struct_Memory *__fastcall sub_140059904(int a1, _OWORD *a2)
{
  _UNICODE_STRING v2; // xmm0
  _UNICODE_STRING v3; // xmm1
  _UNICODE_STRING v7; // xmm0
  _UNICODE_STRING v8; // xmm1
  _UNICODE_STRING v9; // xmm0
  _UNICODE_STRING v10; // xmm1
  _UNICODE_STRING v11; // xmm0
  __int64 v12; // rax
  __int128 v13; // xmm0
  __int128 v14; // xmm1
  __int128 v15; // xmm0
  __int128 v16; // xmm1
  __int128 v17; // xmm0
  __int128 v18; // xmm1
  __int64 idx; // rax
  _OWORD *BaseAddress; // rax
  __int64 Address; // rsi
  struct_Memory *Memory; // rdi MAPDST
  unsigned int Module_Size; // r15d
  DWORD ScaleSize; // r14d
  __int64 Allocate; // rax
  int Value; // eax
  __int64 v27; // r10
  unsigned __int16 BytesInMultiByteString[4]; // [rsp+28h] [rbp-E0h] BYREF
  _UNICODE_STRING *v30; // [rsp+30h] [rbp-D8h]
  _UNICODE_STRING unicode_string[8]; // [rsp+38h] [rbp-D0h] BYREF
  __int128 v32; // [rsp+B8h] [rbp-50h]
  __int128 v33; // [rsp+C8h] [rbp-40h]
  __int128 v34; // [rsp+D8h] [rbp-30h]
  __int128 v35; // [rsp+E8h] [rbp-20h]
  __int128 v36; // [rsp+F8h] [rbp-10h]
  __int128 v37; // [rsp+108h] [rbp+0h]
  __int128 v38; // [rsp+118h] [rbp+10h]
  __int128 v39; // [rsp+128h] [rbp+20h]
  __int64 v40; // [rsp+138h] [rbp+30h]
  int v41; // [rsp+140h] [rbp+38h]
  __int16 v42; // [rsp+144h] [rbp+3Ch]
  char v43; // [rsp+146h] [rbp+3Eh]
  char v44; // [rsp+147h] [rbp+3Fh]
  DWORD SizeOfImage; // [rsp+180h] [rbp+78h] BYREF

  v2 = *(a2 + 0x28);
  v44 = 0;
  v3 = *(a2 + 0x38);
  Memory = 0i64;
  unicode_string[1] = v2;
  v7 = *(a2 + 0x48);
  unicode_string[2] = v3;
  v8 = *(a2 + 0x58);
  unicode_string[3] = v7;
  v9 = *(a2 + 0x68);
  unicode_string[4] = v8;
  v10 = *(a2 + 0x78);
  unicode_string[5] = v9;
  v11 = *(a2 + 0x88);
  unicode_string[6] = v10;
  unicode_string[7] = v11;
  v32 = *(a2 + 0x98);
  v12 = *(a2 + 0x23);
  v13 = *(a2 + 0xB8);
  v33 = *(a2 + 0xA8);
  v14 = *(a2 + 0xC8);
  v34 = v13;
  v15 = *(a2 + 0xD8);
  v35 = v14;
  v16 = *(a2 + 0xE8);
  v36 = v15;
  v17 = *(a2 + 0xF8);
  v37 = v16;
  v18 = *(a2 + 0x108);
  v38 = v17;
  v39 = v18;
  v40 = v12;
  v41 = *(a2 + 0x48);
  v42 = *(a2 + 0x92);
  v43 = *(a2 + 0x126);
  v30 = &unicode_string[1];
  idx = -1i64;

  do
    ++idx;
  while ( *(&unicode_string[1].Length + idx) );

  BytesInMultiByteString[0] = idx;
  BytesInMultiByteString[1] = idx + 1;
  if ( Get_RtlMultiByteToUnicodeN(&unicode_string[0].Length, BytesInMultiByteString) >= 0 )
  {
    BaseAddress = sub_140001AA0(unicode_string, *(a2 + 2), &SizeOfImage, 1);
    Address = BaseAddress;
    if ( BaseAddress )
    {
      Memory = 0i64;
      Module_Size = EAC_Get_Module_Size(BaseAddress);
      ScaleSize = SizeOfImage / Module_Size;
      if ( SizeOfImage / Module_Size )
      {
        Memory = EAC_Allocate_Memory(0x18ui64);
        if ( Memory )
        {
          Allocate = EAC_Allocate_Memory(4i64 * ScaleSize);
          Memory->Allocate = Allocate;
          if ( Allocate )
          {
            Memory->dword4 = a1;
            Memory->EncodeBuffer = EAC_Generate_Seed(0, -1);
            Memory->ModuleSize = Module_Size;
            Memory->ScaleSize = ScaleSize;
            do
            {
              Value = EAC_CRC32((Address + Module_Size * Memory), Module_Size, 0);
              LODWORD(Memory) = Memory + 1;
              *(v27 + Memory->Allocate) = Value;
            }
            while ( Memory < ScaleSize );
          }
          else
          {
            Get_ExFreePool(Memory);
            Memory = 0i64;
          }
        }
      }
      EAC_ExFreePool(Address);
    }
    EAC_Free_UnicodeString(unicode_string);
  }
  return Memory;
}
// 140059ADC: variable 'v27' is possibly undefined

//----- (0000000140059B30) ----------------------------------------------------
// from @Swiftik
char __fastcall EAC_CheckCRC(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, _QWORD *a5, _DWORD *a6)
{
  char ret; // bl
  __int64 v8; // r13
  unsigned __int64 v9; // rdx
  __int64 v10; // r8
  __int64 v11; // r14
  unsigned __int64 v12; // rsi
  void *Memory; // rax
  __int64 v14; // r15
  unsigned __int64 v15; // r11
  _BYTE *v16; // rsi
  unsigned __int64 v17; // r12
  unsigned int v18; // ebx
  unsigned __int64 v19; // rdi
  unsigned __int64 v21; // [rsp+60h] [rbp+8h]
  __int64 v22; // [rsp+68h] [rbp+10h]

  ret = 0;
  v8 = a2 & -*(a1 + 8);
  v9 = a3 % *(a1 + 8);
  v10 = a3 - v9;
  v11 = v10 + *(a1 + 8);
  if ( !v9 )
    v11 = v10;
  v12 = v8 & 0xFFFFFFFFFFFFF000ui64;
  Memory = EAC_Allocate_Memory((v11 + 4095) & 0xFFFFFFFFFFFFF000ui64);
  v22 = Memory;
  v14 = Memory;
  if ( Memory )
  {
    if ( EAC_Read_VirtualMemory(v12, (v11 + 4095) & 0xFFFFFFFFFFFFF000ui64, Memory) == ((v11 + 4095) & 0xFFFFFFFFFFFFF000ui64) )
    {
      v15 = v8 + v14 - v12;
      v16 = v15;
      v17 = v11 + v15;
      if ( v15 < v11 + v15 )
      {
        v18 = *(a1 + 8);
        do
        {
          v19 = &v16[-v15 - a4 + v8];
          v21 = v19 / v18;
          if ( v21 < *(a1 + 12) && *(*(a1 + 16) + 4 * v21) != EAC_CRC32(v16, v18, 0) )
          {
            *(*a5 + 8i64 * (*a6)++) = v19 + a4;
            v18 = *(a1 + 8);
          }
          v16 += v18;
        }
        while ( v16 < v17 );
        v14 = v22;
      }
      ret = 1;
    }
    Get_ExFreePool(v14);
  }
  return ret;
}
// 140059BEB: variable 'v15' is possibly undefined

//----- (0000000140059C74) ----------------------------------------------------
// from @Swiftik
__int64 __fastcall EAC_CheckDriverIntegrity(
        unsigned __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 *Buffer_1,
        _DWORD *a5)
{
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // r15
  unsigned int ret; // esi
  unsigned __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 Memory; // rax
  void *Buf; // rax
  int v14; // esi
  __int64 Buffer; // rbx
  unsigned __int64 v16; // rdi
  _DWORD *v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rdi
  _OWORD *v20; // rax
  __int64 v21; // rdi
  __int64 v22; // r15
  __int64 v23; // r14
  _OWORD *v24; // rax
  int v25; // esi
  __int64 v26; // r8
  char v27; // al
  __int64 v28; // rcx

  v7 = a2;
  v8 = a1;
  ret = 0xC0000229;
  if ( !KeGetCurrentIrql() )
  {
    if ( a1 )
    {
      if ( a2 )
      {
        if ( a3 )
        {
          v10 = *(a3 + 0x10);
          if ( v10 )
          {
            if ( *(a3 + 0x18)
              && v10 >= MmSystemRangeStart
              && Buffer_1
              && a5
              && sub_140041F0C(a3, v8)
              && sub_140041F0C(v11, v8 + v7) )
            {
              *Buffer_1 = 0i64;
              *a5 = 0;

              Memory = EAC_Allocate_Memory(8 * (v7 >> 12) + 8);
              *Buffer_1 = Memory;
              if ( !Memory )
                return ret;

              if ( KeGetCurrentIrql() <= 1u )
              {
                ExAcquireFastMutex(&stru_1400831A0);
                if ( !byte_140085FE9 && !byte_140085FEA )
                {
                  Buf = EAC_Allocate_Memory(0x6000ui64);
                  qword_1400861D8 = Buf;
                  if ( Buf )
                  {
                    byte_140085FE9 = 1;
                    memset(Buf, 0, 0x6000ui64);
                  }
                }
                ExReleaseFastMutex(&stru_1400831A0);
                if ( byte_140085FE9 )
                {
                  v14 = EAC_CRC32((a3 + 0x28), 0x100u, 0);
                  Buffer = 0i64;
                  ExAcquireFastMutex(&stru_1400831A0);
                  if ( byte_140085FE9 )
                  {
                    v16 = 0i64;
                    if ( dword_1400861D0 )
                    {
                      v17 = (qword_1400861D8 + 4);
                      while ( *v17 != v14 )
                      {
                        ++v16;
                        v17 += 6;
                        if ( v16 >= dword_1400861D0 )
                          goto LABEL_32;
                      }

                      Buffer = EAC_Allocate_Memory(0x18ui64);
                      if ( Buffer )
                      {
                        v18 = qword_1400861D8;
                        v19 = 3 * v16;
                        *Buffer = *(qword_1400861D8 + 8 * v19);
                        *(Buffer + 0x10) = *(v18 + 8 * v19 + 0x10);
                        v20 = EAC_Allocate_Memory(4i64 * *(v18 + 8 * v19 + 0xC));
                        *(Buffer + 0x10) = v20;
                        if ( v20 )
                        {
                          EAC_memcpy(v20, *(qword_1400861D8 + 8 * v19 + 0x10), 4i64 * *(qword_1400861D8 + 8 * v19 + 12));
                          if ( *(Buffer + 12) )
                          {
                            v21 = 0i64;
                            do
                            {
                              *(*(Buffer + 16) + 4 * v21) ^= *Buffer;
                              v21 = (v21 + 1);
                            }
                            while ( v21 < *(Buffer + 12) );
                          }
                        }
                        else
                        {
                          Get_ExFreePool(Buffer);
                          Buffer = 0i64;
                        }
                      }
                    }
                  }
LABEL_32:
                  ExReleaseFastMutex(&stru_1400831A0);
                  if ( Buffer )
                  {
LABEL_43:
                    v27 = EAC_CheckCRC(Buffer, v8, v7, *(a3 + 0x10), Buffer_1, a5);
                    v28 = *(Buffer + 16);
                    ret = v27 == 0 ? 0xC0000005 : 0;
                    if ( v28 )
                      Get_ExFreePool(v28);

                    Get_ExFreePool(Buffer);
                    if ( (ret & 0x80000000) == 0 && *a5 )
                      return ret;
                    goto LABEL_47;
                  }
                  Buffer = sub_140059904(v14, a3);
                  if ( Buffer )
                  {
                    ExAcquireFastMutex(&stru_1400831A0);
                    if ( byte_140085FE9 && dword_1400861D0 < 0x400 )
                    {
                      v22 = qword_1400861D8;
                      v23 = 3i64 * dword_1400861D0;
                      *(qword_1400861D8 + 8 * v23) = *Buffer;
                      *(v22 + 8 * v23 + 16) = *(Buffer + 16);
                      v24 = EAC_Allocate_Memory(4i64 * *(Buffer + 12));
                      v25 = dword_1400861D0;
                      *(qword_1400861D8 + 24i64 * dword_1400861D0 + 16) = v24;
                      if ( v24 )
                      {
                        EAC_memcpy(v24, *(Buffer + 0x10), 4i64 * *(Buffer + 0xC));
                        if ( *(v22 + 8 * v23 + 12) )
                        {
                          v26 = 0i64;
                          do
                          {
                            *(*(v22 + 8 * v23 + 16) + 4 * v26) ^= *(v22 + 8 * v23);
                            v26 = (v26 + 1);
                          }
                          while ( v26 < *(v22 + 8 * v23 + 12) );
                        }
                        dword_1400861D0 = v25 + 1;
                      }
                      v8 = a1;
                      v7 = a2;
                    }
                    ExReleaseFastMutex(&stru_1400831A0);
                    goto LABEL_43;
                  }
                  ret = 0xC0000123;
                }
              }
LABEL_47:
              Get_ExFreePool(*Buffer_1);
              return ret;
            }
          }
        }
      }
    }
  }
  return 0xC000000Di64;
}
// 140059E94: conditional instruction was optimized away because eax.4!=0
// 140059F71: conditional instruction was optimized away because eax.4!=0
// 140059D23: variable 'v11' is possibly undefined
// 140085FE9: using guessed type char byte_140085FE9;
// 140085FEA: using guessed type char byte_140085FEA;
// 1400861D0: using guessed type int dword_1400861D0;
// 1400861D8: using guessed type __int64 qword_1400861D8;

//----- (000000014005A1D8) ----------------------------------------------------
void __fastcall sub_14005A1D8(_QWORD *a1)
{
  _QWORD *v1; // r8
  unsigned __int64 v2; // rdi
  unsigned __int64 v4; // r15
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 Memory; // rax
  unsigned __int64 v9; // rbp
  _QWORD *v10; // rsi
  _WORD *v11; // rbx
  _OWORD *v12; // rbx
  _OWORD *v13; // rbx
  _QWORD *v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rbx
  __int64 v17; // r9
  unsigned __int64 v18; // r10
  int v19; // r8d
  _BYTE *v20; // rdx
  unsigned int v21; // r8d
  char v22; // cl
  unsigned __int64 v23; // rcx

  v1 = *a1;
  v2 = 0i64;
  v4 = 0i64;
  if ( *a1 != a1 )
  {
    do
    {
      v5 = *(v1 + 16);
      v6 = *(v1 + 8);
      v1 = *v1;
      v7 = v4 + v6;
      v4 = v7 + v5 + 12;
    }
    while ( v1 != a1 );
    if ( v4 )
    {
      Memory = EAC_Allocate_Memory(v7 + v5 + 12);
      v9 = Memory;
      if ( Memory )
      {
        v10 = *a1;
        v11 = Memory;
        while ( v10 != a1 )
        {
          *v11 = *(v10 + 8);
          v12 = v11 + 1;
          EAC_memcpy(v12, v10[3], *(v10 + 8));
          v13 = (v12 + *(v10 + 8));
          *v13 = *(v10 + 16);
          v13 = (v13 + 2);
          EAC_memcpy(v13, v10[5], *(v10 + 16));
          v14 = (v13 + *(v10 + 16));
          *v14 = *v10[6];
          v11 = v14 + 1;
          v10 = *v10;
        }
        v15 = EAC_Allocate_Memory(0x8208ui64);
        v16 = v15;
        if ( v15 )
        {
          EAC_memset((v15 + 8), 0, 0x8200ui64);
          v17 = v16 + 8;
          *v16 = 0i64;
          *(v16 + 8) = -955980226;
          v18 = 24i64;
          *(v16 + 12) = -862229642;
          *(v16 + 16) = 105472610;
          *(v16 + 24) = -865491936;
          *(v16 + 28) = 61759276;
          v19 = (-732215657 * (v9 >> 2)) ^ 0xA7C72F4E;
          *(v16 + 20) = (-732215657 * (v9 >> 2)) ^ 0x1C36F961;
          if ( v4 )
          {
            do
            {
              if ( v2 >= 0x8000 )
                break;
              v20 = (v2 + v9);
              ++v18;
              v21 = __ROL4__(
                      ((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13) ^ (32
                                                                       * (((v19 ^ (v19 << 13)) >> 17) ^ v19 ^ (v19 << 13))),
                      1);
              v22 = 8 * (v2++ & 3);
              v20[v17 - v9 + 24] = *v20 ^ (v21 >> v22);
              v19 = *v20 ^ v21;
            }
            while ( v2 < v4 );
          }
          v23 = (v18 + 255) & 0xFFFFFFFFFFFFFF00ui64;
          while ( v18 < v23 )
          {
            v19 *= -732215657;
            *(v18 + v17) = BYTE1(v19);
            ++v18;
          }
          *(v16 + 24) ^= v19;
          *(v16 + 28) ^= v2;
          *v16 = v18;
          (loc_140016B54)(624680998i64, v16 + 8, v18);
          Get_ExFreePool(v16);
        }
        memset(v9, 0, v4);
        Get_ExFreePool(v9);
      }
    }
  }
}

//----- (000000014005A918) ----------------------------------------------------
__int64 sub_14005A918()
{
  char v0; // si
  __int64 BaseAddress; // rbx
  ULONG64 v2; // r14
  __int64 CurrentProcess; // rax
  int ProcessWow64Process; // r12d
  __int64 v5; // rax
  unsigned __int64 User_Module; // rdi
  _BYTE *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  char v10; // dl
  unsigned __int64 v11; // r8
  char *v12; // rdx
  int v14[3]; // [rsp+20h] [rbp-68h] BYREF
  char v15[12]; // [rsp+2Ch] [rbp-5Ch] BYREF
  int v16[6]; // [rsp+38h] [rbp-50h] BYREF
  __int16 v17; // [rsp+50h] [rbp-38h]
  char v18[30]; // [rsp+52h] [rbp-36h] BYREF

  v0 = 0;
  BaseAddress = 0i64;
  v2 = 0i64;
  CurrentProcess = Get_PsGetCurrentProcess();
  ProcessWow64Process = Get_PsGetProcessWow64Process(CurrentProcess);
  if ( !ProcessWow64Process )
    goto LABEL_6;
  v16[0] = 944905929;
  v16[1] = 1472902480;
  v16[2] = 1562343623;
  v16[3] = -851197167;
  v16[4] = 1900454540;
  v16[5] = -12893874;
  v17 = 7330;
  v5 = sub_14005AAC8(v16, v18);
  User_Module = EAC_Get_User_Module(v5);
  v0 = 1;
  if ( !User_Module )
    goto LABEL_6;
  v14[0] = 816120414;
  v14[1] = 652368697;
  v14[2] = -1600108862;
  v7 = sub_14005AB50(v14, v15);
  v2 = sub_14001DA84(User_Module, v7);
  v0 = 3;
  if ( v2 && (BaseAddress = EAC_Allocate_ProcessVirtualMemory(v8, 0x1000i64, v9, 64)) != 0 )
    v10 = 1;
  else
LABEL_6:
    v10 = 0;
  if ( (v0 & 2) != 0 )
  {
    v0 &= ~2u;
    memset(v15, 0, sizeof(v15));
  }
  if ( (v0 & 1) != 0 )
    memset(v18, 0, 0x1Aui64);
  if ( v10 )
  {
    sub_14001D338(BaseAddress, 0x1000i64);
    v11 = 46i64;
    if ( ProcessWow64Process == 64 )
      v11 = 48i64;
    v12 = &unk_140076C10;
    if ( ProcessWow64Process == 64 )
      v12 = &unk_140076BE0;
    EAC_memcpy(BaseAddress, v12, v11);
    if ( ProcessWow64Process == 64 )
      *(BaseAddress + 38) = v2;
    else
      *(BaseAddress + 40) = v2;
  }
  return BaseAddress;
}
// 14005AA07: variable 'v8' is possibly undefined
// 14005AA07: variable 'v9' is possibly undefined

//----- (000000014005AAC8) ----------------------------------------------------
__int64 __fastcall sub_14005AAC8(__int64 a1, __int64 a2)
{
  unsigned int v3; // r9d
  unsigned __int64 v4; // r8
  unsigned __int64 i; // r10
  char v6; // cl
  __int64 result; // rax

  *a2 = 0i64;
  *(a2 + 16) = 0i64;
  *(a2 + 24) = 0;
  v3 = 943136418;
  v4 = 24i64;
  for ( i = 0i64; i < 0x18; i += 4i64 )
  {
    *(a2 + i) = *(a1 + i) ^ v3;
    v3 = -12820164 - 1140671485 * v3;
  }
  do
  {
    v6 = v3;
    v3 >>= 8;
    result = a2;
    *(a2 + v4) = *(a1 + v4) ^ v6;
    ++v4;
  }
  while ( v4 < 0x1A );
  return result;
}

//----- (000000014005AB50) ----------------------------------------------------
__int64 __fastcall sub_14005AB50(__int64 a1, __int64 a2)
{
  unsigned int v2; // r8d
  unsigned __int64 v3; // r9
  __int64 result; // rax

  v2 = -2133410394;
  *a2 = 0i64;
  v3 = 0i64;
  *(a2 + 8) = 0;
  do
  {
    v2 = ~(((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13) ^ (32 * (((v2 ^ (v2 << 13)) >> 17) ^ v2 ^ (v2 << 13))));
    result = a2;
    *(a2 + v3) = *(a1 + v3) ^ v2;
    v3 += 4i64;
  }
  while ( v3 < 0xC );
  return result;
}

//----- (000000014005AC60) ----------------------------------------------------
__int64 __fastcall EAC_APC_Routine(
        __int64 NormalContext,
        __int64 (__fastcall *SystemArgument1)(__int64),
        __int64 SystemArgument2)
{
  __int64 result; // rax

  if ( SystemArgument1 )
  {
    if ( SystemArgument2 )
      return SystemArgument1(SystemArgument2);
  }
  return result;
}

//----- (000000014005ACEC) ----------------------------------------------------
char __fastcall Detect_QueueApc(HANDLE ThreadId, __int64 Argument1, __int64 Argument2, int ApcMode, char Flag)
{
  char ret; // bl
  __int64 NormalRoutine; // rsi
  bool Mode; // r12
  struct_EAC_Apc_Data *EAC_Apc_Data; // rax MAPDST
  __m128 *Allocate; // rax
  __int64 Apc; // rdi
  PVOID Thread; // rbx
  void (__fastcall *KeInitializeApc)(__int64, PVOID, __int64, __int64 *, __int64 *, __int64, bool, __int64); // rax
  __int64 Environment; // r8
  __int64 (__fastcall *KeInsertQueueApc)(__int64, __int64, __int64, _QWORD); // rax
  void (__fastcall *v22)(PVOID, _QWORD); // rax
  void (__fastcall *v23)(__int64); // rax
  __int64 v24; // rcx
  __int64 NormalContext; // [rsp+38h] [rbp-30h]
  PVOID Object; // [rsp+70h] [rbp+8h] MAPDST BYREF

  ret = 0;
  NormalRoutine = 0i64;
  Mode = ApcMode == 1;
  if ( !ThreadId || !Argument1 )
    return 0;

  if ( ApcMode == 1 && PsGetCurrentThreadId() != ThreadId )
  {
    EAC_Apc_Data = EAC_Allocate_Memory((ApcMode + 0x1F));
    if ( EAC_Apc_Data )
    {
      EAC_Apc_Data->ThreadId = ThreadId;
      EAC_Apc_Data->Argument1 = Argument1;
      EAC_Apc_Data->Argument2 = Argument2;
      EAC_Apc_Data->Flag = Flag;

      if ( Detect_QueueApc(ThreadId, &dword_14005ACA4, EAC_Apc_Data, 0, 0) )
        return ApcMode;

      Get_ExFreePool(EAC_Apc_Data);
    }
    return 0;
  }

  if ( KeGetCurrentIrql() > 1u || !byte_140085FEB )
    return 0;

  ExAcquireFastMutex(&stru_140086288);
  if ( !byte_1400861D4 && Get_PsLookupThreadByThreadId(ThreadId, &Object) >= 0 )
  {
    Allocate = EAC_Allocate_Memory(0x58ui64);
    Apc = Allocate;
    if ( Allocate )
    {
      EAC_memset(Allocate, 0, 0x58ui64);
      if ( ApcMode )
      {
        if ( ApcMode == 1 )
        {
          NormalRoutine = 1i64;
        }
        else if ( ApcMode == 3 )
        {
          NormalRoutine = EAC_APC_Routine;
        }
      }

      Thread = Object;
      KeInitializeApc = (loc_14005B768)(qword_140085FA8, &qword_140085FA8, 0i64);
      if ( KeInitializeApc )
        KeInitializeApc(
          Apc,
          Thread,
          Environment,
          qword_14005ABA8,
          qword_14005AC78,
          NormalRoutine,
          Mode,
          Environment & NormalContext);         // KeInitializeApc

      KeInsertQueueApc = (loc_14005B768)(qword_140085FB0, &qword_140085FB0, 0i64);
      if ( KeInsertQueueApc )
      {
        ret = KeInsertQueueApc(Apc, Argument1, Argument2, 0i64);// KeInsertQueueApc
        if ( ret )
        {
          _InterlockedIncrement(&dword_1400862C0);
          if ( Flag )
          {
            if ( ApcMode == 1 )
            {
              if ( (loc_14005B768)(qword_140085FB8, &qword_140085FB8, 0i64) )
              {
                v23 = (loc_14005B768)(qword_140085FB8, &qword_140085FB8);
                if ( v23 )
                {
                  LOBYTE(v24) = 1;
                  v23(v24);
                }
              }
              else
              {
                MEMORY[0x2A] |= 2u;
              }
            }
            else if ( (loc_14005B768)(qword_140085FC0, &qword_140085FC0, 0i64) )
            {
              v22 = (loc_14005B768)(qword_140085FC0, &qword_140085FC0);
              if ( v22 )
                v22(Object, 0i64);
            }
            else
            {
              MEMORY[0x29] = 1;
            }
          }
          goto LABEL_36;
        }
      }
      else
      {
        ret = 0;
      }
      Get_ExFreePool(Apc);
    }
LABEL_36:
    ObfDereferenceObject(Object);
  }
  ExReleaseFastMutex(&stru_140086288);
  return ret;
}
/* Orphan comments:


*/
// 14005AE6C: variable 'Environment' is possibly undefined
// 14005AE44: variable 'NormalContext' is possibly undefined
// 14005AF3C: variable 'v24' is possibly undefined
// 14005ABA8: using guessed type __int64 qword_14005ABA8[23];
// 14005AC78: using guessed type __int64 qword_14005AC78[5];
// 14005ACA4: using guessed type int dword_14005ACA4;
// 140085FA8: using guessed type __int64 qword_140085FA8;
// 140085FB0: using guessed type __int64 qword_140085FB0;
// 140085FB8: using guessed type __int64 qword_140085FB8;
// 140085FC0: using guessed type __int64 qword_140085FC0;
// 140085FEB: using guessed type char byte_140085FEB;
// 1400861D4: using guessed type char byte_1400861D4;
// 1400862C0: using guessed type int dword_1400862C0;

//----- (000000014005AF74) ----------------------------------------------------
void sub_14005AF74()
{
  stru_140086288.Owner = 0i64;
  stru_140086288.Contention = 0;
  stru_140086288.Count = 1;
  KeInitializeEvent(&stru_140086288.Event, SynchronizationEvent, 0);
  byte_140085FEB = 1;
}
// 140085FEB: using guessed type char byte_140085FEB;

//----- (000000014005AFB4) ----------------------------------------------------
char sub_14005AFB4()
{
  char result; // al
  union _LARGE_INTEGER Interval; // [rsp+30h] [rbp+8h] BYREF

  byte_1400861D4 = 1;
  while ( 1 )
  {
    result = byte_140085FEB;
    if ( !byte_140085FEB )
      break;
    ExAcquireFastMutex(&stru_140086288);
    if ( !dword_1400862C0 )
      byte_140085FEB = dword_1400862C0;
    ExReleaseFastMutex(&stru_140086288);
    Interval.QuadPart = -1000000i64;
    KeDelayExecutionThread(0, 0, &Interval);
  }
  return result;
}
// 140085FEB: using guessed type char byte_140085FEB;
// 1400861D4: using guessed type char byte_1400861D4;
// 1400862C0: using guessed type int dword_1400862C0;

//----- (000000014005B014) ----------------------------------------------------
void EAC_sprintf_Allocate_Memory(__int64 Buffer, __int64 Format, ...)
{
  __int64 Memory; // rax MAPDST
  int Value; // eax
  _WORD *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rsi
  __int64 v9; // rdx
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  if ( Buffer )
  {
    if ( Format )
    {
      if ( KeGetCurrentIrql() <= 1u && !*(Buffer + 0x20) )
      {
        Memory = EAC_Allocate_Memory(0x800ui64);
        if ( Memory )
        {
          Value = Get_vsprintf(Memory, 0x3FFi64, Format, va);
          if ( Value < 0 || Value > 0x3FF )
          {
            *(Memory + 0x7FE) = 0;
          }
          else
          {
            if ( Value == 0x3FFi64 )
              *(Memory + 0x7FE) = 0;

            v6 = Memory;
            v7 = 0x400i64;
            do
            {
              if ( !*v6 )
                break;
              ++v6;
              --v7;
            }
            while ( v7 );
            v8 = (0x400 - v7) & -(v7 != 0);
            if ( v7 && v8 )
            {
              ExAcquireFastMutex((Buffer + 0x28));
              if ( !*(Buffer + 32) )
              {
                v9 = *(Buffer + 8);
                if ( v8 + 2 <= (*(Buffer + 0x10) - v9) )
                {
                  EAC_memcpy((*Buffer + 2 * v9), Memory, 2 * v8);
                  *(Buffer + 8) += v8;
                  *(*Buffer + 2i64 * (*(Buffer + 8))++) = 0xA;
                  *(*Buffer + 2i64 * *(Buffer + 8)) = 0;
                }
              }
              ExReleaseFastMutex((Buffer + 0x28));
            }
          }
          Get_ExFreePool(Memory);
        }
      }
    }
  }
}

//----- (000000014005B15C) ----------------------------------------------------
bool __fastcall sub_14005B15C(__int64 unicode_string, void **a2)
{
  char v4; // si
  bool v5; // bl
  unsigned __int64 v6; // rdi
  unsigned int v7; // edx
  unsigned __int64 v8; // r8
  int v9; // ecx
  char v10; // cl
  int v11; // eax
  char v12; // dl
  NTSTATUS v13; // eax
  UNICODE_STRING ObjectName; // [rsp+60h] [rbp-A0h] BYREF
  int v16[3]; // [rsp+70h] [rbp-90h]
  __int16 v17; // [rsp+7Ch] [rbp-84h]
  __int64 v18[2]; // [rsp+7Eh] [rbp-82h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+90h] [rbp-70h] BYREF
  struct _OBJECT_ATTRIBUTES v20; // [rsp+C0h] [rbp-40h] BYREF
  struct _OBJECT_ATTRIBUTES v21; // [rsp+F0h] [rbp-10h] BYREF
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+120h] [rbp+20h] BYREF
  struct _FILE_NETWORK_OPEN_INFORMATION FileInformation; // [rsp+130h] [rbp+30h] BYREF

  v4 = 0;
  v5 = 1;
  if ( !unicode_string || !*(unicode_string + 8) || !*unicode_string || !*(unicode_string + 2) || !a2 )
    return 0;
  *a2 = 0i64;
  if ( !KeGetCurrentIrql() && !Get_KeAreAllApcsDisabled() )
  {
    ObjectName.Buffer = EAC_Allocate_Memory(0x200ui64);
    if ( ObjectName.Buffer )
    {
      *&ObjectName.Length = 0x2000000;
      if ( sub_14005D620(&ObjectName, unicode_string) < 0 )
        goto LABEL_14;
      v16[0] = 982343522;
      v17 = 18931;
      v6 = 12i64;
      v16[1] = -409831820;
      v18[0] = 0i64;
      v7 = 987848524;
      LODWORD(v18[1]) = 0;
      v8 = 0i64;
      WORD2(v18[1]) = 0;
      v16[2] = 1188277615;
      do
      {
        v9 = v16[v8] ^ v7;
        v7 = __ROR4__(1140671485 * v7 + 12820163, 3);
        *(v18 + v8 * 4) = v9;
        ++v8;
      }
      while ( v8 < 3 );
      do
      {
        v10 = v7;
        v7 >>= 8;
        *(v18 + v6) = *(v16 + v6) ^ v10;
        ++v6;
      }
      while ( v6 < 0xE );
      v4 = 1;
      v11 = sub_14005D584(&ObjectName.Length, v18);
      v12 = 1;
      if ( v11 < 0 )
LABEL_14:
        v12 = 0;
      if ( (v4 & 1) != 0 )
        memset(v18, 0, 0xEui64);
      if ( v12 )
      {
        if ( !ObjectName.Buffer )
          goto LABEL_31;
        if ( ObjectName.Length && ObjectName.MaximumLength && !KeGetCurrentIrql() && !Get_KeAreAllApcsDisabled() )
        {
          ObjectAttributes.Length = 48;
          ObjectAttributes.ObjectName = &ObjectName;
          ObjectAttributes.RootDirectory = 0i64;
          *&ObjectAttributes.SecurityDescriptor = 0i64;
          ObjectAttributes.Attributes = 576;
          ZwDeleteFile(&ObjectAttributes);
        }
        if ( ObjectName.Buffer
          && ObjectName.Length
          && ObjectName.MaximumLength
          && !KeGetCurrentIrql()
          && !Get_KeAreAllApcsDisabled()
          && (v20.Length = 48,
              v20.ObjectName = &ObjectName,
              v20.RootDirectory = 0i64,
              v20.Attributes = 576,
              *&v20.SecurityDescriptor = 0i64,
              ZwQueryFullAttributesFile(&v20, &FileInformation) >= 0) )
        {
          v5 = 0;
        }
        else
        {
LABEL_31:
          v21.ObjectName = &ObjectName;
          v21.Length = 48;
          v21.RootDirectory = 0i64;
          v21.Attributes = 576;
          *&v21.SecurityDescriptor = 0i64;
          v13 = ZwCreateFile(a2, 0xC0110000, &v21, &IoStatusBlock, 0i64, 2u, 0, 2u, 0x1000u, 0i64, 0);
          if ( v13 < 0 )
            *a2 = 0i64;
          v5 = v13 != -1073741771;
        }
      }
      Get_ExFreePool(ObjectName.Buffer);
    }
  }
  return v5;
}

//----- (000000014005B450) ----------------------------------------------------
char __fastcall sub_14005B450(__int64 Length)
{
  char v1; // si
  char v2; // r15
  __int64 v3; // rax
  __int64 v4; // rbx
  unsigned int v5; // ebp
  __int64 v6; // r14
  __int64 v7; // rdi
  UNICODE_STRING unicode_string; // [rsp+20h] [rbp-28h] BYREF

  v1 = 0;
  if ( !dword_1400862C4
    || !Length
    || !*(Length + 8)
    || !*Length
    || !*(Length + 2)
    || KeGetCurrentIrql()
    || !EAC_Allocate_Unicode_string(&unicode_string, Length, *Length) )
  {
    return 0;
  }
  v2 = 0;
  KeEnterCriticalRegion();
  ExAcquireFastMutexUnsafe(&stru_1400862D0);
  v3 = qword_1400862C8;
  if ( qword_1400862C8 )
  {
    v4 = 0i64;
    v5 = 0;
    v6 = 0i64;
    do
    {
      v7 = v6 + v3;
      if ( *(v6 + v3 + 24) )
      {
        if ( RtlEqualUnicodeString((v7 + 8), &unicode_string, 1u) )
        {
          ++*(v7 + 24);
          v1 = 1;
          goto LABEL_20;
        }
        v3 = qword_1400862C8;
      }
      if ( !v4 && !*(v7 + 24) )
        v4 = v7;
      ++v5;
      v6 += 32i64;
    }
    while ( v5 < 0x20 );
    if ( v4 && sub_14005B15C(&unicode_string, v4) )
    {
      ++*(v4 + 24);
      v2 = 1;
      v1 = 1;
      *(v4 + 8) = unicode_string;
    }
  }
LABEL_20:
  ExReleaseFastMutexUnsafe(&stru_1400862D0);
  KeLeaveCriticalRegion();
  if ( !v2 )
    EAC_Free_UnicodeString(&unicode_string);
  return v1;
}
// 1400862C4: using guessed type int dword_1400862C4;
// 1400862C8: using guessed type __int64 qword_1400862C8;

//----- (000000014005B5B0) ----------------------------------------------------
void __fastcall sub_14005B5B0(PCUNICODE_STRING String2)
{
  __int64 v2; // rbx
  unsigned int v3; // ebp
  __int64 v4; // rdi
  unsigned __int64 v6; // rcx

  if ( !dword_1400862C4
    || !String2
    || !String2->Buffer
    || !String2->Length
    || !String2->MaximumLength
    || KeGetCurrentIrql() )
  {
    return;
  }
  KeEnterCriticalRegion();
  ExAcquireFastMutexUnsafe(&stru_1400862D0);
  v2 = qword_1400862C8;
  if ( !qword_1400862C8 )
    goto LABEL_17;
  v3 = 0;
  v4 = 0i64;
  while ( !*(v4 + v2 + 24) )
  {
LABEL_12:
    ++v3;
    v4 += 32i64;
    if ( v3 >= 0x20 )
      goto LABEL_17;
  }
  if ( !RtlEqualUnicodeString((v4 + v2 + 8), String2, 1u) )
  {
    v2 = qword_1400862C8;
    goto LABEL_12;
  }
  if ( (*(v4 + v2 + 24))-- == 1 )
  {
    EAC_Free_UnicodeString(v4 + v2 + 8);
    v6 = *(v4 + v2);
    if ( v6 )
    {
      Get_NtClose(v6);
      *(v4 + v2) = 0i64;
    }
  }
LABEL_17:
  ExReleaseFastMutexUnsafe(&stru_1400862D0);
  KeLeaveCriticalRegion();
}
// 1400862C4: using guessed type int dword_1400862C4;
// 1400862C8: using guessed type __int64 qword_1400862C8;

//----- (000000014005B6B8) ----------------------------------------------------
void sub_14005B6B8()
{
  __int64 v0; // rcx
  unsigned int v1; // edi
  __int64 v2; // rbx

  KeGetCurrentIrql();
  if ( dword_1400862C4 )
  {
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&stru_1400862D0);
    v0 = qword_1400862C8;
    if ( qword_1400862C8 )
    {
      v1 = 0;
      v2 = 0i64;
      do
      {
        if ( *(v2 + v0 + 24) )
        {
          EAC_Free_UnicodeString(0x20i64 * v1 + 8 + v0);
          v0 = qword_1400862C8;
          if ( *(v2 + qword_1400862C8) )
          {
            Get_NtClose(*(v2 + qword_1400862C8));
            v0 = qword_1400862C8;
          }
        }
        ++v1;
        v2 += 32i64;
      }
      while ( v1 < 0x20 );
      Get_ExFreePool(v0);
      qword_1400862C8 = 0i64;
    }
    ExReleaseFastMutexUnsafe(&stru_1400862D0);
    KeLeaveCriticalRegion();
  }
}
// 1400862C4: using guessed type int dword_1400862C4;
// 1400862C8: using guessed type __int64 qword_1400862C8;

//----- (000000014005B934) ----------------------------------------------------
char *sub_14005B934()
{
  __int64 v1; // rdx
  char *v2; // rbx

  if ( KeGetCurrentIrql() > 1u )
    return 0i64;
  ExAcquireFastMutex(&stru_140086348);
  v1 = qword_140086340 + 1;
  v2 = BaseAddress + 3252 * qword_140086340;
  if ( qword_140086340 == 63 )
    v1 = 0i64;
  qword_140086340 = v1;
  ExReleaseFastMutex(&stru_140086348);
  return v2;
}
// 140086340: using guessed type __int64 qword_140086340;

//----- (000000014005B994) ----------------------------------------------------
int EAC_MapModuleToProcess()
{
  char *Allocate; // rax
  __m128 *Buffer; // rdi
  bool Value; // bl
  ULONG_PTR RegionSize; // [rsp+50h] [rbp+8h] BYREF
  __int64 SizeOfImage; // [rsp+58h] [rbp+10h] BYREF

  stru_140086348.Count = 1;
  stru_140086348.Owner = 0i64;
  stru_140086348.Contention = 0;
  KeInitializeEvent(&stru_140086348.Event, SynchronizationEvent, 0);
  BaseAddress = 0i64;
  RegionSize = 208128i64;
  LODWORD(Allocate) = ZwAllocateVirtualMemory(0xFFFFFFFFFFFFFFFFi64, &BaseAddress, 0i64, &RegionSize, 0x3000u, 4u);
  if ( Allocate >= 0 )
  {
    EAC_IsUsermodeValidAddress(BaseAddress, RegionSize, 1);
    EAC_memset(BaseAddress, 0, RegionSize);
    Allocate = (loc_14000CD18)(&unk_140076C60, 24576i64);
    Buffer = Allocate;
    if ( Allocate )
    {
      Value = EAC_MapImage(Allocate, 0x6000ui64, &qword_140086330, &SizeOfImage, &dword_140086328, 0i64, 0i64);
      EAC_memset(Buffer, 0, 0x6000ui64);
      LODWORD(Allocate) = Get_ExFreePool(Buffer);
      if ( Value )
      {
        EAC_memset(qword_140086330, 0, 0x1000ui64);
        LODWORD(Allocate) = qword_140086330;
        qword_140086380 = qword_140086330;
      }
    }
  }
  return Allocate;
}
// 140086328: using guessed type int dword_140086328;
// 140086330: using guessed type __int64 qword_140086330;
// 140086380: using guessed type __int64 qword_140086380;

//----- (000000014005BAD8) ----------------------------------------------------
char __fastcall EAC_Get_Entry_Point(ULONG64 BaseAddress)
{
  __int64 AddressOfEntryPoint; // rax MAPDST
  unsigned int OldProtection; // [rsp+58h] [rbp+10h] BYREF
  __int64 Length; // [rsp+60h] [rbp+18h] BYREF
  __int64 Address_Of_Entry_Point; // [rsp+68h] [rbp+20h] BYREF

  AddressOfEntryPoint = EAC_Get_AddressOfEntryPoint(BaseAddress);
  if ( AddressOfEntryPoint )
  {
    Address_Of_Entry_Point = AddressOfEntryPoint;
    Length = 0x17i64;
    LODWORD(AddressOfEntryPoint) = Get_ZwProtectVirtualMemory(
                                     -1i64,
                                     &Address_Of_Entry_Point,
                                     &Length,
                                     0x40u,
                                     &OldProtection);
    if ( AddressOfEntryPoint >= 0 )
    {
      EAC_IsUsermodeValidAddress(AddressOfEntryPoint, 0x17i64, 1);
      *AddressOfEntryPoint = xmmword_140076C40;
      *(AddressOfEntryPoint + 0x10) = 0;
      *(AddressOfEntryPoint + 0x14) = -12033;
      *(AddressOfEntryPoint + 0x16) = -61;
      *(AddressOfEntryPoint + 1) = qword_140086380;
      *(AddressOfEntryPoint + 6) = ::BaseAddress;
      *(AddressOfEntryPoint + 0xB) = qword_140086330;
      *(AddressOfEntryPoint + 0x10) = dword_140086328;
      byte_1400861D6 = 1;
      LOBYTE(AddressOfEntryPoint) = Get_ZwProtectVirtualMemory_2(
                                      AddressOfEntryPoint,
                                      0x17i64,
                                      OldProtection,
                                      &OldProtection);
    }
  }
  return AddressOfEntryPoint;
}
// 140076C40: using guessed type __int128 xmmword_140076C40;
// 1400861D6: using guessed type char byte_1400861D6;
// 140086328: using guessed type int dword_140086328;
// 140086330: using guessed type __int64 qword_140086330;
// 140086380: using guessed type __int64 qword_140086380;

//----- (000000014005BBB4) ----------------------------------------------------
__int64 __fastcall sub_14005BBB4(signed __int64 a1, __int64 Length, _BYTE *a3)
{
  __int64 CurrentProcess; // rax
  __int64 ProcessId; // r14
  int v8; // edx
  unsigned __int64 v9; // r8
  bool v10; // zf
  __int64 v11; // rax
  __int64 result; // rax
  _UNICODE_STRING v13; // [rsp+20h] [rbp-40h] BYREF
  int v14[6]; // [rsp+30h] [rbp-30h]
  _BYTE v15[24]; // [rsp+48h] [rbp-18h] BYREF

  CurrentProcess = Get_PsGetCurrentProcess();
  ProcessId = Get_PsGetProcessId(CurrentProcess);
  v14[0] = -33975008;
  v14[1] = -1576688122;
  v14[2] = 176564612;
  v14[3] = 1526824905;
  v14[4] = -1084686431;
  v8 = -894154109;
  v14[5] = -277386553;
  v9 = 0i64;
  memset(v15, 0, sizeof(v15));
  do
  {
    v8 = __ROL4__(((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13) ^ (32 * (((v8 ^ (v8 << 13)) >> 17) ^ v8 ^ (v8 << 13))), 2);
    *&v15[v9 * 4] = v14[v9] ^ v8;
    ++v9;
  }
  while ( v9 < 6 );
  if ( a1 )
  {
    if ( Length )
    {
      if ( *(Length + 8) )
      {
        if ( *Length )
        {
          if ( *(Length + 2) )
          {
            if ( a3 )
            {
              v10 = byte_1400861D5 == 0;
              *a3 = 0;
              if ( v10
                && qword_140085F38
                && ProcessId == qword_140085F38
                && !EAC_ProcessId_0
                && EAC_Copy_Unicode_from_Unicode(Length, &v13)
                && !Get_CompareUnicodeString(&v13, v15) )
              {
                if ( KUSER_SHARED_DATA.NtMajorVersion == 5 )
                {
                  if ( Event )
                    KeSetEvent(Event, 0, 0);
                }
                else
                {
                  qword_140086318 = ProcessId;
                  _InterlockedCompareExchange64(&EAC_ProcessId_0, a1, 0i64);
                  v11 = Get_PsGetCurrentProcess();
                  (loc_14002EC90)(v11);
                  byte_1400861D5 = 1;
                  *a3 = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  result = 0i64;
  memset(v15, 0, sizeof(v15));
  return result;
}
// 140085F38: using guessed type __int64 qword_140085F38;
// 1400861D5: using guessed type char byte_1400861D5;
// 140086310: using guessed type __int64 qword_140086310;
// 140086318: using guessed type __int64 qword_140086318;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014005BD6C) ----------------------------------------------------
char __fastcall EAC_Call_Entry_Point(ULONG64 BaseAddress)
{
  __int64 CurrentProcess; // rax
  __int64 ProcessId; // rax
  __int64 Process; // rax

  CurrentProcess = Get_PsGetCurrentProcess();
  ProcessId = Get_PsGetProcessId(CurrentProcess);

  if ( !EAC_ProcessId_0 || ProcessId != EAC_ProcessId_0 )
    return 0;

  Process = Get_PsGetCurrentProcess();
  if ( BaseAddress == Get_PsGetProcessSectionBaseAddress(Process)
    && !_InterlockedCompareExchange(&dword_140086320, 1, 0) )
  {
    EAC_MapModuleToProcess();
    EAC_Get_Entry_Point(BaseAddress);
    if ( Event )
      KeSetEvent(Event, 0, 0);
  }
  return 1;
}
// 140086310: using guessed type __int64 EAC_ProcessId_0;
// 140086320: using guessed type int dword_140086320;

//----- (000000014005BE24) ----------------------------------------------------
LONG_PTR __fastcall sub_14005BE24(char **a1, int a2, void *a3, __int64 a4)
{
  LONG_PTR result; // rax
  char *v8; // r14
  void *v9; // rcx
  unsigned __int64 v10; // r8
  __int64 v11; // rdx
  unsigned __int64 i; // r8
  unsigned __int64 v13; // rax
  bool v14; // [rsp+30h] [rbp-98h]
  PVOID v15; // [rsp+38h] [rbp-90h] BYREF
  PVOID Object; // [rsp+40h] [rbp-88h] BYREF
  __int64 v17; // [rsp+48h] [rbp-80h]
  __int64 v18; // [rsp+50h] [rbp-78h]
  union _LARGE_INTEGER Timeout; // [rsp+58h] [rbp-70h] BYREF
  unsigned __int64 v20; // [rsp+60h] [rbp-68h]
  _KAPC_STATE ApcState[2]; // [rsp+68h] [rbp-60h] BYREF
  void *retaddr; // [rsp+C8h] [rbp+0h] BYREF
  PVOID Process; // [rsp+E0h] [rbp+18h] BYREF
  __int64 v25; // [rsp+E8h] [rbp+20h]

  result = &retaddr;
  v25 = a4;
  Process = a3;
  v20 = 4i64;
  v14 = 0;
  Object = 0i64;
  v15 = 0i64;
  if ( a4 )
  {
    result = EAC_memset((a4 + 8), 0, 0xA98ui64);
    *a4 = 1;
    *(a4 + 4) = 6;
    if ( a1 && a1[1] && *a1 && *(a1 + 1) && a2 )
    {
      result = KUSER_SHARED_DATA.NtMajorVersion;
      if ( KUSER_SHARED_DATA.NtMajorVersion < 6
        || KUSER_SHARED_DATA.NtMajorVersion == 6 && (result = 0xFFFFF78000000270ui64, !KUSER_SHARED_DATA.NtMinorVersion) )
      {
        *(a4 + 4) = 0;
      }
      else
      {
        result = EAC_ProcessId_0;
        if ( EAC_ProcessId_0 && byte_1400861D6 )
        {
          result = Get_PsLookupProcessByProcessId(EAC_ProcessId_0, &Process);
          if ( result >= 0 )
          {
            v8 = sub_14005B934();
            v17 = v8;
            if ( v8 && Get_KeStackAttachProcess(Process, ApcState) )
            {
              if ( qword_140086380 )
              {
                EAC_IsUsermodeValidAddress(qword_140086380, 4i64, 1);
                v9 = *qword_140086380;
                if ( v9 )
                {
                  if ( ObReferenceObjectByHandle(v9, 2u, ExEventObjectType, 1, &Object, 0i64) >= 0 )
                  {
                    EAC_IsUsermodeValidAddress(v8, 3252i64, 1);
                    if ( ObReferenceObjectByHandle(*(v8 + 1), 0x100000u, ExEventObjectType, 1, &v15, 0i64) >= 0 )
                    {
                      *(v8 + 2) = a2;
                      v10 = 518i64;
                      if ( *a1 < 0x206ui64 )
                        v10 = *a1;
                      EAC_memcpy(v8 + 12, a1[1], v10);
                      *(v8 + 265) = 0;
                      v11 = 0i64;
                      for ( i = 0i64; ; ++i )
                      {
                        v18 = v11;
                        if ( i >= 0x208 )
                          break;
                        v8[v11 + 12] += 64 - 96 * v11;
                        v11 = i + 1;
                      }
                      EAC_memset((v8 + 532), 0, 0xAA0ui64);
                      *(v8 + 133) = 1;
                      *(v8 + 134) = 7;
                      *v8 = 1;
                      v14 = 1;
                    }
                    else
                    {
                      v15 = 0i64;
                    }
                  }
                  else
                  {
                    Object = 0i64;
                  }
                }
              }
              (loc_140054154)(Process, ApcState);// KeUnstackDetachProcess
              *(a4 + 4) = 7;
              if ( v14 )
              {
                KeSetEvent(Object, 0, 1u);
                Timeout.QuadPart = -300000000i64;
                v14 = KeWaitForSingleObject(v15, UserRequest, 0, 0, &Timeout) == 0;
              }
              if ( v15 )
                ObfDereferenceObject(v15);
              if ( Object )
                ObfDereferenceObject(Object);
            }
            if ( v14 && Get_KeStackAttachProcess(Process, ApcState) )
            {
              EAC_IsUsermodeValidAddress(v8, 3252i64, 1);
              v17 = 4i64;
              v13 = v20;
              if ( v20 > 4 )
                v13 = 4i64;
              EAC_memcpy(a4, v8 + 0x214, 680 * v13);
              EAC_memset((v8 + 0x214), 0, 0xAA0ui64);
              (loc_140054154)(Process, ApcState);// KeUnstackDetachProcess
            }
            return ObfDereferenceObject(Process);
          }
        }
        else
        {
          *(a4 + 4) = 6;
        }
      }
    }
    else
    {
      *(a4 + 4) = 4;
    }
  }
  return result;
}
// 1400861D6: using guessed type char byte_1400861D6;
// 140086310: using guessed type __int64 EAC_ProcessId_0;
// 140086380: using guessed type __int64 qword_140086380;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014005C1D4) ----------------------------------------------------
char sub_14005C1D4()
{
  char v0; // cl

  if ( KUSER_SHARED_DATA.NtMajorVersion < 6 )
    return 1;
  v0 = 0;
  if ( KUSER_SHARED_DATA.NtMajorVersion == 6 && !KUSER_SHARED_DATA.NtMinorVersion )
    return 1;
  if ( EAC_ProcessId_0 )
  {
    if ( byte_1400861D6 )
      return 1;
  }
  return v0;
}
// 1400861D6: using guessed type char byte_1400861D6;
// 140086310: using guessed type __int64 EAC_ProcessId_0;
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014005C214) ----------------------------------------------------
char __fastcall EAC_Is_Equal_ProcessId(__int64 ProcessId)
{
  char ret; // dl

  ret = 0;
  if ( ProcessId && ProcessId == EAC_ProcessId_0 )
    return 1;

  return ret;
}
// 140086310: using guessed type __int64 EAC_ProcessId_0;

//----- (000000014005C240) ----------------------------------------------------
void __fastcall sub_14005C240(void *a1)
{
  NTSTATUS v1; // eax
  struct _KEVENT *v2; // rcx

  if ( a1 && !Event )
  {
    v1 = ObReferenceObjectByHandle(a1, 2u, ExEventObjectType, 1, &Event, 0i64);
    v2 = Event;
    if ( v1 < 0 )
      v2 = 0i64;
    Event = v2;
  }
}

//----- (000000014005C298) ----------------------------------------------------
void sub_14005C298()
{
  if ( EAC_ProcessId_0 )
  {
    sub_140053E00(EAC_ProcessId_0, 0);
    EAC_ProcessId_0 = 0i64;
  }
  if ( Event )
  {
    ObfDereferenceObject(Event);
    Event = 0i64;
  }
  qword_140086318 = 0i64;
}
// 140086310: using guessed type __int64 EAC_ProcessId_0;
// 140086318: using guessed type __int64 qword_140086318;

//----- (000000014005D214) ----------------------------------------------------
char __fastcall sub_14005D214(_UNICODE_STRING *unicode_string)
{
  char result; // al

  result = 0;
  if ( !unicode_string || !unicode_string->Buffer || !unicode_string->Length || !unicode_string->MaximumLength )
    return 1;

  return result;
}

//----- (000000014005D230) ----------------------------------------------------
LONG __fastcall Get_CompareUnicodeString(_UNICODE_STRING *UnicodeString, WCHAR *string)
{
  BOOLEAN Case; // r9
  _UNICODE_STRING *UnicodeString0; // r10
  UNICODE_STRING String2; // [rsp+20h] [rbp-18h] BYREF

  Get_Unicode_string_Inline(&String2, string);
  return RtlCompareUnicodeString(UnicodeString0, &String2, Case);
}
// 14005D24F: variable 'UnicodeString0' is possibly undefined
// 14005D24F: variable 'Case' is possibly undefined

//----- (000000014005D25C) ----------------------------------------------------
char __fastcall sub_14005D25C(__int64 a1, __int64 a2)
{
  char v2; // bl

  v2 = 0;
  if ( a1 && *(a1 + 8) && *a1 && a2 && sub_14005D7E4(*(a1 + 8), a2) )
    return 1;
  return v2;
}
// 14005D7E4: using guessed type __int64 __fastcall sub_14005D7E4(_QWORD, _QWORD);

//----- (000000014005D29C) ----------------------------------------------------
unsigned __int64 __fastcall Get_Unicode_string_Inline(_UNICODE_STRING *unicode_string, WCHAR *string)
{
  USHORT Length; // r8
  __int64 v3; // rax
  unsigned __int64 result; // rax

  Length = 0;
  if ( string )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( string[v3] );

    result = 2 * v3;

    if ( result > 0xFFFC )
      result = 0xFFFCi64;

    Length = result + 2;
  }
  else
  {
    result = 0i64;
  }
  unicode_string->Length = result;
  unicode_string->MaximumLength = Length;
  unicode_string->Buffer = string;

  return result;
}

//----- (000000014005D2DC) ----------------------------------------------------
char __fastcall sub_14005D2DC(__int64 Size, unsigned __int16 Length)
{
  __int64 Memory; // rax
  char result; // al

  if ( !Size )
    return 0;

  if ( !Length )
    return 0;

  Memory = EAC_Allocate_Memory(Length);
  *(Size + 8) = Memory;
  if ( !Memory )
    return 0;

  *(Size + 2) = Length;
  result = 1;

  *Size = 0;
  return result;
}

//----- (000000014005D32C) ----------------------------------------------------
char __fastcall EAC_Read_String_From_Unicode_String(_UNICODE_STRING *unicode_string, char *String)
{
  char ret; // bl
  __int64 idx; // rdi
  unsigned __int64 Length; // rdi
  __m128 *Memory; // rax

  ret = 0;
  if ( unicode_string )
  {
    if ( String )
    {
      idx = -1i64;
      do
        ++idx;
      while ( *&String[2 * idx] );

      Length = 2 * idx + 2;

      if ( Length < 0xFFFF )
      {
        Memory = EAC_Allocate_Memory(Length);
        unicode_string->Buffer = Memory;
        if ( Memory )
        {
          EAC_memset(Memory, 0, Length);
          EAC_memcpy(unicode_string->Buffer, String, Length);
          unicode_string->MaximumLength = Length;
          ret = 1;
          unicode_string->Length = Length - 2;
        }
      }
    }
  }
  return ret;
}

//----- (000000014005D3C4) ----------------------------------------------------
char __fastcall EAC_Allocate_Unicode_string(
        _UNICODE_STRING *unicode_string,
        unsigned __int16 *Length,
        unsigned __int16 Size)
{
  unsigned int _Size; // esi
  __m128 *Memory; // rax
  PWSTR Buffer; // rcx

  _Size = Size;
  if ( !unicode_string )
    return 0;

  if ( !Length )
    return 0;

  if ( !*(Length + 1) )
    return 0;

  if ( !*Length )
    return 0;

  if ( !Length[1] )
    return 0;

  if ( Size < *Length )
    return 0;

  Memory = EAC_Allocate_Memory(Size);

  unicode_string->Buffer = Memory;
  if ( !Memory )
    return 0;

  EAC_memset(Memory, 0, _Size);
  Buffer = unicode_string->Buffer;
  unicode_string->Length = *Length;
  unicode_string->MaximumLength = _Size;
  EAC_memcpy(Buffer, *(Length + 1), *Length);

  return 1;
}

//----- (000000014005D468) ----------------------------------------------------
char __fastcall EAC_Check_Unicode_string(_UNICODE_STRING *unicode_string, __int64 Length)
{
  char result; // al

  result = 0;
  if ( unicode_string && Length && *(Length + 8) && *Length )
  {
    if ( *(Length + 2) )
      return EAC_Allocate_Unicode_string(unicode_string, Length, *Length);
  }
  return result;
}

//----- (000000014005D498) ----------------------------------------------------
__int64 __fastcall EAC_Free_UnicodeString(_UNICODE_STRING *unicode_string)
{
  PWSTR Buffer; // rcx
  __int64 result; // rax

  if ( unicode_string )
  {
    Buffer = unicode_string->Buffer;
    if ( Buffer )
    {
      result = Get_ExFreePool(Buffer);
      *unicode_string = 0i64;
    }
  }
  return result;
}

//----- (000000014005D4C0) ----------------------------------------------------
NTSTATUS __fastcall Get_RtlMultiByteToUnicodeN(unsigned __int16 *Length, unsigned __int16 *BytesInMultiByteString)
{
  unsigned __int64 TotalSize; // rcx
  NTSTATUS result; // eax
  WCHAR *Memory; // rax
  int Status; // eax MAPDST
  __int64 Size; // rcx
  ULONG BytesInUnicodeString; // [rsp+40h] [rbp+8h] BYREF

  if ( !Length || !BytesInMultiByteString )
    return 0xC000000D;

  TotalSize = 2i64 * *BytesInMultiByteString + 2;

  if ( TotalSize > 0xFFFF )
    return 0xC00000F0;

  Length[1] = TotalSize;
  *Length = TotalSize - 2;
  Memory = EAC_Allocate_Memory(TotalSize);

  *(Length + 1) = Memory;
  if ( !Memory )
    return 0xC0000017;

  Status = RtlMultiByteToUnicodeN(
             Memory,
             *Length,
             &BytesInUnicodeString,
             *(BytesInMultiByteString + 1),
             *BytesInMultiByteString);

  Size = *(Length + 1);
  if ( Status >= 0 )
  {
    *(Size + 2 * (BytesInUnicodeString >> 1)) = 0;
    *Length = BytesInUnicodeString;
    return 0;
  }
  else
  {
    Get_ExFreePool(Size);
    result = Status;
    *Length = 0i64;
  }
  return result;
}

//----- (000000014005D584) ----------------------------------------------------
__int64 __fastcall sub_14005D584(unsigned __int16 *Length, WCHAR *string)
{
  char *Value; // rdx
  unsigned __int64 Size; // rcx
  unsigned __int64 uni_string; // rsi
  _OWORD *Copy; // r14
  __int16 unicode_string[12]; // [rsp+20h] [rbp-18h] BYREF

  if ( string )
  {
    Get_Unicode_string_Inline(unicode_string, string);
    Size = *Length;
    uni_string = unicode_string[0];
    if ( Size + unicode_string[0] > Length[1] )
      return 0xC0000023i64;

    Copy = (*(Length + 1) + 2 * (Size >> 1));
    EAC_memcpy(Copy, Value, unicode_string[0]);
    *Length += uni_string;
    if ( Length[1] >= *Length + 2 )
      *(Copy + (uni_string >> 1)) = 0;
  }
  return 0i64;
}
// 14005D5E0: variable 'Value' is possibly undefined
// 14005D584: using guessed type unsigned __int16 unicode_string[12];

//----- (000000014005D620) ----------------------------------------------------
__int64 __fastcall sub_14005D620(UNICODE_STRING *unicode_string_1, char **unicode_string)
{
  unsigned __int64 String; // rsi
  unsigned int Length; // ecx
  WCHAR *Buffer; // r14

  String = *unicode_string;
  Length = unicode_string_1->Length;
  Buffer = &unicode_string_1->Buffer[Length >> 1];
  if ( String )
  {
    if ( String + Length > unicode_string_1->MaximumLength )
      return 0xC0000023i64;

    EAC_memcpy(Buffer, unicode_string[1], String);

    unicode_string_1->Length += String;
    if ( unicode_string_1->MaximumLength >= unicode_string_1->Length + 2 )
      Buffer[String >> 1] = 0;
  }
  return 0i64;
}

//----- (000000014005D6B8) ----------------------------------------------------
unsigned __int64 __fastcall EAC_Compare_Unicode_Size_String(__int64 ModuleName, __int64 Size, unsigned __int16 *Length)
{
  unsigned __int64 result; // rax
  unsigned __int64 ShAddress; // r10

  if ( !ModuleName || !Size || !Length || !*(Length + 1) || !*Length || !Length[1] )
    return 0i64;

  result = 0i64;
  ShAddress = *Length >> 1;
  if ( ShAddress )
  {
    do
    {
      if ( result >= Size - 1 )
        break;

      *(ModuleName + 2 * result) = *(*(Length + 1) + 2 * result);
      ++result;
    }
    while ( result < ShAddress );
  }

  *(ModuleName + 2 * result) = 0;

  return result;
}

//----- (000000014005D720) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005D720(__int64 a1, __int64 a2, unsigned __int16 *a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r10

  if ( !a1 || !a2 || !a3 || !*(a3 + 1) || !*a3 || !a3[1] )
    return 0i64;

  result = 0i64;
  v4 = *a3 >> 1;
  if ( v4 )
  {
    do
    {
      if ( result >= a2 - 1 )
        break;
      *(result + a1) = *(*(a3 + 1) + 2 * result);
      ++result;
    }
    while ( result < v4 );
  }
  *(result + a1) = 0;
  return result;
}

//----- (000000014005D784) ----------------------------------------------------
char __fastcall sub_14005D784(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r10
  char ret; // r9
  __int64 v5; // r11

  v3 = 0i64;
  ret = 1;
  if ( a3 )
  {
    v5 = a1 - a2;
    while ( (a2[v5] | 0x20) == (*a2 | 0x20) )
    {
      if ( a2[v5] || *a2 )
      {
        ++v3;
        ++a2;
        if ( v3 < a3 )
          continue;
      }
      return ret;
    }
    return 0;
  }
  return ret;
}

//----- (000000014005D7E4) ----------------------------------------------------
char *__fastcall sub_14005D7E4(char *Buffer, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // r9
  __int64 v5; // r10
  char *v6; // r11
  unsigned __int64 v7; // rbx
  unsigned __int16 v8; // dx
  __int16 v9; // ax

  v4 = 0i64;
  if ( a3 )
  {
    v5 = a2 - Buffer;
    do
    {
      if ( !*Buffer )
        break;

      v6 = Buffer;
      v7 = v4;
      if ( v4 < a3 )
      {
        v8 = *a2;
        do
        {
          v9 = *v6 | 0x20;
          v6 += 2;
          if ( v9 != (v8 | 0x20) )
            break;
          v8 = *&v6[v5];
          if ( !v8 )
            return Buffer;
        }
        while ( ++v7 < a3 );
      }
      ++v4;
      Buffer += 2;
      v5 -= 2i64;
    }
    while ( v4 < a3 );
  }
  return 0i64;
}

//----- (000000014005D868) ----------------------------------------------------
_BYTE *__fastcall sub_14005D868(_BYTE *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r9
  __int64 v5; // r10
  _BYTE *v6; // r11
  unsigned __int64 v7; // rbx
  unsigned __int8 v8; // dl
  char v9; // al

  v3 = 0i64;
  if ( a3 )
  {
    v5 = a2 - a1;
    do
    {
      if ( !*a1 )
        break;
      v6 = a1;
      v7 = v3;
      if ( v3 < a3 )
      {
        v8 = *a2;
        do
        {
          v9 = *v6++ | 0x20;
          if ( v9 != (v8 | 0x20) )
            break;
          v8 = v6[v5];
          if ( !v8 )
            return a1;
        }
        while ( ++v7 < a3 );
      }
      ++v3;
      ++a1;
      --v5;
    }
    while ( v3 < a3 );
  }
  return 0i64;
}

//----- (000000014005D8D4) ----------------------------------------------------
__int64 __fastcall sub_14005D8D4(__int64 ModuleName, __int64 Size, __int64 a3)
{
  unsigned __int64 ofs; // r9
  unsigned __int64 idx; // rcx
  unsigned __int64 Total_Size; // rdx
  __int64 result; // rax

  if ( ModuleName && a3 )
  {
    ofs = -1i64;
    do
      ++ofs;
    while ( *(a3 + ofs) );

    idx = 0i64;
    Total_Size = Size - 1;
    if ( Total_Size )
    {
      do
      {
        if ( idx >= ofs )
          break;

        result = *(idx + a3);
        *(ModuleName + 2 * idx) = *(idx + a3);
        ++idx;
      }
      while ( idx < Total_Size );
    }
    *(ModuleName + 2 * idx) = 0;
  }
  return result;
}

//----- (000000014005D918) ----------------------------------------------------
char __fastcall sub_14005D918(__int64 a1, char *a2, unsigned __int64 a3)
{
  char ret; // di
  unsigned __int64 v4; // rbx
  void *Memory; // rax

  ret = 0;
  v4 = a3 + 1;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( v4 < 0xFFFF )
      {
        Memory = EAC_Allocate_Memory(a3 + 1);
        *(a1 + 8) = Memory;
        if ( Memory )
        {
          memset(Memory, 0, v4);
          EAC_memcpy(*(a1 + 8), a2, a3);
          *(a1 + 2) = v4;
          ret = 1;
          *a1 = v4 - 1;
        }
      }
    }
  }
  return ret;
}

//----- (000000014005D9A8) ----------------------------------------------------
char __fastcall sub_14005D9A8(__int64 a1, unsigned __int16 *a2, unsigned __int16 a3)
{
  unsigned int v3; // ebp
  void *Memory; // rax
  unsigned __int64 v7; // r8
  char *v8; // rdx
  _OWORD *v9; // rcx

  v3 = a3;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !*(a2 + 1) )
    return 0;
  if ( !*a2 )
    return 0;
  if ( !a2[1] )
    return 0;
  if ( a3 < *a2 )
    return 0;
  Memory = EAC_Allocate_Memory(a3);
  *(a1 + 8) = Memory;
  if ( !Memory )
    return 0;
  v7 = *a2;
  v8 = *(a2 + 1);
  memset(Memory, 0, v3);
  v9 = *(a1 + 8);
  *a1 = v7;
  *(a1 + 2) = v3;
  EAC_memcpy(v9, v8, v7);
  return 1;
}

//----- (000000014005F11C) ----------------------------------------------------
// from @Swiftik
__int64 EAC_CompareToDisk()
{
  char v0; // di
  unsigned int ret; // ebx
  __int64 ntoskrnl_base; // rsi
  int v3; // edi
  unsigned __int64 v4; // rdx
  char v5; // dl
  int v8[18]; // [rsp+20h] [rbp-79h] BYREF
  _IMAGE_NT_HEADERS *NtHeader; // [rsp+68h] [rbp-31h] BYREF
  _IMAGE_NT_HEADERS *NtHeader_2; // [rsp+70h] [rbp-29h] BYREF
  _UNICODE_STRING unicode_string; // [rsp+78h] [rbp-21h] BYREF
  __m128 string[6]; // [rsp+88h] [rbp-11h] BYREF
  __int64 Size; // [rsp+100h] [rbp+67h] BYREF
  int *v14; // [rsp+108h] [rbp+6Fh]
  __m128 *v15; // [rsp+110h] [rbp+77h]
  __int64 Buffer; // [rsp+118h] [rbp+7Fh] MAPDST BYREF

  v0 = 0;
  LODWORD(Size) = 0;
  ret = 2;
  ntoskrnl_base = Ge_ntoskrnl_base();
  if ( ntoskrnl_base && EAC_GetNtoskrnlPath(&unicode_string.Length, 1) )
  {
    if ( KUSER_SHARED_DATA.NtMajorVersion <= 6
      && (KUSER_SHARED_DATA.NtMajorVersion != 6 || KUSER_SHARED_DATA.NtMinorVersion - 2 > 1) )
    {
      goto LABEL_10;
    }
    v8[0] = -769435453;
    v8[1] = -1783615648;
    v8[2] = 1529891571;
    v8[3] = -1976933188;
    v8[4] = 1986464704;
    v8[5] = 462817341;
    v8[6] = -1873799580;
    v8[7] = -2075817998;
    v8[8] = -847137830;
    v8[9] = 1855045706;
    v8[10] = -1957200133;
    v8[11] = -545029819;
    v8[12] = 1238491324;
    v8[13] = -1769469989;
    v8[14] = -1817602981;
    v8[15] = -99319420;
    v8[16] = -1761860934;
    EAC_memset(string, 0, 0x44ui64);
    v3 = -1454577375;
    v14 = v8;
    v4 = 0i64;
    v15 = string;
    do
    {
      v3 = -2531012 - 214013 * v3;
      v15->m128_i32[v4] = v14[v4] ^ v3;
      ++v4;
    }
    while ( v4 < 17 );
    v0 = 1;
    if ( Get_CompareUnicodeString(&unicode_string, string) )
    {
      v5 = 1;
    }
    else
    {
LABEL_10:
      v5 = 0;
      if ( (v0 & 1) == 0 )
        goto LABEL_13;
    }
    memset(string, 0, 0x44ui64);
    if ( v5 )
    {
      ret = 1;
LABEL_26:
      EAC_Free_UnicodeString(&unicode_string);
      return ret;
    }
LABEL_13:
    if ( EAC_ReadFile(&unicode_string, &Buffer, &Size) )
    {
      if ( Size >= 0x1000 )
        ret = !GetModuleInfo(ntoskrnl_base, 0x1000ui64, &Size, &NtHeader)
           || !GetModuleInfo(Buffer, 0x1000ui64, &Size, &NtHeader_2)
           || NtHeader->FileHeader.NumberOfSections != NtHeader_2->FileHeader.NumberOfSections
           || NtHeader->FileHeader.TimeDateStamp != NtHeader_2->FileHeader.TimeDateStamp
           || NtHeader->OptionalHeader.AddressOfEntryPoint != NtHeader_2->OptionalHeader.AddressOfEntryPoint
           || NtHeader->OptionalHeader.CheckSum != NtHeader_2->OptionalHeader.CheckSum
           || NtHeader->OptionalHeader.SizeOfImage != NtHeader_2->OptionalHeader.SizeOfImage;

      if ( Buffer )
        Get_ExFreePool(Buffer);
    }
    goto LABEL_26;
  }
  return ret;
}
// 14005F11C: using guessed type __m128 string[6];
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (000000014005F340) ----------------------------------------------------
bool __fastcall sub_14005F340(__int64 a1, __int64 *a2)
{
  unsigned __int64 v2; // rbx
  bool v5; // di
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // rsi
  _BYTE *Memory; // rax
  _BYTE *v9; // rcx
  signed int v10; // edi
  unsigned __int64 v11; // rdx
  __int64 v12; // r15
  char v13; // al

  v2 = 0i64;
  v5 = 0;
  if ( !a1 || !a2 )
    return 0;
  v6 = -1i64;
  do
    ++v6;
  while ( *(a1 + v6) );
  v7 = v6 + 1;
  if ( v6 + 1 > 1 )
  {
    Memory = EAC_Allocate_Memory(v6 + 1);
    *a2 = Memory;
    v9 = Memory;
    if ( Memory )
    {
      if ( v7 <= 0x7FFFFFFF )
      {
        v11 = 2147483646 - v7;
        v12 = a1 - Memory;
        do
        {
          if ( !(v11 + v7) )
            break;
          v13 = v9[v12];
          if ( !v13 )
            break;
          *v9++ = v13;
          --v7;
        }
        while ( v7 );
        Memory = v9 - 1;
        if ( v7 )
          Memory = v9;
        v10 = v7 == 0 ? 0x80000005 : 0;
      }
      else
      {
        v10 = -1073741811;
      }
      v5 = v10 >= 0;
      *Memory = 0;
      if ( v5 )
      {
        if ( v6 )
        {
          do
          {
            *(v2 + *a2) = tolower(*(*a2 + v2));
            ++v2;
          }
          while ( v2 < v6 );
        }
      }
      else
      {
        Get_ExFreePool(*a2);
        *a2 = 0i64;
      }
    }
  }
  return v5;
}

//----- (000000014005F450) ----------------------------------------------------
bool __fastcall sub_14005F450(_BYTE *a1, int a2, _BYTE *a3, __int64 a4, char a5)
{
  unsigned __int64 v8; // r8
  unsigned int v9; // edx
  unsigned __int64 v10; // rdi
  char v11; // cl
  bool v12; // dl
  __int64 v14; // [rsp+30h] [rbp-20h]
  __int64 v15[3]; // [rsp+38h] [rbp-18h] BYREF

  if ( !a1 || !*a1 || !a3 )
    return 0;
  v14 = 0x1216517444E171i64;
  *(v15 + 3) = 0i64;
  v8 = 0i64;
  *(&v15[1] + 3) = 0;
  v9 = 459969108;
  BYTE5(v15[1]) = 0;
  LOWORD(v15[0]) = 30198;
  v10 = 8i64;
  BYTE2(v15[0]) = -53;
  do
  {
    *(v15 + v8 + 3) = *(&v15[-1] + v8) ^ v9;
    v8 += 4i64;
    v9 = __ROL4__(((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13) ^ (32 * (((v9 ^ (v9 << 13)) >> 17) ^ v9 ^ (v9 << 13))), 3);
  }
  while ( v8 < 8 );
  do
  {
    v11 = v9;
    v9 >>= 8;
    *(v15 + v10 + 3) = *(&v15[-1] + v10) ^ v11;
    ++v10;
  }
  while ( v10 < 0xB );
  v12 = sub_14002C528(a3, 256i64, v15 + 3, a1, a2, a5 != 0 ? 0 : 0x2C, v14, v15[0]) >= 0;
  memset(v15 + 3, 0, 0xBui64);
  return v12;
}

//----- (000000014005F56C) ----------------------------------------------------
bool sub_14005F56C(_BYTE *a1, _BYTE *a2, _BYTE *a3, ...)
{
  unsigned __int32 v5; // edx
  unsigned __int64 i; // rdi
  bool v7; // cf
  int v8; // edx
  bool v9; // si
  _BYTE *v10; // rdi
  __int64 v12; // [rsp+60h] [rbp+20h] BYREF
  __int64 v13; // [rsp+78h] [rbp+38h]
  va_list va; // [rsp+78h] [rbp+38h]
  __int64 v15; // [rsp+80h] [rbp+40h]
  va_list va1; // [rsp+88h] [rbp+48h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  if ( !a1 || !*a1 || !a2 || !*a2 || !a3 )
    return 0;
  v13 = 0xAD8D36A2E09B2197ui64;
  v12 = 0i64;
  v5 = 561055146;
  for ( i = 0i64; i < 8; i += 4i64 )
  {
    v5 = _byteswap_ulong(214013 * v5 + 2531011);
    *(&v12 + i) = *(va + i) ^ v5;
  }
  v7 = v15 != 0;
  LOBYTE(v15) = -v15;
  v8 = sub_14002C528(a3, 256i64, &v12, a1, a2, v7 ? 0 : 0x2C);
  v9 = v8 >= 0;
  memset(&v12, 0, sizeof(v12));
  if ( v8 >= 0 )
  {
    v10 = a3;
    do
    {
      if ( !*v10 )
        break;
      *v10 = tolower(*v10);
      ++v10;
    }
    while ( (v10 - a3) < 0x100 );
  }
  return v9;
}
// 14002C528: using guessed type __int64 __fastcall sub_14002C528(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (000000014005F67C) ----------------------------------------------------
char sub_14005F67C(unsigned __int64 a1, char a2, unsigned int *a3, __int64 a4, ...)
{
  __int64 v8; // r13
  int *v9; // rsi
  unsigned int v11; // eax
  unsigned int v12; // ecx
  unsigned __int64 v13; // r8
  unsigned int *v14; // r14
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rax
  int v17; // r9d
  __int64 v18; // r15
  unsigned __int64 v19; // rcx
  int v20; // eax
  __int64 v21; // rax
  int *v22; // rdi
  int *v23; // rdx
  int v24; // ecx
  bool v25; // al
  int v26; // edx
  char v27; // al
  __int64 v28; // r8
  __int64 *i; // rax
  __int64 v30; // rcx
  __int64 *v31; // rdi
  bool v32; // r8
  char v33; // al
  __int64 v34; // r8
  char v35; // [rsp+30h] [rbp-208h]
  unsigned __int64 v36; // [rsp+60h] [rbp-1D8h]
  unsigned __int64 v37; // [rsp+68h] [rbp-1D0h]
  __m128 v38; // [rsp+70h] [rbp-1C8h] BYREF
  int v39; // [rsp+80h] [rbp-1B8h]
  int v40; // [rsp+84h] [rbp-1B4h]
  char v41[296]; // [rsp+110h] [rbp-128h] BYREF
  __int64 v44; // [rsp+260h] [rbp+28h] BYREF
  va_list va; // [rsp+260h] [rbp+28h]
  _WORD *v46; // [rsp+268h] [rbp+30h]
  va_list va1; // [rsp+270h] [rbp+38h] BYREF

  va_start(va1, a4);
  va_start(va, a4);
  v44 = va_arg(va1, _QWORD);
  v46 = va_arg(va1, _WORD *);
  v35 = 0;
  EAC_memset(&v38, 0, 0x98ui64);
  v44 = 0i64;
  v8 = 0i64;
  v9 = 0i64;
  if ( !a1 || !a3 || !a4 )
    return 0;
  if ( a2 == 32 )
  {
    v11 = a3[32];
    v12 = a3[33];
  }
  else
  {
    if ( a2 != 64 )
      return 0;
    v11 = a3[36];
    v12 = a3[37];
  }
  v13 = a3[20];
  v37 = v13;
  v14 = (a1 + v11);
  v15 = v13 + a1;
  v36 = v13 + a1;
  if ( !v13 || v12 < 0x14ui64 || v14 <= a1 || v14 + v12 > v15 )
    return 0;
  v38.m128_i32[3] = -271733879;
  v39 = -1732584194;
  v40 = 271733878;
  v38.m128_i32[0] = 0;
  *(v38.m128_u64 + 4) = 0x6745230100000000i64;
  while ( 1 )
  {
    v16 = v14[3];
    if ( !v16 )
      break;
    if ( v16 <= v13 )
    {
      if ( sub_14005F340(a1 + v16, va) )
      {
        v18 = v44;
        v19 = -1i64;
        do
          ++v19;
        while ( *(v44 + v19) );
        if ( v19 > 4 )
        {
          v20 = *(v19 + v44 - 4);
          if ( v20 == 2019782446 || v20 == 1937339182 || v20 == 1819042862 )
            *(v19 + v44 - 4) = 0;
        }
        v21 = *v14;
        if ( v21 || (v21 = v14[4], v21) )
          v9 = (a1 + v21);
        if ( v9 && v9 < v15 )
        {
          if ( a2 == 32 )
          {
            v22 = v9;
            while ( 1 )
            {
              v23 = v22;
              v24 = *v22;
              if ( !*v22 )
                break;
              ++v22;
              v25 = !*v22 && !v14[8];
              v26 = *v23;
              if ( v24 >= 0 )
                v27 = sub_14005F56C(v18, a1 + v26 + 2, v41, v17, v25);
              else
                v27 = sub_14005F450(v18, v26, v41, v17, v25);
              if ( v27 )
              {
                v28 = -1i64;
                do
                  ++v28;
                while ( v41[v28] );
                sub_14004C6D0(&v38, v41);
                ++v8;
              }
            }
          }
          else if ( a2 == 64 )
          {
            for ( i = v9; ; i = v31 )
            {
              v30 = *i;
              if ( !*i )
                break;
              v31 = i + 1;
              v32 = !i[1] && !v14[8];
              if ( v30 >= 0 )
                v33 = sub_14005F56C(v18, a1 + v30 + 2, v41, v17, v32);
              else
                v33 = sub_14005F450(v18, v30, v41, v17, v32);
              if ( v33 )
              {
                v34 = -1i64;
                do
                  ++v34;
                while ( v41[v34] );
                sub_14004C6D0(&v38, v41);
                ++v8;
              }
            }
          }
        }
        Get_ExFreePool(v18);
        v15 = v36;
      }
      v13 = v37;
    }
    v14 += 5;
  }
  if ( v8 )
  {
    sub_14004C78C(&v38, a4);
    if ( v46 )
      *v46 = v8;
    return 1;
  }
  return v35;
}
// 14005F87E: variable 'v17' is possibly undefined
// 14004C6D0: using guessed type __int64 __fastcall sub_14004C6D0(_QWORD, _QWORD);
// 14004C78C: using guessed type __int64 __fastcall sub_14004C78C(_QWORD, _QWORD);
// 14005F340: using guessed type __int64 __fastcall sub_14005F340(_QWORD, _QWORD);
// 14005F450: using guessed type __int64 __fastcall sub_14005F450(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 14005F56C: using guessed type __int64 __fastcall sub_14005F56C(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 14005F67C: using guessed type char var_128[296];

//----- (000000014005FF30) ----------------------------------------------------
char __fastcall sub_14005FF30(
        __int64 Address,
        unsigned __int8 (__fastcall *Routine)(__int64, _QWORD, _QWORD, __int64, __int64),
        __int64 Buffer)
{
  const char *idx; // rdi
  char ret; // bl
  unsigned int ofs; // r11d
  const char *v9; // rbp
  __int64 v10; // rcx
  unsigned int v11; // eax
  unsigned int v12; // r11d
  __int64 v13; // r10

  idx = *Address;
  ret = 0;
  ofs = 0;
  _mm_prefetch(*Address, 1);
  v9 = &idx[*(Address + 0x18)];
  while ( idx < v9 )
  {
    v10 = *idx;
    if ( byte_14007D560[v10] )
    {
      ++ofs;
    }
    else
    {
      if ( !v10 && (ofs - 7 <= 0x79 || ofs == 0x17D) )
      {
        v11 = EAC_CRC32(&idx[-ofs], ofs, 0);
        if ( Routine(v13, v12, v11, Address, Buffer) )
          return 1;
      }
      ofs = 0;
    }
    ++idx;
  }
  return ret;
}
// 14005FFB5: variable 'v13' is possibly undefined
// 14005FFAF: variable 'v12' is possibly undefined
// 14007D560: using guessed type _BYTE byte_14007D560[256];

//----- (000000014005FFE8) ----------------------------------------------------
bool __fastcall sub_14005FFE8(__int64 a1, int a2, int a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r9

  v5 = *a5 + 0x10i64 * (*(a5 + 8))++;
  *v5 = a1;
  *(v5 + 8) = a2;
  *(v5 + 0xC) = a3;
  return *(a5 + 8) == *(a5 + 0xC);
}

//----- (0000000140060018) ----------------------------------------------------
bool __fastcall sub_140060018(unsigned __int64 *Address)
{
  ULONG64 StartAddress; // rcx
  __int64 Size; // rdx

  if ( !Address )
    return 0;

  StartAddress = *Address;
  if ( !StartAddress )
    return 0;

  Size = Address[3];
  if ( !Size )
    return 0;

  if ( StartAddress < MmHighestUserAddress )
  {
    EAC_IsUsermodeValidAddress(StartAddress, Size, 1);
    return 1;
  }
  return StartAddress >= MmSystemRangeStart && Size + StartAddress > StartAddress;
}

//----- (0000000140060074) ----------------------------------------------------
char __fastcall sub_140060074(
        __int64 Address,
        __int64 a2,
        unsigned __int8 (__fastcall *a3)(__int64, _QWORD, _QWORD, __int64, __int64),
        __int64 a4)
{
  bool v6; // al
  char ret; // cl
  __int128 v10; // [rsp+28h] [rbp-30h]
  __int128 v12; // [rsp+40h] [rbp-18h]

  v10 = 0i64;
  v12 = 0i64;
  v6 = sub_140060018(&Address);
  ret = 0;

  if ( v6 && a3 )
    return sub_14005FF30(&Address, a3, a4);

  return ret;
}

//----- (00000001400600D4) ----------------------------------------------------
__int64 __fastcall Check_Address(unsigned __int64 *Address, __int64 Buffer, int Size)
{
  unsigned int ret; // [rsp+28h] [rbp-10h]

  if ( !sub_140060018(Address) || !Buffer || !Size )
    return 0i64;

  ret = 0;

  sub_14005FF30(Address, sub_14005FFE8, &Buffer);

  return ret;
}

//----- (0000000140060138) ----------------------------------------------------
char __fastcall sub_140060138(__int64 a1, __int64 a2, __int64 a3)
{
  char v4; // di
  __int64 Process; // rax
  int ProcessWow64Process; // ebp
  unsigned __int64 v7; // rax
  unsigned __int64 v9; // rbx
  unsigned int v10; // r14d
  char *v11; // r12
  unsigned int v12; // esi
  __int64 v13; // r13
  unsigned int v14; // r10d
  unsigned int v15; // edx
  char v16[24]; // [rsp+30h] [rbp-78h] BYREF
  int v17; // [rsp+48h] [rbp-60h]
  char v18[33]; // [rsp+50h] [rbp-58h] BYREF
  int v19; // [rsp+71h] [rbp-37h]

  v4 = 0;
  Process = Get_PsGetCurrentProcess();
  ProcessWow64Process = Get_PsGetProcessWow64Process(Process);

  v7 = *(a1 + 0x18);
  if ( v7 < 0x40 )
    return 0;

  v9 = *a1;
  _mm_prefetch(*a1, 1);
  v10 = 0;
  v11 = (v9 + v7 - 64);
  v12 = 0;
  v13 = 0i64;
  v14 = 16;
  while ( v9 < v11 )
  {
    if ( v12 )
    {
      if ( ProcessWow64Process == 64 )
      {
        sub_1400210C8(v9, v18);
        if ( (v19 & 0x1000) == 0 && v18[0] )
        {
          v12 += v18[0];
          if ( *v9 == 15 || (v15 = 1, *v9 == 72) )
            v15 = 2;
LABEL_26:
          v10 = EAC_CRC32(v9, v15, v10);
LABEL_27:
          if ( !byte_14007D660[*v9] )
            goto LABEL_30;
          if ( sub_14005FFE8(v13, v12, v10, a1, a3) )
            return 1;
        }
      }
      else
      {
        if ( ProcessWow64Process != 32 )
          goto LABEL_27;
        sub_14004973C(v9, v16);
        if ( (v17 & 0x1000) == 0 && v16[0] )
        {
          v12 += v16[0];
          v15 = (*v9 == 15) + 1;
          goto LABEL_26;
        }
      }
      v12 = 0;
      v9 &= 0xFFFFFFFFFFFFFFF0ui64;
      v14 = 16;
      goto LABEL_30;
    }
    if ( ProcessWow64Process == 64 )
    {
      if ( *v9 == 0x8348 && *(v9 + 2) == 0xEC || *v9 == -443987883 )
      {
        v12 = 4;
LABEL_15:
        v10 = EAC_CRC32(v9, v12, 0);
        v13 = v9;
        v14 = v12;
      }
    }
    else if ( ProcessWow64Process == 32 && *v9 == 0x8B55 && *(v9 + 2) == 0xEC )
    {
      v12 = 3;
      goto LABEL_15;
    }
LABEL_30:
    v9 += v14;
  }
  return v4;
}
// 1400602D8: variable 'v14' is possibly undefined
// 14007D660: using guessed type _BYTE byte_14007D660[280];
// 140060138: using guessed type char var_58[33];
// 140060138: using guessed type char var_78[24];

//----- (000000014006030C) ----------------------------------------------------
__int64 __fastcall sub_14006030C(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned int v5; // edi
  __int64 Memory; // rax MAPDST
  unsigned int v12; // eax
  char **v13; // rdi
  __int64 v14; // rbp
  __int128 v17; // [rsp+28h] [rbp-40h]
  __int64 v18; // [rsp+38h] [rbp-30h]
  __int128 v19; // [rsp+40h] [rbp-28h]

  v4 = 0;
  v5 = a4 >> 3;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          Memory = EAC_Allocate_Memory(0x10i64 * v5);
          if ( Memory )
          {
            v18 = a2;
            v17 = 0i64;
            v19 = 0i64;
            v12 = Check_Address(&a1, Memory, v5);
            if ( v12 )
            {
              v13 = (Memory + 8);
              v14 = v12;
              do
              {
                if ( *v13 + v4 + 1 < a4 )
                {
                  EAC_memcpy((a3 + v4), *(v13 - 1), (*v13 + 1));
                  v4 += *v13 + 1;
                }
                v13 += 2;
                --v14;
              }
              while ( v14 );
            }
            Get_ExFreePool(Memory);
          }
        }
      }
    }
  }
  return v4;
}

//----- (0000000140060518) ----------------------------------------------------
void __fastcall sub_140060518(__int64 a1, __int64 NumberOfBytes)
{
  int v3; // edx
  __int64 BaseAddress; // rdi
  __int64 Size; // r8
  __int64 v6; // [rsp+40h] [rbp-58h] BYREF
  int v7; // [rsp+48h] [rbp-50h]
  int v8; // [rsp+4Ch] [rbp-4Ch]

  if ( a1 && NumberOfBytes )
  {
    v3 = *(NumberOfBytes + 0xC);
    if ( (v3 & 0xC0000000) == 0xC0000000 )
    {
      if ( (*(a1 + 0xA8) & 0xC0000000) == 0xC0000000 )
        return;
      *(a1 + 0xA8) = v3;
    }
    if ( g_EAC_ProcessIg )
    {
      if ( qword_140083248 )
      {
        if ( qword_140083250 )
        {
          BaseAddress = EAC_Allocate_ProcessVirtualMemory_Erase(g_EAC_ProcessIg, *NumberOfBytes, 0);
          if ( BaseAddress )
          {
            *(NumberOfBytes + 4) = qword_140083258;
            sub_14000CE6C(&v6);
            v7 = g_EAC_ProcessIg ^ 0x6A96A456;
            v6 = BaseAddress ^ 0x6A380882DEFDF454i64;
            v8 = 0x8042DD12;
            if ( !(loc_1400603FC)(g_EAC_ProcessIg, qword_140083248, qword_140083250, NumberOfBytes, 0, &v6, BaseAddress) )
            {
              if ( g_EAC_ProcessIg )
                EAC_NtFreeVirtualMemory(g_EAC_ProcessIg, BaseAddress, Size);
            }
          }
        }
      }
    }
  }
}
// 140060630: variable 'Size' is possibly undefined
// 140083238: using guessed type __int64 g_EAC_ProcessIg;
// 140083248: using guessed type __int64 qword_140083248;
// 140083250: using guessed type __int64 qword_140083250;
// 140083258: using guessed type __int64 qword_140083258;

//----- (0000000140060648) ----------------------------------------------------
void __fastcall sub_140060648(__int64 a1, int a2)
{
  int v2; // eax
  int v3[10]; // [rsp+20h] [rbp-28h] BYREF

  if ( a1 )
  {
    if ( *(a1 + 16) )
    {
      v2 = *(a1 + 16);
      v3[3] = a2;
      v3[0] = 24;
      v3[5] = v2;
      sub_140060518(a1, v3);
    }
  }
}

//----- (0000000140060978) ----------------------------------------------------
void __fastcall sub_140060978(struct_Eac_Data *Eac_Data, char *Buffer)
{
  unsigned int Size; // r12d
  struct _FAST_MUTEX *fast_mutex; // r15
  __m128 *Allocate; // r14
  char value; // si
  __int64 Lenght; // r8
  __int64 ProcessId; // rcx
  _KAPC_STATE ApcState; // [rsp+30h] [rbp-58h] BYREF

  if ( Eac_Data )
  {
    if ( Buffer )
    {
      Size = *Buffer;
      if ( *Buffer )
      {
        if ( *(Buffer + 3) && KeGetCurrentIrql() <= 1u )
        {
          fast_mutex = &Eac_Data->fast_mutex;
          ExAcquireFastMutex(&Eac_Data->fast_mutex);
          Allocate = EAC_Allocate_ProcessVirtualMemory_Erase(Eac_Data->ProcessId, Size, 0);
          (loc_14000CEAC)(Buffer, Eac_Data->gap1B8, Eac_Data->ProcessId, Allocate);
          if ( Allocate )
          {
            value = 0;
            if ( Get_KeStackAttachProcess(Eac_Data->Process, &ApcState) )
            {
              EAC_memcpy(Allocate, Buffer, Size);
              *(Eac_Data->Address + 8i64 * (*Eac_Data->Address)++ + 8) = Allocate - 0xFFFF01000i64;

              value = 1;
              (loc_140054154)(Eac_Data->Process, &ApcState);// KeUnstackDetachProcess
            }
            if ( !value )
            {
              ProcessId = Eac_Data->ProcessId;
              if ( ProcessId )
                EAC_NtFreeVirtualMemory(ProcessId, Allocate, Lenght);
            }
          }
          ExReleaseFastMutex(fast_mutex);
        }
      }
    }
  }
}
// 140060AB7: variable 'Lenght' is possibly undefined
// 140060978: using guessed type _KAPC_STATE ApcState;

//----- (0000000140060B80) ----------------------------------------------------
// from @Swiftik
char __fastcall EAC_vmreadwrapper(__int64 _RCX, __int64 _RDX)
{
  char v2; // cf
  char v3; // zf

  __asm { vmread  qword ptr [rdx], rcx }
  return v2 + v2 + v3;
}
// 140060B89: variable 'v2' is possibly undefined
// 140060B89: variable 'v3' is possibly undefined

//----- (0000000140060BB0) ----------------------------------------------------
void sub_140060BB0()
{
  __asm
  {
    xbegin  locret_140060BB9
    xend
  }
}

//----- (0000000140060D76) ----------------------------------------------------
unsigned __int64 __fastcall sub_140060D76(_QWORD *a1, __int64 a2)
{
  unsigned __int64 result; // rax

  result = 0xAAAAAAAAAAAAAA01ui64;
  if ( *a1 == 0xAAAAAAAAAAAAAA01ui64 )
  {
    result = 0xAAAAAAAAAAAAAA02ui64;
    if ( *(a2 + 128) == 0xAAAAAAAAAAAAAA02ui64 )
    {
      MEMORY[0xAAAAAAAAAAAAAA03](-1i64);
      return 0xAAAAAAAAAAAAAA02ui64;
    }
  }
  return result;
}

//----- (0000000140060E00) ----------------------------------------------------
__int64 __fastcall sub_140060E00(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  bool v4; // cf
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r9

  v3 = a2 - a1;
  if ( a3 < 8 )
    goto LABEL_6;
  for ( ; (a1 & 7) != 0; --a3 )
  {
    v4 = *a1 < *(a1 + v3);
    if ( *a1 != *(a1 + v3) )
      return -v4 - (v4 - 1);
    a1 = (a1 + 1);
  }
  if ( !(a3 >> 3) )
  {
LABEL_6:
    if ( !a3 )
      return 0i64;
    while ( 1 )
    {
      v4 = *a1 < *(a1 + v3);
      if ( *a1 != *(a1 + v3) )
        break;
      a1 = (a1 + 1);
      if ( !--a3 )
        return 0i64;
    }
    return -v4 - (v4 - 1);
  }
  v6 = a3 >> 5;
  if ( a3 >> 5 )
  {
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(a1 + v3) )
        break;
      v7 = a1[1];
      if ( v7 != *(a1 + v3 + 8) )
        goto LABEL_24;
      v7 = a1[2];
      if ( v7 != *(a1 + v3 + 16) )
        goto LABEL_23;
      v7 = a1[3];
      if ( v7 != *(a1 + v3 + 24) )
      {
        ++a1;
LABEL_23:
        ++a1;
LABEL_24:
        ++a1;
        break;
      }
      a1 += 4;
      if ( !--v6 )
      {
        a3 &= 0x1Fu;
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    v8 = a3 >> 3;
    if ( !(a3 >> 3) )
      goto LABEL_6;
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(a1 + v3) )
        break;
      ++a1;
      if ( !--v8 )
      {
        a3 &= 7u;
        goto LABEL_6;
      }
    }
  }
  v4 = _byteswap_uint64(v7) < _byteswap_uint64(*(a1 + v3));
  return -v4 - (v4 - 1);
}

//----- (0000000140060F00) ----------------------------------------------------
__m128 *__fastcall EAC_memcpy(_OWORD *dst, char *Src, unsigned __int64 Lenght)
{
  __m128 *result; // rax
  __int64 v4; // r11
  __int64 v5; // rdx
  __int128 v6; // xmm1
  bool v7; // cf
  __int64 v8; // rdx
  char v9; // r11
  _BYTE *v10; // rcx
  char v11; // r11
  char *v12; // r11
  __int64 v13; // rdx
  __m128 v14; // xmm0
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rcx
  __m128 v17; // xmm1
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  __int128 v20; // xmm1
  __int128 v21; // xmm2
  __int128 v22; // xmm3
  __m128 v23; // xmm4
  unsigned __int64 j; // r9
  unsigned __int64 v25; // r8
  unsigned __int64 v26; // r9
  __m128 v27; // xmm1
  __m128 v28; // xmm2
  __m128 v29; // xmm3
  __m128 v30; // xmm4
  char *v31; // rcx
  __int128 v32; // xmm0
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r8
  _OWORD *v35; // r11
  __int128 v36; // xmm1
  unsigned __int64 v37; // r9
  __int128 v38; // xmm1
  __int128 v39; // xmm2
  __int128 v40; // xmm3
  __int128 v41; // xmm4
  unsigned __int64 i; // r9
  unsigned __int64 v43; // r8

  result = dst;
  if ( Lenght < 8 )
  {
    if ( Lenght )
    {
      v7 = Src < dst;
      v8 = Src - dst;
      if ( v7 )
      {
        v10 = dst + Lenght;
        do
        {
          v11 = v10[v8 - 1];
          --v10;
          --Lenght;
          *v10 = v11;
        }
        while ( Lenght );
      }
      else
      {
        do
        {
          v9 = *(dst + v8);
          dst = (dst + 1);
          --Lenght;
          *(dst - 1) = v9;
        }
        while ( Lenght );
      }
    }
  }
  else if ( Lenght > 0x10 )
  {
    if ( Lenght > 0x20 )
    {
      v12 = &Src[Lenght];
      v7 = Src < dst;
      v13 = Src - dst;
      if ( v7 && v12 > dst )
      {
        v31 = dst + Lenght;
        v32 = *&v31[v13 - 16];
        v33 = (v31 - 16);
        v34 = Lenght - 16;
        if ( (v33 & 0xF) != 0 )
        {
          v35 = v33;
          v33 &= 0xFFFFFFFFFFFFFFF0ui64;
          v36 = *(v33 + v13);
          *v35 = v32;
          v32 = v36;
          v34 = v33 - result;
        }
        v37 = v34 >> 6;
        if ( v34 >> 6 )
        {
          v34 &= 0x3Fu;
          do
          {
            v38 = *(v33 + v13 - 0x10);
            v39 = *(v33 + v13 - 0x20);
            v40 = *(v33 + v13 - 0x30);
            v41 = *(v33 + v13 - 0x40);
            *v33 = v32;
            v33 -= 64i64;
            --v37;
            *(v33 + 0x30) = v38;
            *(v33 + 0x20) = v39;
            *(v33 + 0x10) = v40;
            v32 = v41;
          }
          while ( v37 );
        }
        for ( i = v34 >> 4; i; --i )
        {
          *v33 = v32;
          v32 = *(v33 + v13 - 16);
          v33 -= 16i64;
        }
        v43 = v34 & 0xF;
        if ( v43 )
          *(v33 - v43) = *(v33 - v43 + v13);
        *v33 = v32;
      }
      else
      {
        v14 = *(dst + v13);
        v15 = (dst + 1);
        if ( (v15 & 0xF) != 0 )
        {
          v16 = v15 & 0xFFFFFFFFFFFFFFF0ui64;
          v17 = *(v16 + v13);
          *result = v14;
          v14 = v17;
          v15 = v16 + 16;
        }
        v18 = result + Lenght - v15;
        v19 = v18 >> 6;
        if ( v18 >> 6 )
        {
          if ( v19 > 0x1000 )
          {
            v26 = v18 >> 6;
            v18 &= 0x3Fu;
            _mm_prefetch((v15 + v13 + 64), 0);
            do
            {
              v27 = *(v15 + v13);
              v28 = *(v15 + v13 + 16);
              v29 = *(v15 + v13 + 32);
              v30 = *(v15 + v13 + 48);
              _mm_stream_ps((v15 - 16), v14);
              v15 += 64i64;
              _mm_prefetch((v15 + v13 + 64), 0);
              --v26;
              _mm_stream_ps((v15 - 64), v27);
              _mm_stream_ps((v15 - 48), v28);
              _mm_stream_ps((v15 - 32), v29);
              v14 = v30;
            }
            while ( v26 );
            _mm_sfence();
          }
          else
          {
            v18 &= 0x3Fu;
            do
            {
              v20 = *(v15 + v13);
              v21 = *(v15 + v13 + 16);
              v22 = *(v15 + v13 + 32);
              v23 = *(v15 + v13 + 48);
              *(v15 - 16) = v14;
              v15 += 64i64;
              --v19;
              *(v15 - 64) = v20;
              *(v15 - 48) = v21;
              *(v15 - 32) = v22;
              v14 = v23;
            }
            while ( v19 );
          }
        }
        for ( j = v18 >> 4; j; --j )
        {
          *(v15 - 16) = v14;
          v14 = *(v15 + v13);
          v15 += 16i64;
        }
        v25 = v18 & 0xF;
        if ( v25 )
          *(v15 + v25 - 16) = *(v15 + v25 - 16 + v13);
        *(v15 - 16) = v14;
      }
    }
    else
    {
      v6 = *&Src[Lenght - 16];
      *dst = *Src;
      *(dst + Lenght - 16) = v6;
    }
  }
  else
  {
    v4 = *Src;
    v5 = *&Src[Lenght - 8];
    *dst = v4;
    *(dst + Lenght - 8) = v5;
  }
  return result;
}

//----- (00000001400611C0) ----------------------------------------------------
__m128 *__fastcall EAC_memset(__m128 *a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __m128 *result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // r9
  char *v6; // rcx
  unsigned __int64 v7; // r8
  __m128 v8; // xmm0
  char *v9; // r8
  __m128 *v10; // rcx
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // r9
  unsigned __int64 i; // r9
  __int64 v14; // r8

  result = a1;
  if ( a3 < 8 )
  {
    for ( ; a3; --a3 )
      a1->m128_i8[a3 - 1] = a2;
  }
  else
  {
    v4 = 0x101010101010101i64 * a2;
    if ( a3 >= 0x4F )
    {
      v8 = _mm_movelh_ps(v4, v4);
      *a1 = v8;
      v9 = a1 + a3;
      v10 = (&a1[1] & 0xFFFFFFFFFFFFFFF0ui64);
      v11 = v9 - v10;
      v12 = v11 >> 7;
      if ( v11 >> 7 )
      {
        do
        {
          *v10 = v8;
          v10[1] = v8;
          v10 += 8;
          v10[-6] = v8;
          v10[-5] = v8;
          --v12;
          v10[-4] = v8;
          v10[-3] = v8;
          v10[-2] = v8;
          v10[-1] = v8;
        }
        while ( v12 );
        v11 &= 0x7Fu;
      }
      for ( i = v11 >> 4; i; --i )
        *v10++ = v8;
      v14 = v11 & 0xF;
      if ( v14 )
        *(v10 + v14 - 16) = v8;
    }
    else
    {
      v5 = a3 & 0x78;
      v6 = a1 + (a3 & 0xFFFFFFFFFFFFFFF8ui64);
      do
      {
        *(&result->m128_u64[-1] + v5) = v4;
        v5 -= 8i64;
      }
      while ( v5 );
      v7 = a3 & 7;
      if ( v7 )
        *&v6[v7 - 8] = v4;
    }
  }
  return result;
}
// 1400611E3: mask 0xFFFFFFFFFFFFFFF8 is shortened because r8.8 <= 0x4E
// 140061210: masking with 0x7 was optimized away because r8.8 <= 0x7

//----- (000000014008A000) ----------------------------------------------------
char __fastcall sub_14008A000(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v4; // rbx
  char result; // al

  v4 = *(a1 + 0x70);
  if ( v4 )
  {
    if ( *(a2 + 8) == 4 )
    {
      result = sub_14001D338(*(a1 + 0x70), 4i64);
      *v4 = 0x43;
      *a3 = 4;
    }
  }
  return result;
}

//----- (000000014008A91C) ----------------------------------------------------
void __fastcall sub_14008A91C(__int64 *a1, __int64 a2, unsigned int *a3)
{
  char *v4; // rsi
  unsigned int v5; // r14d
  ULONG64 v6; // rbx
  unsigned int v7; // r15d
  unsigned int v8; // eax
  unsigned int v9; // eax
  __int64 *v10; // rax
  __int64 *v11; // rbx
  ULONG64 v12; // r14
  char *Memory; // rax
  char *v14; // rsi
  __int64 v15; // rcx
  int v16; // eax
  int v17; // ebx
  _PEB *ProcessPeb; // rax
  char *v19; // rax
  char *v20; // rsi
  __int64 v21; // rax
  __int64 Buffer; // [rsp+28h] [rbp-80h]
  unsigned int v24; // [rsp+30h] [rbp-78h]
  ULONG64 v25; // [rsp+38h] [rbp-70h]
  char *v26; // [rsp+40h] [rbp-68h]
  unsigned int v27; // [rsp+48h] [rbp-60h]
  unsigned __int64 v28; // [rsp+50h] [rbp-58h]
  char *v29; // [rsp+58h] [rbp-50h]
  char *v30; // [rsp+60h] [rbp-48h]
  _OWORD *v31; // [rsp+70h] [rbp-38h]
  unsigned int v32; // [rsp+C8h] [rbp+20h]

  a1 = 0i64;
  Buffer = 0i64;
  v26 = 0i64;
  v29 = 0i64;
  v4 = *(a2 + 0x20);
  v30 = v4;
  v5 = *(a2 + 0x10);
  v6 = a1[0xE];
  v31 = v6;
  v7 = *(a2 + 8);

  EAC_IsUsermodeValidAddress(v4, v5, 1);
  EAC_IsUsermodeValidAddress(v6, v7, 1);

  if ( v5 >= 0xC && v5 == v7 )
  {
    if ( *v4 == 1 )
    {
      v26 = v4;
      v8 = 0x24;
    }
    else
    {
      if ( *v4 != 2 )
        goto LABEL_55;

      v29 = v4;
      v8 = 0x2C;
    }
    v24 = v8;
    if ( v5 >= v8 && v7 >= v8 )
    {
      v9 = *(v4 + 2);
      if ( v9 )
      {
        v10 = sub_14000D7E8(v9);
        v11 = v10;
        a1 = v10;
        if ( v10 )
        {
          if ( !sub_14002322C(*v10) && !_InterlockedCompareExchange(v11 + 0x20, 0, 0) )
          {
            if ( PsGetCurrentThreadId() != a1[4] )
              goto LABEL_29;

            if ( *v4 == 1 )
            {
              v27 = *(v26 + 5);
              if ( !*(v26 + 0xC)
                && (*(v26 + 5) - 1) <= 0xFFF
                && (*(v26 + 7) & 0x1000) != 0
                && *(v26 + 8) == 4
                && !_InterlockedCompareExchange(a1 + 0x46, 1, 0) )
              {
                *(a1 + 0x42) = v27;
                *(a1 + 0x43) = v27;
                v21 = a1[32];
                a1[0x22] = v21;
                *(v26 + 0xC) = v21;
                *(v26 + 0x14) = (v27 + 0xFFFi64) & 0xFFFFFFFFFFFFF000ui64;
                *(v26 + 1) = 0;
LABEL_54:
                EAC_memcpy(v31, v30, v24);
                *a3 = v24;
                goto LABEL_55;
              }
              goto LABEL_29;
            }

            if ( *v4 != 2 )
              goto LABEL_29;

            v25 = *(v29 + 0x14);
            v12 = *(v29 + 0xC);
            v28 = v12;
            v32 = *(v29 + 7);

            if ( Check_Process_Architecture() == 32 )
              v25 = v25;

            if ( *(a1 + 0xA) == 32 )
            {
              v12 = v12;
              v28 = v12;
            }
            if ( v25 && v12 && v32 )
            {
              EAC_IsUsermodeValidAddress(v25, v32, 1);
              EAC_IsUsermodeValidAddress(v12, v32, 1);
              if ( v12 == a1[34] && v32 <= *(a1 + 67) )
              {
                if ( *(a1 + 70) == 1 )
                {
                  *(a1 + 67) -= v32;
                  a1[34] += v32;
                  Memory = EAC_Allocate_Memory(v32);
                  v14 = Memory;
                  Buffer = Memory;

                  if ( !Memory )
                    goto LABEL_29;

                  EAC_memcpy(Memory, v25, v32);
                  sub_140053690(a1[2], v28, v14, v32);
                  v15 = v14;
                  goto LABEL_28;
                }
                v12 = v28;
              }
              v16 = *(a1 + 0xA);
              if ( v16 == 32 )
              {
                v17 = 4;
                ProcessPeb = Get_PsGetProcessWow64Process2(a1[1]);
              }
              else if ( v16 == 64 )
              {
                v17 = 8;
                ProcessPeb = Get_PsGetProcessPeb(a1[1]);
              }
              else
              {
                v17 = 0;
                ProcessPeb = 0i64;
              }
              if ( v32 == v17 && v12 > ProcessPeb && v12 < &ProcessPeb[4].TlsExpansionBitmapBits[8] )
              {
                v19 = EAC_Allocate_Memory(v32);
                v20 = v19;
                Buffer = v19;
                if ( v19 )
                {
                  EAC_memcpy(v19, v25, v32);
                  if ( !sub_140060E00(v20, (a1 + 0x20), v32) )
                    sub_140053690(a1[2], v12, v20, v32);

                  v15 = Buffer;
LABEL_28:
                  Get_ExFreePool(v15);
                  Buffer = 0i64;
                }
              }
LABEL_29:
              if ( *v30 == 1 )
              {
                if ( !*(v26 + 12) )
                  *(v26 + 12) = 0x10000i64;
                *(v26 + 20) = (*(v26 + 20) + 4095i64) & 0xFFFFFFFFFFFFF000ui64;
                *(v26 + 1) = 0;
              }
              else if ( *v30 == 2 )
              {
                *(v29 + 36) = *(v29 + 28);
                *(v29 + 1) = 0;
              }
              goto LABEL_54;
            }
          }
        }
      }
    }
  }
LABEL_55:

  if ( Buffer )
    Get_ExFreePool(Buffer);

  if ( a1 )
    sub_14000D924(a1);
}

//----- (000000014008C000) ----------------------------------------------------
bool sub_14008C000()
{
  unsigned int BuildNumbe; // ecx

  BuildNumbe = Get_BuildNumber();
  return KUSER_SHARED_DATA.NtMajorVersion < 5
      || BuildNumbe < 0xA28
      || KUSER_SHARED_DATA.NtMajorVersion == 5 && KUSER_SHARED_DATA.NtMinorVersion != 1
      || BuildNumbe - 5048 <= 0x3B8;
}
// FFFFF78000000000: using guessed type _KUSER_SHARED_DATA KUSER_SHARED_DATA;

//----- (0000000140090000) ----------------------------------------------------
__int64 __fastcall sub_140090000()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rdi
  unsigned __int64 v2; // rbp

  v2 = 0xFFFFFFFFF3DCE7A2ui64;
  if ( ((v1 - v0) >> 1) + v0 + 1 >= v1 )
    v2 = 0xFFFFFFFFF45E0D2Dui64;
  return ((v2 + 0x14C2C1860i64))();
}
// 140090003: variable 'v1' is possibly undefined
// 140090005: variable 'v0' is possibly undefined
// 140090000: using guessed type __int64 __fastcall sub_140090000();

//----- (000000014028D9E5) ----------------------------------------------------
void __fastcall sub_14028D9E5()
{
  __asm { retf }
}
// 14028D9E6: unbalanced stack, ignored a potential tail call

//----- (00000001402E9E6A) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_1402E9E6A(float a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r9
  __int64 v5; // r8
  void *v6; // rsp
  unsigned __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned __int64 v10; // rax
  bool v11; // zf
  __int64 v12; // rax
  __int64 v13; // [rsp-18h] [rbp-18h]
  __int64 v14; // [rsp-8h] [rbp-8h]
  void (__fastcall *retaddr)(unsigned __int64, __int64, __int64, __int64); // [rsp+0h] [rbp+0h] BYREF

  while ( 1 )
  {
    v7 = LODWORD(a1) & 0x254C4A8;
    v8 = 16818691i64;
    v9 = 16818691i64;
    do
    {
      v10 = v7 & v8;
      v7 ^= v9;
      v11 = 2 * v10 == 0;
      v8 = 2 * v10;
      v9 = v8;
    }
    while ( !v11 );
    if ( 2 * v7 > v7 )
      break;
    _InterlockedExchange64(&retaddr, 0x14029C508i64);
    v14 = a4;
    v4 = v8;
    v13 = a3;
    v5 = v8;
    do
    {
      v12 = v4 & v8;
      v4 ^= v5;
      v11 = 2 * v12 == 0;
      v8 = 2 * v12;
      v5 = v8;
    }
    while ( !v11 );
    v6 = alloca(v4 & 1);
    retaddr(v7, v9, v13, v14);
  }
  JUMPOUT(0x14017313Di64);
}
// 14015E48D: positive sp value 8 has been found
// 1408D54AE: control flows out of bounds to 14017313D
// 14015E491: variable 'a4' is possibly undefined
// 14015E49A: variable 'a3' is possibly undefined
// 1401721F8: using guessed type __int64[512];

//----- (000000014037006E) ----------------------------------------------------
#error "14037006B: call analysis failed (funcsize=73)"

//----- (0000000140766C1B) ----------------------------------------------------
void __noreturn sub_140766C1B()
{
  JUMPOUT(0x14054155Fi64);
}
// 1405410C8: using guessed type __int64[304];

//----- (0000000140796649) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140796649()
{
  ;
}
// 1407966C8: positive sp value 108 has been found
// 140796649: could not find valid save-restore pair for rbp
// 140796649: could not find valid save-restore pair for r12
// 140796649: could not find valid save-restore pair for r13
// 140796649: could not find valid save-restore pair for r14
// 140796649: could not find valid save-restore pair for r15
// 140796649: could not find valid save-restore pair for xmm7
// 140796649: could not find valid save-restore pair for xmm9
// 140796649: could not find valid save-restore pair for xmm13

// nfuncs=602 queued=595 decompiled=595 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 595 function(s)"
